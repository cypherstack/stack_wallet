/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import 'package:isar/isar.dart';

import '../../../../exceptions/address/address_exception.dart';
import 'crypto_currency_address.dart';
import 'transaction.dart';

part 'address.g.dart';

@Collection(accessor: "addresses")
class Address extends CryptoCurrencyAddress {
  Address({
    required this.walletId,
    required this.value,
    required this.publicKey,
    required this.derivationIndex,
    required this.derivationPath,
    required this.type,
    required this.subType,
    this.zSafeFrost,
    this.otherData,
  });

  Id id = Isar.autoIncrement;

  @Index()
  late final String walletId;

  @Index(unique: true, composite: [CompositeIndex("walletId")])
  late final String value;

  late final List<byte> publicKey;

  @Index()
  late final int derivationIndex; // -1 generally means unknown

  @enumerated
  late final AddressType type;

  @enumerated
  late final AddressSubType subType;

  late final DerivationPath? derivationPath;

  late final String? otherData;

  final transactions = IsarLinks<Transaction>();

  late final bool? zSafeFrost;

  int derivationChain() {
    if (subType == AddressSubType.receiving) {
      return 0; // 0 for receiving (external)
    } else if (subType == AddressSubType.change) {
      return 1; // 1 for change (internal)
    } else {
      throw AddressException("Could not imply derivation chain value");
    }
  }

  bool isPaynymAddress() =>
      subType == AddressSubType.paynymNotification ||
      subType == AddressSubType.paynymSend ||
      subType == AddressSubType.paynymReceive;

  /// If called on an [Address] already stored in the DB be sure to update the
  /// [transactions] Isar Links if required
  Address copyWith({
    String? walletId,
    String? value,
    List<byte>? publicKey,
    int? derivationIndex,
    AddressType? type,
    AddressSubType? subType,
    DerivationPath? derivationPath,
    bool? zSafeFrost,
    String? otherData,
  }) {
    return Address(
      walletId: walletId ?? this.walletId,
      value: value ?? this.value,
      publicKey: publicKey ?? this.publicKey,
      derivationIndex: derivationIndex ?? this.derivationIndex,
      type: type ?? this.type,
      subType: subType ?? this.subType,
      derivationPath: derivationPath ?? this.derivationPath,
      zSafeFrost: zSafeFrost ?? this.zSafeFrost,
      otherData: otherData ?? this.otherData,
    );
  }

  @override
  String toString() => "{ "
      "id: $id, "
      "walletId: $walletId, "
      "value: $value, "
      "publicKey: $publicKey, "
      "derivationIndex: $derivationIndex, "
      "type: ${type.name}, "
      "subType: ${subType.name}, "
      "transactionsLength: ${transactions.length} "
      "derivationPath: $derivationPath, "
      "zSafeFrost: $zSafeFrost, "
      "otherData: $otherData, "
      "}";

  String toJsonString() {
    final Map<String, dynamic> result = {
      "walletId": walletId,
      "value": value,
      "publicKey": publicKey,
      "derivationIndex": derivationIndex,
      "type": type.name,
      "subType": subType.name,
      "derivationPath": derivationPath?.value,
      "zSafeFrost": zSafeFrost,
      "otherData": otherData,
    };
    return jsonEncode(result);
  }

  static Address fromJsonString(
    String jsonString, {
    String? overrideWalletId,
  }) {
    final json = jsonDecode(jsonString);
    final derivationPathString = json["derivationPath"] as String?;

    final DerivationPath? derivationPath =
        derivationPathString == null ? null : DerivationPath();
    if (derivationPath != null) {
      derivationPath.value = derivationPathString!;
    }

    return Address(
      walletId: overrideWalletId ?? json["walletId"] as String,
      value: json["value"] as String,
      publicKey: List<int>.from(json["publicKey"] as List),
      derivationIndex: json["derivationIndex"] as int,
      derivationPath: derivationPath,
      type: AddressType.values.byName(json["type"] as String),
      subType: AddressSubType.values.byName(json["subType"] as String),
      zSafeFrost: json["zSafeFrost"] as bool?,
      otherData: json["otherData"] as String?,
    );
  }
}

// do not modify unless you know what the consequences are
enum AddressType {
  p2pkh,
  p2sh,
  p2wpkh,
  cryptonote,
  mimbleWimble,
  unknown,
  nonWallet,
  ethereum,
  nano,
  banano,
  spark,
  stellar,
  tezos,
  frostMS,
  p2tr,
  solana;

  String get readableName {
    switch (this) {
      case AddressType.p2pkh:
        return "P2PKH";
      case AddressType.p2sh:
        return "Wrapped segwit";
      case AddressType.p2wpkh:
        return "P2WPKH (segwit)";
      case AddressType.cryptonote:
        return "Cryptonote";
      case AddressType.mimbleWimble:
        return "Mimble Wimble";
      case AddressType.unknown:
        return "Unknown";
      case AddressType.nonWallet:
        return "Non wallet/unknown";
      case AddressType.ethereum:
        return "Ethereum";
      case AddressType.nano:
        return "Nano";
      case AddressType.banano:
        return "Banano";
      case AddressType.spark:
        return "Spark";
      case AddressType.stellar:
        return "Stellar";
      case AddressType.tezos:
        return "Tezos";
      case AddressType.frostMS:
        return "FrostMS";
      case AddressType.solana:
        return "Solana";
      case AddressType.p2tr:
        return "P2TR (taproot)";
    }
  }
}

// do not modify
enum AddressSubType {
  receiving,
  change,
  paynymNotification,
  paynymSend,
  paynymReceive,
  unknown,
  nonWallet;

  String get prettyName {
    switch (this) {
      case AddressSubType.receiving:
        return "Receiving";
      case AddressSubType.change:
        return "Change";
      case AddressSubType.paynymNotification:
        return "PayNym Notification";
      case AddressSubType.paynymSend:
        return "PayNym Send";
      case AddressSubType.paynymReceive:
        return "PayNym Receiving";
      case AddressSubType.unknown:
        return "Unknown";
      case AddressSubType.nonWallet:
        return "Non wallet/unknown";
    }
  }
}

@Embedded(inheritance: false)
class DerivationPath {
  late final String value;

  List<String> getComponents() => value.split("/");

  String getPurpose() => getComponents()[1];

  @override
  toString() => value;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is DerivationPath && value == other.value;

  @ignore
  @override
  int get hashCode => value.hashCode;
}
