/*
 * This file is part of Stack Wallet.
 *
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-05-06
 *
 */

import 'dart:async';
import 'dart:math' as math;

import 'package:drift/drift.dart';
import 'package:drift_flutter/drift_flutter.dart';
import 'package:path/path.dart' as path;

import '../../utilities/stack_file_system.dart';

part 'database.g.dart';

abstract final class Drift {
  static bool _didInit = false;

  static final Map<String, WalletDatabase> _map = {};

  static WalletDatabase get(String walletId) {
    if (!_didInit) {
      driftRuntimeOptions.dontWarnAboutMultipleDatabases = true;
      _didInit = true;
    }

    return _map[walletId] ??= WalletDatabase._(walletId);
  }
}

class SparkNames extends Table {
  TextColumn get name =>
      text().customConstraint("UNIQUE NOT NULL COLLATE NOCASE")();
  TextColumn get address => text()();
  IntColumn get validUntil => integer()();
  TextColumn get additionalInfo => text().nullable()();

  @override
  Set<Column> get primaryKey => {name};
}

class MwebUtxos extends Table {
  TextColumn get outputId => text()();
  TextColumn get address => text()();
  IntColumn get value => integer()();
  IntColumn get height => integer()();
  IntColumn get blockTime => integer()();
  BoolColumn get blocked => boolean()();
  BoolColumn get used => boolean()();

  @override
  Set<Column> get primaryKey => {outputId};
}

extension MwebUtxoExt on MwebUtxo {
  int getConfirmations(int currentChainHeight) {
    if (blockTime <= 0) return 0;
    if (height <= 0) return 0;
    return math.max(0, currentChainHeight - (height - 1));
  }

  bool isConfirmed(
    int currentChainHeight,
    int minimumConfirms, {
    int? overrideMinConfirms,
  }) {
    final confirmations = getConfirmations(currentChainHeight);

    if (overrideMinConfirms != null) {
      return confirmations >= overrideMinConfirms;
    }
    return confirmations >= minimumConfirms;
  }
}

@DriftDatabase(tables: [SparkNames, MwebUtxos])
final class WalletDatabase extends _$WalletDatabase {
  WalletDatabase._(String walletId, [QueryExecutor? executor])
    : super(executor ?? _openConnection(walletId));

  @override
  int get schemaVersion => 2;

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onUpgrade: (m, from, to) async {
      if (from == 1 && to == 2) {
        await m.createTable(mwebUtxos);
      }
    },
  );

  static QueryExecutor _openConnection(String walletId) {
    return driftDatabase(
      name: walletId,
      native: DriftNativeOptions(
        shareAcrossIsolates: true,
        databasePath: () async {
          final dir = await StackFileSystem.applicationDriftDirectory();
          return path.join(dir.path, "wallets", walletId, "$walletId.db");
        },
      ),
    );
  }

  Future<void> upsertSparkNames(
    List<
      ({String name, String address, int validUntil, String? additionalInfo})
    >
    names,
  ) async {
    await transaction(() async {
      for (final name in names) {
        await into(sparkNames).insertOnConflictUpdate(
          SparkNamesCompanion(
            name: Value(name.name),
            address: Value(name.address),
            validUntil: Value(name.validUntil),
            additionalInfo: Value(name.additionalInfo),
          ),
        );
      }
    });
  }
}
