/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';
import 'dart:io';

import 'package:digest_auth/digest_auth.dart';
import 'package:flutter/material.dart';
import 'package:http/io_client.dart';
import 'package:monero_rpc/monero_rpc.dart';
import 'package:socks5_proxy/socks.dart';
import 'package:tor_ffi_plugin/socks_socket.dart';

import '../widgets/desktop/primary_button.dart';
import '../widgets/desktop/secondary_button.dart';
import '../widgets/stack_dialog.dart';
import 'format.dart';
import 'logger.dart';

class MoneroNodeConnectionResponse {
  final X509Certificate? cert;
  final String? url;
  final int? port;
  final bool success;

  MoneroNodeConnectionResponse(
    this.cert,
    this.url,
    this.port,
    this.success,
  );
}

Future<MoneroNodeConnectionResponse> testMoneroNodeConnection(
  Uri uri,
  String? username,
  String? password,
  bool allowBadX509Certificate, {
  required ({
    InternetAddress host,
    int port,
  })? proxyInfo,
}) async {
  if (uri.host.endsWith(".onion")) {
    if (proxyInfo == null) {
      // If the host ends in .onion, we can't access it without Tor.
      return MoneroNodeConnectionResponse(null, null, null, false);
    }

    SOCKSSocket? socket;
    try {
      // An HttpClient cannot be used for onion nodes.
      //
      // The SOCKSSocket class from the tor_ffi_plugin package can be used to
      // connect to .onion addresses.  We'll do the same things as above but
      // with SOCKSSocket instead of httpClient.
      socket = await SOCKSSocket.create(
        proxyHost: proxyInfo.host.address,
        proxyPort: proxyInfo.port,
        sslEnabled: false,
      );
      await socket.connect();
      await socket.connectTo(uri.host, uri.port);

      final rawRequest = DaemonRpc.rawRequestRpc(uri, 'get_info', {});
      var response = await socket.send(rawRequest);
      // check if we need authentication
      String? authenticateHeaderValue;
      for (final line in response.split('\r\n')) {
        if (line.contains('WWW-authenticate: ')) {
          // both the password and username needs to be
          if (username == null || password == null) {
            // node asking us for authentication, but we don't have any crendentials.
            return MoneroNodeConnectionResponse(null, null, null, false);
          }
          authenticateHeaderValue =
              line.replaceFirst('WWW-authenticate: ', '').trim();
        }
      }
      // header to authenticate was present, we need to remake the request with digest
      if (authenticateHeaderValue != null) {
        final digestAuth = DigestAuth(username!, password!);
        digestAuth.initFromAuthorizationHeader(authenticateHeaderValue);

        // generate the Authorization header for the second request.
        final authHeader = digestAuth.getAuthString('POST', uri.path);
        final rawRequestAuthenticated =
            DaemonRpc.rawRequestRpc(uri, 'get_info', {}, authHeader);
        // resend with an authenticated request
        response = await socket.send(rawRequestAuthenticated);
      }

      // Check if the response contains "results" and does not contain "error"
      final success =
          response.contains('"result":') && !response.contains('"error"');

      return MoneroNodeConnectionResponse(null, null, null, success);
    } catch (e, s) {
      Logging.instance.w("$e\n$s", error: e, stackTrace: s,);
      return MoneroNodeConnectionResponse(null, null, null, false);
    } finally {
      await socket?.close();
    }
  } else {
    final httpClient = HttpClient();
    MoneroNodeConnectionResponse? badCertResponse;
    try {
      if (proxyInfo != null) {
        SocksTCPClient.assignToHttpClient(httpClient, [
          ProxySettings(
            proxyInfo.host,
            proxyInfo.port,
          ),
        ]);
      }

      httpClient.badCertificateCallback = (cert, url, port) {
        if (allowBadX509Certificate) {
          return true;
        }

        if (badCertResponse == null) {
          badCertResponse =
              MoneroNodeConnectionResponse(cert, url, port, false);
        } else {
          return false;
        }

        return false;
      };
      final daemonRpc = DaemonRpc(
        IOClient(httpClient),
        '$uri',
        username: username,
        password: password,
      );
      final result = await daemonRpc.call('get_info', {});

      final success = result.containsKey('status') && result['status'] == 'OK';

      return MoneroNodeConnectionResponse(null, null, null, success);
    } catch (e, s) {
      if (badCertResponse != null) {
        return badCertResponse!;
      } else {
        Logging.instance.w("$e\n$s", error: e, stackTrace: s,);
        return MoneroNodeConnectionResponse(null, null, null, false);
      }
    } finally {
      httpClient.close(force: true);
    }
  }
}

Future<bool> showBadX509CertificateDialog(
  X509Certificate cert,
  String url,
  int port,
  BuildContext context,
) async {
  final chars = Format.uint8listToString(cert.sha1)
      .toUpperCase()
      .characters
      .toList(growable: false);

  String sha1 = chars.sublist(0, 2).join();
  for (int i = 2; i < chars.length; i += 2) {
    sha1 += ":${chars.sublist(i, i + 2).join()}";
  }

  final result = await showDialog<bool>(
    context: context,
    barrierDismissible: false,
    builder: (context) {
      return StackDialog(
        title: "Untrusted X509Certificate",
        message: "SHA1:\n$sha1",
        leftButton: SecondaryButton(
          label: "Cancel",
          onPressed: () {
            Navigator.of(context).pop(false);
          },
        ),
        rightButton: PrimaryButton(
          label: "Trust",
          onPressed: () {
            Navigator.of(context).pop(true);
          },
        ),
      );
    },
  );

  return result ?? false;
}

extension on SOCKSSocket {
  /// write the raw request to the socket and return the response as String
  Future<String> send(String rawRequest) async {
    write(rawRequest);
    final buffer = StringBuffer();
    await for (final response in inputStream) {
      buffer.write(utf8.decode(response));
      if (buffer.toString().contains("\r\n\r\n")) {
        break;
      }
    }
    return buffer.toString();
  }
}
