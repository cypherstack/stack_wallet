/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import '../app_config.dart';
import '../wallets/crypto_currency/crypto_currency.dart';
import 'logger.dart';

class AddressUtils {
  static final Set<String> recognizedParams = {
    'amount',
    'label',
    'message',
    'tx_amount', // For Monero/Wownero.
    'tx_payment_id',
    'recipient_name',
    'tx_description',
    // TODO [prio=med]: Add more recognized params for other coins.
  };

  static String condenseAddress(String address) {
    return '${address.substring(0, 5)}...${address.substring(address.length - 5)}';
  }

  /// Return only recognized parameters.
  static Map<String, String> _filterParams(Map<String, String> params) {
    return Map.fromEntries(
      params.entries.where(
        (entry) => recognizedParams.contains(entry.key.toLowerCase()),
      ),
    );
  }

  /// Parses a URI string and returns a map with parsed components.
  static Map<String, String> _parseUri(String uri) {
    final Map<String, String> result = {};
    try {
      final u = Uri.parse(uri);
      if (u.hasScheme) {
        result["scheme"] = u.scheme.toLowerCase();

        // Handle different URI formats.
        if (result["scheme"] == "bitcoin" ||
            result["scheme"] == "bitcoincash") {
          result["address"] = u.path;
        } else if (result["scheme"] == "monero") {
          // Monero addresses can contain '?' which Uri.parse interprets as query start.
          final addressEnd = uri.indexOf(
            '?',
            7,
          ); // 7 is the length of "monero:".
          if (addressEnd != -1) {
            result["address"] = uri.substring(7, addressEnd);
          } else {
            result["address"] = uri.substring(7);
          }
        } else {
          // Default case, treat path as address.
          result["address"] = u.path;
        }

        // Parse query parameters.
        result.addAll(_parseQueryParameters(u.queryParameters));

        // Handle Monero-specific fragment (tx_description).
        if (u.fragment.isNotEmpty && result["scheme"] == "monero") {
          result["tx_description"] = Uri.decodeComponent(u.fragment);
        }
      }
    } catch (e, s) {
      Logging.instance.d(
        "Exception caught in parseUri($uri): $e",
        error: e,
        stackTrace: s,
      );
    }
    return result;
  }

  /// Helper method to parse and normalize query parameters.
  static Map<String, String> _parseQueryParameters(Map<String, String> params) {
    final Map<String, String> result = {};
    params.forEach((key, value) {
      final lowerKey = key.toLowerCase();
      if (recognizedParams.contains(lowerKey)) {
        switch (lowerKey) {
          case 'amount':
          case 'tx_amount':
            result['amount'] = _normalizeAmount(value);
            break;
          case 'label':
          case 'recipient_name':
            result['label'] = Uri.decodeComponent(value);
            break;
          case 'message':
          case 'tx_description':
            result['message'] = Uri.decodeComponent(value);
            break;
          case 'tx_payment_id':
            result['tx_payment_id'] = Uri.decodeComponent(value);
            break;
          default:
            result[lowerKey] = Uri.decodeComponent(value);
        }
      } else {
        // Include unrecognized parameters as-is.
        result[key] = Uri.decodeComponent(value);
      }
    });
    return result;
  }

  /// Normalizes amount value to a standard format.
  static String _normalizeAmount(String amount) {
    // Remove any non-numeric characters except for '.'
    final sanitized = amount.replaceAll(RegExp(r'[^\d.]'), '');
    // Ensure only one decimal point
    final parts = sanitized.split('.');
    if (parts.length > 2) {
      return '${parts[0]}.${parts.sublist(1).join()}';
    }
    return sanitized;
  }

  /// Centralized method to handle various cryptocurrency URIs and return a common object.
  ///
  /// Returns null on failure to parse
  static PaymentUriData? parsePaymentUri(String uri, {Logging? logging}) {
    // hacky check its not just a bcash, ecash, or xel address
    final parts = uri.split(":");
    if (parts.length == 2) {
      if ([
        "xel",
        "bitcoincash",
        "bchtest",
        "ecash",
        "ectest",
      ].contains(parts.first.toLowerCase())) {
        return null;
      }
    }

    try {
      final Map<String, String> parsedData = _parseUri(uri);

      // Normalize the URI scheme.
      final String scheme = parsedData['scheme'] ?? '';
      parsedData.remove('scheme');

      // Filter out unrecognized parameters.
      final filteredParams = _filterParams(parsedData);

      return PaymentUriData(
        scheme: scheme,
        address: parsedData['address']!.trim(),
        amount: filteredParams['amount'] ?? filteredParams['tx_amount'],
        label: filteredParams['label'] ?? filteredParams['recipient_name'],
        message: filteredParams['message'] ?? filteredParams['tx_description'],
        paymentId: filteredParams['tx_payment_id'],
        // Specific to Monero
        additionalParams: filteredParams,
      );
    } catch (e, s) {
      logging?.i("Invalid payment URI: $uri", error: e, stackTrace: s);
      return null;
    }
  }

  /// Parses a wallet URI and returns a Map.
  ///
  /// Returns null on failure to parse.
  static Map<String, dynamic>? _parseWalletUri(String uri) {
    final String scheme;
    final Map<String, dynamic> parsedData = {};
    if (uri.split(":")[0].contains("_")) {
      // We need to check if the uri is compatible because RFC 3986 does not allow underscores in the scheme
      final String compatibleUri = uri.replaceFirst("_", "");
      scheme = uri.split(":")[0];
      parsedData.addAll(_parseUri(compatibleUri));
    } else {
      parsedData.addAll(_parseUri(uri));
      scheme = parsedData['scheme'] as String? ?? '';
    }

    // not sure this is the best way to handle this but will leave as is for now
    final possibleCoins = AppConfig.coins.where(
      (e) => "${e.uriScheme}_wallet".contains(scheme),
    );

    if (possibleCoins.length != 1) {
      return null;
    }

    parsedData["coin"] = possibleCoins.first;

    return parsedData;
  }

  /// Builds a uri string with the given address and query parameters (if any)
  static String buildUriString(
    String scheme,
    String address,
    Map<String, String> params,
  ) {
    // Filter unrecognized parameters.
    final filteredParams = _filterParams(params);
    String uriString;

    // cashaddrs strike again
    if (address.startsWith("$scheme:")) {
      uriString = address;
    } else {
      uriString = "$scheme:$address";
    }

    if (scheme.toLowerCase() == "monero") {
      // Handle Monero-specific formatting.
      if (filteredParams.containsKey("tx_description")) {
        final description = filteredParams.remove("tx_description")!;
        if (filteredParams.isNotEmpty) {
          uriString += Uri(queryParameters: filteredParams).toString();
        }
        uriString += "#${Uri.encodeComponent(description)}";
      } else if (filteredParams.isNotEmpty) {
        uriString += Uri(queryParameters: filteredParams).toString();
      }
    } else {
      // General case for other cryptocurrencies.
      if (filteredParams.isNotEmpty) {
        uriString += Uri(queryParameters: filteredParams).toString();
      }
    }

    return uriString;
  }

  /// returns empty if bad data
  static Map<String, dynamic> decodeQRSeedData(String data) {
    Map<String, dynamic> result = {};
    try {
      result = Map<String, dynamic>.from(jsonDecode(data) as Map);
    } catch (e, s) {
      Logging.instance.d(
        "Exception caught in parseQRSeedData($data)",
        error: e,
        stackTrace: s,
      );
    }
    return result;
  }

  /// encode mnemonic words to qrcode formatted string
  static String encodeQRSeedData(List<String> words) {
    return jsonEncode({"mnemonic": words});
  }

  /// Method to get CryptoCurrency based on URI scheme.
  static CryptoCurrency? _getCryptoCurrencyByScheme(String scheme) {
    if (AppConfig.coins.map((e) => e.uriScheme).toSet().contains(scheme)) {
      return AppConfig.coins.firstWhere((e) => e.uriScheme == scheme);
    } else {
      return null;
      // throw UnsupportedError('Unsupported URI scheme: $scheme');
    }
  }

  /// Formats an address string to remove any unnecessary prefixes or suffixes.
  String formatEpicCashAddress(String epicAddress) {
    // strip http:// or https:// prefixes if the address contains an @ symbol (and is thus an epicbox address)
    if ((epicAddress.startsWith("http://") ||
            epicAddress.startsWith("https://")) &&
        epicAddress.contains("@")) {
      epicAddress = epicAddress.replaceAll("http://", "");
      epicAddress = epicAddress.replaceAll("https://", "");
    }
    // strip mailto: prefix
    if (epicAddress.startsWith("mailto:")) {
      epicAddress = epicAddress.replaceAll("mailto:", "");
    }
    // strip / suffix if the address contains an @ symbol (and is thus an epicbox address)
    if (epicAddress.endsWith("/") && epicAddress.contains("@")) {
      epicAddress = epicAddress.substring(0, epicAddress.length - 1);
    }
    return epicAddress;
  }
}

class PaymentUriData {
  final String address;
  final String? scheme;
  final String? amount;
  final String? label;
  final String? message;
  final String? paymentId; // Specific to Monero.
  final Map<String, String> additionalParams;

  CryptoCurrency? get coin => AddressUtils._getCryptoCurrencyByScheme(
    scheme ?? "", // empty will just return null
  );

  PaymentUriData({
    required this.address,
    this.scheme,
    this.amount,
    this.label,
    this.message,
    this.paymentId,
    required this.additionalParams,
  });

  @override
  String toString() =>
      "PaymentUriData { "
      "coin: $coin, "
      "address: $address, "
      "amount: $amount, "
      "scheme: $scheme, "
      "label: $label, "
      "message: $message, "
      "paymentId: $paymentId, "
      "additionalParams: $additionalParams"
      " }";
}

class WalletUriData {
  final CryptoCurrency coin;
  final String? address;
  final String? seed;
  final String? spendKey;
  final String? viewKey;
  final int? height;
  final List<String>? txids;

  WalletUriData({
    required this.coin,
    this.address,
    this.seed,
    this.spendKey,
    this.viewKey,
    this.height,
    this.txids,
  });

  factory WalletUriData.fromUriString(String uri) {
    final map = AddressUtils._parseWalletUri(uri);

    if (map == null) {
      throw Exception("Invalid wallet URI");
    }

    return WalletUriData.fromJson(map, map["coin"] as CryptoCurrency);
  }

  /// Factory constructor with validation logic according to the spec:
  /// https://github.com/monero-project/monero/wiki/URI-Formatting#wallet-definition-scheme
  factory WalletUriData.fromJson(
    Map<String, dynamic> json,
    CryptoCurrency coin,
  ) {
    final address = json["address"] as String?;
    final spendKey = json["spend_key"] as String?;
    final viewKey = json["view_key"] as String?;
    final seed = json["seed"] as String?;
    final height =
        json["height"] != null ? int.tryParse(json["height"].toString()) : null;
    final txid = json["txid"] as String?;

    // Rule: address is required
    if (address == null || address.isEmpty) {
      throw const FormatException("Missing required field: address");
    }

    // Rule: Only one of seed OR (spend_key + view_key) may/must be specified
    final hasSeed = seed != null;
    final hasKeyPair = spendKey != null && viewKey != null;

    if (hasSeed && hasKeyPair) {
      throw const FormatException(
        "Invalid: cannot specify both seed and (spend_key, view_key).",
      );
    }
    if (!hasSeed && !hasKeyPair) {
      throw const FormatException(
        "Invalid: must specify either seed OR (spend_key, view_key).",
      );
    }

    // Rule: spend_key requires address + view_key
    if (spendKey != null && viewKey == null) {
      throw const FormatException("Invalid: spend_key requires view_key.");
    }

    // Rule: view_key requires address (already required anyway) and absence of seed
    if (viewKey != null && hasSeed) {
      throw const FormatException(
        "Invalid: view_key cannot be specified together with seed.",
      );
    }

    // Rule: height requires absence of txid
    if (height != null && txid != null) {
      throw const FormatException(
        "Invalid: cannot specify both height and txid.",
      );
    }

    // Parse txids if present
    List<String>? txids;
    if (txid != null && txid.isNotEmpty) {
      txids =
          txid
              .split(";")
              .map((s) => s.trim())
              .where((s) => s.isNotEmpty)
              .toList();
    }

    return WalletUriData(
      coin: coin,
      address: address,
      spendKey: spendKey,
      viewKey: viewKey,
      seed: seed,
      height: height,
      txids: txids,
    );
  }

  @override
  String toString() {
    return "WalletUriData { "
        "coin: $coin, "
        "address: $address, "
        "seed: $seed, "
        "spendKey: $spendKey, "
        "viewKey: $viewKey, "
        "height: $height, "
        "txids: $txids"
        " }";
  }

  String toJson() {
    return jsonEncode({
      "coin": coin.prettyName,
      "address": address,
      "seed": seed,
      "spendKey": spendKey,
      "viewKey": viewKey,
      "height": height,
      "txids": txids,
    });
  }
}
