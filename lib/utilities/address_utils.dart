/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import '../app_config.dart';
import '../wallets/crypto_currency/crypto_currency.dart';
import 'logger.dart';

class AddressUtils {
  static final Set<String> recognizedParams = {
    'amount',
    'amounts',
    'label',
    'labels',
    'message',
    'tx_amount', // For Monero/Wownero.
    'recipient_name',
    'tx_description',
    // TODO [prio=med]: Add more recognized params for other coins.
  };

  static String condenseAddress(String address) {
    return '${address.substring(0, 5)}...${address.substring(address.length - 5)}';
  }

  /// Return only recognized parameters.
  static Map<String, String> _filterParams(Map<String, String> params) {
    return Map.fromEntries(
      params.entries.where(
        (entry) => recognizedParams.contains(entry.key.toLowerCase()),
      ),
    );
  }

  /// Parses a URI string and returns a map with parsed components.
  static Map<String, String> _parseUri(String uri) {
    final Map<String, String> result = {};
    try {
      final u = Uri.parse(uri);
      if (u.hasScheme) {
        result["scheme"] = u.scheme.toLowerCase();

        // Handle different URI formats.
        if (result["scheme"] == "bitcoin" ||
            result["scheme"] == "bitcoincash") {
          result["address"] = u.path;
        } else if (result["scheme"] == "monero") {
          // Monero addresses can contain '?' which Uri.parse interprets as query start.
          final addressEnd = uri.indexOf(
            '?',
            7,
          ); // 7 is the length of "monero:".
          String addressPart;
          if (addressEnd != -1) {
            addressPart = uri.substring(7, addressEnd);
          } else {
            addressPart = uri.substring(7);
          }
          // Handle multiple semicolon-separated addresses.
          final addresses = addressPart.split(';').map((addr) => addr.trim()).where((addr) => addr.isNotEmpty).toList();
          if (addresses.length > 1) {
            result["addresses"] = addresses.join(';');
          }
          result["address"] = addresses.isNotEmpty ? addresses.first : '';  // Backward compatibility.
        } else {
          // Default case, treat path as address.
          result["address"] = u.path;
        }

        // Parse query parameters.
        result.addAll(_parseQueryParameters(u.queryParameters));

        // Handle Monero-specific fragment (tx_description).
        if (u.fragment.isNotEmpty && result["scheme"] == "monero") {
          result["tx_description"] = Uri.decodeComponent(u.fragment);
        }
      }
    } catch (e, s) {
      Logging.instance.d(
        "Exception caught in parseUri($uri): $e",
        error: e,
        stackTrace: s,
      );
    }
    return result;
  }

  /// Helper method to parse and normalize query parameters.
  static Map<String, String> _parseQueryParameters(Map<String, String> params) {
    final Map<String, String> result = {};
    params.forEach((key, value) {
      final lowerKey = key.toLowerCase();
      if (recognizedParams.contains(lowerKey)) {
        switch (lowerKey) {
          case 'amount':
          case 'tx_amount':
            // Handle multiple semicolon-separated amounts.
            final amounts = value.split(';').map((amt) => _normalizeAmount(amt.trim())).where((amt) => amt.isNotEmpty).toList();
            if (amounts.length > 1) {
              result['amounts'] = amounts.join(';');
            }
            result['amount'] = amounts.isNotEmpty ? amounts.first : '';  // Backward compatibility.
            break;
          case 'label':
          case 'recipient_name':
            // Handle multiple semicolon-separated labels.
            final labels = value.split(';').map((lbl) => Uri.decodeComponent(lbl.trim())).where((lbl) => lbl.isNotEmpty).toList();
            result['labels'] = labels.join(';');
            result['label'] = labels.isNotEmpty ? labels.first : '';  // Backward compatibility.
            break;
          case 'message':
          case 'tx_description':
            result['message'] = Uri.decodeComponent(value);
            break;
          default:
            result[lowerKey] = Uri.decodeComponent(value);
        }
      } else {
        // Include unrecognized parameters as-is.
        result[key] = Uri.decodeComponent(value);
      }
    });
    return result;
  }

  /// Normalizes amount value to a standard format.
  static String _normalizeAmount(String amount) {
    // Remove any non-numeric characters except for '.'
    final sanitized = amount.replaceAll(RegExp(r'[^\d.]'), '');
    // Ensure only one decimal point
    final parts = sanitized.split('.');
    if (parts.length > 2) {
      return '${parts[0]}.${parts.sublist(1).join()}';
    }
    return sanitized;
  }

  /// Validates that the number of addresses matches the number of amounts for Monero multi-recipient URIs.
  static bool _validateMultiRecipient(List<String> addresses, List<String>? amounts) {
    if (amounts == null || amounts.isEmpty) {
      return true; // No amounts specified is valid.
    }
    return addresses.length == amounts.length;
  }

  /// Centralized method to handle various cryptocurrency URIs and return a common object.
  ///
  /// Returns null on failure to parse
  static PaymentUriData? parsePaymentUri(String uri, {Logging? logging}) {
    // hacky check its not just a bcash, ecash, or xel address
    final parts = uri.split(":");
    if (parts.length == 2) {
      if ([
        "xel",
        "bitcoincash",
        "bchtest",
        "ecash",
        "ectest",
      ].contains(parts.first.toLowerCase())) {
        return null;
      }
    }

    try {
      final Map<String, String> parsedData = _parseUri(uri);

      // Normalize the URI scheme.
      final String scheme = parsedData['scheme'] ?? '';
      parsedData.remove('scheme');

      // Filter out unrecognized parameters.
      final filteredParams = _filterParams(parsedData);

      // Handle multiple addresses and amounts for Monero.
      List<String> addresses = [];
      List<String>? amounts;
      List<String>? labels;

      if (scheme == 'monero') {
        // Parse addresses - check for multiple first.
        if (parsedData.containsKey('addresses')) {
          addresses = parsedData['addresses']!.split(';').map((addr) => addr.trim()).where((addr) => addr.isNotEmpty).toList();
        } else {
          addresses = [parsedData['address']!.trim()];
        }
        
        // Parse amounts.
        if (filteredParams.containsKey('amounts')) {
          amounts = filteredParams['amounts']!.split(';').map((amt) => amt.trim()).where((amt) => amt.isNotEmpty).toList();
        } else if (filteredParams.containsKey('amount')) {
          amounts = [filteredParams['amount']!];
        }
        
        // Parse labels.
        if (filteredParams.containsKey('labels')) {
          labels = filteredParams['labels']!.split(';').map((lbl) => lbl.trim()).where((lbl) => lbl.isNotEmpty).toList();
        } else if (filteredParams.containsKey('label') || filteredParams.containsKey('recipient_name')) {
          final singleLabel = filteredParams['label'] ?? filteredParams['recipient_name']!;
          if (singleLabel.contains(';')) {
            labels = singleLabel.split(';').map((lbl) => lbl.trim()).where((lbl) => lbl.isNotEmpty).toList();
          } else {
            labels = [singleLabel];
          }
        }
        
        // Validate multi-recipient structure.
        if (!_validateMultiRecipient(addresses, amounts)) {
          logging?.i("Invalid Monero URI: number of addresses (${addresses.length}) does not match number of amounts (${amounts?.length ?? 0})");
          return null;
        }
      } else {
        // Single address case (backward compatibility and other cryptocurrencies).
        addresses = [parsedData['address']!.trim()];
        if (filteredParams.containsKey('amount') || filteredParams.containsKey('tx_amount')) {
          amounts = [filteredParams['amount'] ?? filteredParams['tx_amount']!];
        }
        if (filteredParams.containsKey('label') || filteredParams.containsKey('recipient_name')) {
          labels = [filteredParams['label'] ?? filteredParams['recipient_name']!];
        }
      }

      return PaymentUriData(
        scheme: scheme,
        addresses: addresses,
        amounts: amounts,
        labels: labels,
        message: filteredParams['message'] ?? filteredParams['tx_description'],
        additionalParams: filteredParams,
      );
    } catch (e, s) {
      logging?.i("Invalid payment URI: $uri", error: e, stackTrace: s);
      return null;
    }
  }

  /// Builds a uri string with the given address and query parameters (if any)
  static String buildUriString(
    String scheme,
    String address,
    Map<String, String> params,
  ) {
    // Filter unrecognized parameters.
    final filteredParams = _filterParams(params);
    String uriString;

    // cashaddrs strike again
    if (address.startsWith("$scheme:")) {
      uriString = address;
    } else {
      uriString = "$scheme:$address";
    }

    if (scheme.toLowerCase() == "monero") {
      // Handle Monero-specific formatting.
      if (filteredParams.containsKey("tx_description")) {
        final description = filteredParams.remove("tx_description")!;
        if (filteredParams.isNotEmpty) {
          uriString += Uri(queryParameters: filteredParams).toString();
        }
        uriString += "#${Uri.encodeComponent(description)}";
      } else if (filteredParams.isNotEmpty) {
        uriString += Uri(queryParameters: filteredParams).toString();
      }
    } else {
      // General case for other cryptocurrencies.
      if (filteredParams.isNotEmpty) {
        uriString += Uri(queryParameters: filteredParams).toString();
      }
    }

    return uriString;
  }

  /// Builds a multi-recipient Monero URI string.
  static String buildMoneroMultiUriString(
    List<String> addresses,
    List<String>? amounts,
    List<String>? labels,
    String? description,
  ) {
    if (addresses.isEmpty) {
      throw ArgumentError('At least one address is required');
    }
    
    if (amounts != null && amounts.isNotEmpty && addresses.length != amounts.length) {
      throw ArgumentError('Number of addresses must match number of amounts');
    }

    String uriString = "monero:${addresses.join(';')}";
    
    final params = <String, String>{};
    
    if (amounts != null && amounts.isNotEmpty) {
      params['tx_amount'] = amounts.join(';');
    }
    
    if (labels != null && labels.isNotEmpty) {
      params['recipient_name'] = labels.join(';');
    }

    if (params.isNotEmpty) {
      uriString += Uri(queryParameters: params).toString();
    }

    if (description != null && description.isNotEmpty) {
      uriString += "#${Uri.encodeComponent(description)}";
    }

    return uriString;
  }

  /// returns empty if bad data
  static Map<String, dynamic> decodeQRSeedData(String data) {
    Map<String, dynamic> result = {};
    try {
      result = Map<String, dynamic>.from(jsonDecode(data) as Map);
    } catch (e, s) {
      Logging.instance.d(
        "Exception caught in parseQRSeedData($data)",
        error: e,
        stackTrace: s,
      );
    }
    return result;
  }

  /// encode mnemonic words to qrcode formatted string
  static String encodeQRSeedData(List<String> words) {
    return jsonEncode({"mnemonic": words});
  }

  /// Method to get CryptoCurrency based on URI scheme.
  static CryptoCurrency? _getCryptoCurrencyByScheme(String scheme) {
    if (AppConfig.coins.map((e) => e.uriScheme).toSet().contains(scheme)) {
      return AppConfig.coins.firstWhere((e) => e.uriScheme == scheme);
    } else {
      return null;
      // throw UnsupportedError('Unsupported URI scheme: $scheme');
    }
  }

  /// Formats an address string to remove any unnecessary prefixes or suffixes.
  String formatEpicCashAddress(String epicAddress) {
    // strip http:// or https:// prefixes if the address contains an @ symbol (and is thus an epicbox address)
    if ((epicAddress.startsWith("http://") ||
            epicAddress.startsWith("https://")) &&
        epicAddress.contains("@")) {
      epicAddress = epicAddress.replaceAll("http://", "");
      epicAddress = epicAddress.replaceAll("https://", "");
    }
    // strip mailto: prefix
    if (epicAddress.startsWith("mailto:")) {
      epicAddress = epicAddress.replaceAll("mailto:", "");
    }
    // strip / suffix if the address contains an @ symbol (and is thus an epicbox address)
    if (epicAddress.endsWith("/") && epicAddress.contains("@")) {
      epicAddress = epicAddress.substring(0, epicAddress.length - 1);
    }
    return epicAddress;
  }
}

class PaymentUriData {
  final List<String> addresses;
  final String? scheme;
  final List<String>? amounts;
  final List<String>? labels;
  final String? message;
  final Map<String, String> additionalParams;

  CryptoCurrency? get coin => AddressUtils._getCryptoCurrencyByScheme(
    scheme ?? "", // empty will just return null
  );

  // Backward compatibility getters.
  String get address => addresses.isNotEmpty ? addresses.first : '';
  String? get amount => amounts?.isNotEmpty == true ? amounts!.first : null;
  String? get label => labels?.isNotEmpty == true ? labels!.first : null;

  PaymentUriData({
    required this.addresses,
    this.scheme,
    this.amounts,
    this.labels,
    this.message,
    required this.additionalParams,
  });

  // Backward compatibility constructor.
  PaymentUriData.single({
    required String address,
    String? scheme,
    String? amount,
    String? label,
    String? message,
    required Map<String, String> additionalParams,
  }) : this(
    addresses: [address],
    scheme: scheme,
    amounts: amount != null ? [amount] : null,
    labels: label != null ? [label] : null,
    message: message,
    additionalParams: additionalParams,
  );

  @override
  String toString() =>
      "PaymentUriData { "
      "coin: $coin, "
      "addresses: $addresses, "
      "amounts: $amounts, "
      "scheme: $scheme, "
      "labels: $labels, "
      "message: $message, "
      "additionalParams: $additionalParams"
      " }";
}
