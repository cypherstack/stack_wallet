/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';
import 'dart:core' as core;
import 'dart:core';
import 'dart:isolate';
import 'dart:ui';

import 'package:flutter_libsparkmobile/flutter_libsparkmobile.dart' as spark;
import 'package:logger/logger.dart';

import 'util.dart';

export 'enums/log_level_enum.dart';

const _kLoggerPortName = "logger_port";

// convenience conversion for spark
extension LoggingLevelExt on spark.LoggingLevel {
  Level getLoggerLevel() {
    switch (this) {
      case spark.LoggingLevel.info:
        return Level.info;
      case spark.LoggingLevel.warning:
        return Level.warning;
      case spark.LoggingLevel.error:
        return Level.error;
      case spark.LoggingLevel.fatal:
        return Level.fatal;
      case spark.LoggingLevel.debug:
        return Level.debug;
      case spark.LoggingLevel.trace:
        return Level.trace;
    }
  }
}

class Logging {
  Logging._();
  static final Logging _instance = Logging._();
  static Logging get instance => _instance;

  late final String logsDirPath;

  SendPort get _sendPort {
    final port = IsolateNameServer.lookupPortByName(_kLoggerPortName);
    if (port == null) {
      throw Exception(
        "Did you forget to call Logging.initialize()?",
      );
    }
    return port;
  }

  Future<void> initialize(String logsPath, {required Level level}) async {
    if (Isolate.current.debugName != "main") {
      throw Exception(
        "Logging.initialize() must be called on the main isolate.",
      );
    }
    if (IsolateNameServer.lookupPortByName(_kLoggerPortName) != null) {
      throw Exception(
        "Logging was already initialized",
      );
    }

    logsDirPath = logsPath;

    final receivePort = ReceivePort();
    await Isolate.spawn(
      (sendPort) {
        final ReceivePort receivePort = ReceivePort();
        sendPort.send(receivePort.sendPort);

        PrettyPrinter prettyPrinter(bool toFile) => PrettyPrinter(
              printEmojis: false,
              methodCount: 0,
              dateTimeFormat:
                  toFile ? DateTimeFormat.none : DateTimeFormat.dateAndTime,
              colors: !toFile,
              noBoxingByDefault: toFile,
            );

        final consoleLogger = Logger(
          printer: PrefixPrinter(prettyPrinter(false)),
          filter: ProductionFilter(),
          level: level,
        );

        final fileLogger = Logger(
          printer: PrefixPrinter(prettyPrinter(true)),
          filter: ProductionFilter(),
          level: level,
          output: AdvancedFileOutput(
            path: logsDirPath,
            overrideExisting: false,
            latestFileName: "latest.txt",
            writeImmediately: [
              Level.error,
              Level.fatal,
              Level.warning,
              Level.trace, // mainly for spark debugging. TODO: Remove later
            ],
          ),
        );

        receivePort.listen((message) {
          final event = (message as (LogEvent, bool)).$1;
          consoleLogger.log(
            event.level,
            event.message,
            stackTrace: event.stackTrace,
            error: event.error,
            time: event.time.toUtc(),
          );
          if (message.$2) {
            fileLogger.log(
              event.level,
              "${event.time.toUtc().toIso8601String()} ${event.message}",
              stackTrace: event.stackTrace,
              error: event.error,
              time: event.time,
            );
          }
        });
      },
      receivePort.sendPort,
    );
    final loggerPort = await receivePort.first as SendPort;
    IsolateNameServer.registerPortWithName(loggerPort, _kLoggerPortName);
  }

  String _stringifyMessage(dynamic message) =>
      !(message is Map || message is Iterable)
          ? message.toString()
          : JsonEncoder.withIndent('  ', (o) => o.toString()).convert(message);

  void log(
    Level level,
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
    bool toFile = true, // false will print to console only
  }) {
    if (Util.isTestEnv || Util.isArmLinux) {
      toFile = false;
    }
    try {
      _sendPort.send(
        (
          LogEvent(
            level,
            _stringifyMessage(message),
            time: time,
            error: error,
            stackTrace: stackTrace,
          ),
          toFile
        ),
      );
    } catch (e, s) {
      t("Isolates suck", error: e, stackTrace: s);
    }
  }

  void t(
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
  }) =>
      log(
        Level.trace,
        message,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );

  void d(
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
  }) =>
      log(
        Level.debug,
        message,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );

  void i(
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
  }) =>
      log(
        Level.info,
        message,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );

  void w(
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
  }) =>
      log(
        Level.warning,
        message,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );

  void e(
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
  }) =>
      log(
        Level.error,
        message,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );

  void f(
    dynamic message, {
    DateTime? time,
    Object? error,
    StackTrace? stackTrace,
  }) =>
      log(
        Level.fatal,
        message,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );
}
