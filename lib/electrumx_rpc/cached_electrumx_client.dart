/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import '../db/hive/db.dart';
import '../utilities/logger.dart';
import '../wallets/crypto_currency/crypto_currency.dart';
import 'electrumx_client.dart';

class CachedElectrumXClient {
  final ElectrumXClient electrumXClient;

  static const minCacheConfirms = 30;

  CachedElectrumXClient({required this.electrumXClient});

  factory CachedElectrumXClient.from({
    required ElectrumXClient electrumXClient,
  }) => CachedElectrumXClient(electrumXClient: electrumXClient);

  String base64ToHex(String source) =>
      base64Decode(
        LineSplitter.split(source).join(),
      ).map((e) => e.toRadixString(16).padLeft(2, '0')).join();

  String base64ToReverseHex(String source) =>
      base64Decode(
        LineSplitter.split(source).join(),
      ).reversed.map((e) => e.toRadixString(16).padLeft(2, '0')).join();

  /// Call electrumx getTransaction on a per coin basis, storing the result in local db if not already there.
  ///
  /// ElectrumX api only called if the tx does not exist in local db
  Future<Map<String, dynamic>> getTransaction({
    required String txHash,
    required CryptoCurrency cryptoCurrency,
    bool verbose = true,
  }) async {
    try {
      final box = await DB.instance.getTxCacheBox(currency: cryptoCurrency);

      final cachedTx = box.get(txHash) as Map?;
      if (cachedTx == null) {
        final Map<String, dynamic> result = await electrumXClient
            .getTransaction(txHash: txHash, verbose: verbose);

        result.remove("hex");
        result.remove("lelantusData");
        result.remove("sparkData");

        if (result["confirmations"] != null &&
            result["confirmations"] as int > minCacheConfirms) {
          await box.put(txHash, result);
        }

        // Logging.instance.log("using fetched result");
        return result;
      } else {
        // Logging.instance.log("using cached result");
        return Map<String, dynamic>.from(cachedTx);
      }
    } catch (e, s) {
      Logging.instance.e(
        "Failed to process CachedElectrumX.getTransaction(): ",
        error: e,
        stackTrace: s,
      );
      rethrow;
    }
  }

  /// Clear all cached transactions for the specified coin
  Future<void> clearSharedTransactionCache({
    required CryptoCurrency cryptoCurrency,
  }) async {
    await DB.instance.clearSharedTransactionCache(currency: cryptoCurrency);
    await DB.instance.closeAnonymitySetCacheBox(currency: cryptoCurrency);
  }
}
