/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:camera_linux/camera_linux.dart';
import 'package:camera_macos/camera_macos_arguments.dart';
import 'package:camera_macos/camera_macos_controller.dart';
import 'package:camera_macos/camera_macos_device.dart';
import 'package:camera_macos/camera_macos_platform_interface.dart';
import 'package:camera_platform_interface/camera_platform_interface.dart';
import 'package:camera_windows/camera_windows.dart';
import 'package:cw_core/monero_transaction_priority.dart';
import 'package:decimal/decimal.dart';
import 'package:dropdown_button2/dropdown_button2.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:image/image.dart' as img;
import 'package:zxing2/qrcode.dart';

import '../../../../models/isar/models/contact_entry.dart';
import '../../../../models/paynym/paynym_account_lite.dart';
import '../../../../models/send_view_auto_fill_data.dart';
import '../../../../pages/send_view/confirm_transaction_view.dart';
import '../../../../pages/send_view/sub_widgets/building_transaction_dialog.dart';
import '../../../../pages/send_view/sub_widgets/transaction_fee_selection_sheet.dart';
import '../../../../providers/providers.dart';
import '../../../../providers/ui/fee_rate_type_state_provider.dart';
import '../../../../providers/ui/preview_tx_button_state_provider.dart';
import '../../../../providers/wallet/public_private_balance_state_provider.dart';
import '../../../../themes/stack_colors.dart';
import '../../../../utilities/address_utils.dart';
import '../../../../utilities/amount/amount.dart';
import '../../../../utilities/amount/amount_formatter.dart';
import '../../../../utilities/amount/amount_input_formatter.dart';
import '../../../../utilities/amount/amount_unit.dart';
import '../../../../utilities/assets.dart';
import '../../../../utilities/barcode_scanner_interface.dart';
import '../../../../utilities/clipboard_interface.dart';
import '../../../../utilities/constants.dart';
import '../../../../utilities/enums/fee_rate_type_enum.dart';
import '../../../../utilities/logger.dart';
import '../../../../utilities/prefs.dart';
import '../../../../utilities/text_styles.dart';
import '../../../../utilities/util.dart';
import '../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../wallets/crypto_currency/intermediate/nano_currency.dart';
import '../../../../wallets/isar/providers/wallet_info_provider.dart';
import '../../../../wallets/models/tx_data.dart';
import '../../../../wallets/wallet/impl/firo_wallet.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/coin_control_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/electrumx_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/paynym_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/spark_interface.dart';
import '../../../../widgets/animated_text.dart';
import '../../../../widgets/conditional_parent.dart';
import '../../../../widgets/custom_buttons/blue_text_button.dart';
import '../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../widgets/desktop/desktop_dialog_close_button.dart';
import '../../../../widgets/desktop/desktop_fee_dialog.dart';
import '../../../../widgets/desktop/primary_button.dart';
import '../../../../widgets/desktop/secondary_button.dart';
import '../../../../widgets/dialogs/firo_exchange_address_dialog.dart';
import '../../../../widgets/fee_slider.dart';
import '../../../../widgets/icon_widgets/addressbook_icon.dart';
import '../../../../widgets/icon_widgets/clipboard_icon.dart';
import '../../../../widgets/icon_widgets/qrcode_icon.dart';
import '../../../../widgets/icon_widgets/x_icon.dart';
import '../../../../widgets/rounded_container.dart';
import '../../../../widgets/stack_dialog.dart';
import '../../../../widgets/stack_text_field.dart';
import '../../../../widgets/textfield_icon_button.dart';
import '../../../coin_control/desktop_coin_control_use_dialog.dart';
import '../../../desktop_home_view.dart';
import 'address_book_address_chooser/address_book_address_chooser.dart';
import 'desktop_fee_dropdown.dart';

class DesktopSend extends ConsumerStatefulWidget {
  const DesktopSend({
    super.key,
    required this.walletId,
    this.autoFillData,
    this.clipboard = const ClipboardWrapper(),
    this.barcodeScanner = const BarcodeScannerWrapper(),
    this.accountLite,
  });

  final String walletId;
  final SendViewAutoFillData? autoFillData;
  final ClipboardInterface clipboard;
  final BarcodeScannerInterface barcodeScanner;
  final PaynymAccountLite? accountLite;

  @override
  ConsumerState<DesktopSend> createState() => _DesktopSendState();
}

class _DesktopSendState extends ConsumerState<DesktopSend> {
  late final String walletId;
  late final CryptoCurrency coin;
  late final ClipboardInterface clipboard;
  late final BarcodeScannerInterface scanner;

  late TextEditingController sendToController;
  late TextEditingController cryptoAmountController;
  late TextEditingController baseAmountController;
  // late TextEditingController feeController;
  late TextEditingController memoController;

  late final SendViewAutoFillData? _data;

  final _addressFocusNode = FocusNode();
  final _cryptoFocus = FocusNode();
  final _baseFocus = FocusNode();
  final _memoFocus = FocusNode();

  late final bool isStellar;

  String? _note;
  String? _onChainNote;

  Amount? _cachedAmountToSend;
  String? _address;

  bool _addressToggleFlag = false;

  bool _isFiroExWarningDisplayed = false;

  bool _cryptoAmountChangeLock = false;
  late VoidCallback onCryptoAmountChanged;

  bool get isPaynymSend => widget.accountLite != null;

  bool isCustomFee = false;
  int customFeeRate = 1;
  (FeeRateType, String?, String?)? feeSelectionResult;

  final stringsToLoopThrough = [
    "Calculating",
    "Calculating.",
    "Calculating..",
    "Calculating...",
  ];

  Future<void> scanWebcam() async {
    try {
      await showDialog(
        context: context,
        builder: (context) {
          return QrCodeScannerDialog(
            walletId: widget.walletId,
            onQrCodeDetected: (qrCodeData) {
              try {
                _processQrCodeData(qrCodeData);
              } catch (e, s) {
                Logging.instance.log("Error processing QR code data: $e\n$s",
                    level: LogLevel.Error);
              }
            },
            onSnackbar: (message) async {
              // TODO [prio=low]: Implement snackbar messages.
              // ScaffoldMessenger.of(context).showSnackBar(
              //   SnackBar(
              //     content: Text(message),
              //   ),
              // );

              if (context.mounted) {
                return await showDialog<void>(
                  context: context,
                  builder: (_) => StackOkDialog(
                    title: "Error scanning QR code",
                    message: message,
                  ),
                );
              }
            },
          );
        },
      );
    } catch (e, s) {
      Logging.instance.log("Error opening QR code scanner dialog: $e\n$s",
          level: LogLevel.Error);
    }
  }

  Future<void> previewSend() async {
    final wallet = ref.read(pWallets).getWallet(walletId);

    final Amount amount = ref.read(pSendAmount)!;
    final Amount availableBalance;
    if ((coin is Firo)) {
      switch (ref.read(publicPrivateBalanceStateProvider.state).state) {
        case FiroType.public:
          availableBalance = wallet.info.cachedBalance.spendable;
          break;
        case FiroType.lelantus:
          availableBalance = wallet.info.cachedBalanceSecondary.spendable;
          break;
        case FiroType.spark:
          availableBalance = wallet.info.cachedBalanceTertiary.spendable;
          break;
      }
    } else {
      availableBalance = wallet.info.cachedBalance.spendable;
    }

    final coinControlEnabled =
        ref.read(prefsChangeNotifierProvider).enableCoinControl;

    if (!(wallet is CoinControlInterface && coinControlEnabled) ||
        (wallet is CoinControlInterface &&
            coinControlEnabled &&
            ref.read(desktopUseUTXOs).isEmpty)) {
      // confirm send all
      if (amount == availableBalance) {
        final bool? shouldSendAll = await showDialog<bool>(
          context: context,
          useSafeArea: false,
          barrierDismissible: true,
          builder: (context) {
            return DesktopDialog(
              maxWidth: 450,
              maxHeight: double.infinity,
              child: Padding(
                padding: const EdgeInsets.only(
                  left: 32,
                  bottom: 32,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(
                          "Confirm send all",
                          style: STextStyles.desktopH3(context),
                        ),
                        const DesktopDialogCloseButton(),
                      ],
                    ),
                    const SizedBox(
                      height: 12,
                    ),
                    Padding(
                      padding: const EdgeInsets.only(
                        right: 32,
                      ),
                      child: Text(
                        "You are about to send your entire balance. Would you like to continue?",
                        textAlign: TextAlign.left,
                        style: STextStyles.desktopTextExtraExtraSmall(context)
                            .copyWith(
                          fontSize: 18,
                        ),
                      ),
                    ),
                    const SizedBox(
                      height: 40,
                    ),
                    Padding(
                      padding: const EdgeInsets.only(
                        right: 32,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: SecondaryButton(
                              buttonHeight: ButtonHeight.l,
                              label: "Cancel",
                              onPressed: () {
                                Navigator.of(context).pop(false);
                              },
                            ),
                          ),
                          const SizedBox(
                            width: 16,
                          ),
                          Expanded(
                            child: PrimaryButton(
                              buttonHeight: ButtonHeight.l,
                              label: "Yes",
                              onPressed: () {
                                Navigator.of(context).pop(true);
                              },
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        );

        if (shouldSendAll == null || shouldSendAll == false) {
          // cancel preview
          return;
        }
      }
    }

    try {
      bool wasCancelled = false;

      if (mounted) {
        unawaited(
          showDialog<dynamic>(
            context: context,
            useSafeArea: false,
            barrierDismissible: false,
            builder: (context) {
              return DesktopDialog(
                maxWidth: 400,
                maxHeight: double.infinity,
                child: Padding(
                  padding: const EdgeInsets.all(32),
                  child: BuildingTransactionDialog(
                    coin: wallet.info.coin,
                    isSpark: wallet is FiroWallet &&
                        ref
                                .read(publicPrivateBalanceStateProvider.state)
                                .state ==
                            FiroType.spark,
                    onCancel: () {
                      wasCancelled = true;

                      Navigator.of(context).pop();
                    },
                  ),
                ),
              );
            },
          ),
        );
      }

      final time = Future<dynamic>.delayed(
        const Duration(
          milliseconds: 2500,
        ),
      );

      TxData txData;
      Future<TxData> txDataFuture;

      if (isPaynymSend) {
        final paynymWallet = wallet as PaynymInterface;

        final feeRate = ref.read(feeRateTypeStateProvider);
        txDataFuture = paynymWallet.preparePaymentCodeSend(
          txData: TxData(
            paynymAccountLite: widget.accountLite!,
            recipients: [
              (
                address: widget.accountLite!.code,
                amount: amount,
                isChange: false,
              ),
            ],
            satsPerVByte: isCustomFee ? customFeeRate : null,
            feeRateType: feeRate,
            utxos: (wallet is CoinControlInterface &&
                    coinControlEnabled &&
                    ref.read(desktopUseUTXOs).isNotEmpty)
                ? ref.read(desktopUseUTXOs)
                : null,
          ),
        );
      } else if (wallet is FiroWallet) {
        switch (ref.read(publicPrivateBalanceStateProvider.state).state) {
          case FiroType.public:
            if (ref.read(pValidSparkSendToAddress)) {
              txDataFuture = wallet.prepareSparkMintTransaction(
                txData: TxData(
                  sparkRecipients: [
                    (
                      address: _address!,
                      amount: amount,
                      memo: memoController.text,
                      isChange: false,
                    ),
                  ],
                  feeRateType: ref.read(feeRateTypeStateProvider),
                  satsPerVByte: isCustomFee ? customFeeRate : null,
                  utxos: (wallet is CoinControlInterface &&
                          coinControlEnabled &&
                          ref.read(desktopUseUTXOs).isNotEmpty)
                      ? ref.read(desktopUseUTXOs)
                      : null,
                ),
              );
            } else {
              txDataFuture = wallet.prepareSend(
                txData: TxData(
                  recipients: [
                    (
                      address: _address!,
                      amount: amount,
                      isChange: false,
                    ),
                  ],
                  feeRateType: ref.read(feeRateTypeStateProvider),
                  satsPerVByte: isCustomFee ? customFeeRate : null,
                  utxos: (wallet is CoinControlInterface &&
                          coinControlEnabled &&
                          ref.read(desktopUseUTXOs).isNotEmpty)
                      ? ref.read(desktopUseUTXOs)
                      : null,
                ),
              );
            }
            break;

          case FiroType.lelantus:
            txDataFuture = wallet.prepareSendLelantus(
              txData: TxData(
                recipients: [
                  (
                    address: _address!,
                    amount: amount,
                    isChange: false,
                  ),
                ],
              ),
            );
            break;

          case FiroType.spark:
            txDataFuture = wallet.prepareSendSpark(
              txData: TxData(
                recipients: ref.read(pValidSparkSendToAddress)
                    ? null
                    : [
                        (
                          address: _address!,
                          amount: amount,
                          isChange: false,
                        ),
                      ],
                sparkRecipients: ref.read(pValidSparkSendToAddress)
                    ? [
                        (
                          address: _address!,
                          amount: amount,
                          memo: memoController.text,
                          isChange: false,
                        ),
                      ]
                    : null,
              ),
            );
            break;
        }
      } else {
        final memo = isStellar ? memoController.text : null;
        txDataFuture = wallet.prepareSend(
          txData: TxData(
            recipients: [
              (
                address: _address!,
                amount: amount,
                isChange: false,
              ),
            ],
            memo: memo,
            feeRateType: ref.read(feeRateTypeStateProvider),
            satsPerVByte: isCustomFee ? customFeeRate : null,
            utxos: (wallet is CoinControlInterface &&
                    coinControlEnabled &&
                    ref.read(desktopUseUTXOs).isNotEmpty)
                ? ref.read(desktopUseUTXOs)
                : null,
          ),
        );
      }

      final results = await Future.wait([
        txDataFuture,
        time,
      ]);

      txData = results.first as TxData;

      if (!wasCancelled && mounted) {
        if (isPaynymSend) {
          txData = txData.copyWith(
            paynymAccountLite: widget.accountLite!,
            note: _note ?? "PayNym send",
          );
        } else {
          txData = txData.copyWith(
            note: _note ?? "",
          );
          if (coin is Epiccash) {
            txData = txData.copyWith(
              noteOnChain: _onChainNote ?? "",
            );
          }
        }
        // pop building dialog
        Navigator.of(
          context,
          rootNavigator: true,
        ).pop();

        unawaited(
          showDialog(
            context: context,
            builder: (context) => DesktopDialog(
              maxHeight: MediaQuery.of(context).size.height - 64,
              maxWidth: 580,
              child: ConfirmTransactionView(
                txData: txData,
                walletId: walletId,
                onSuccess: clearSendForm,
                isPaynymTransaction: isPaynymSend,
                routeOnSuccessName: DesktopHomeView.routeName,
              ),
            ),
          ),
        );
      }
    } catch (e, s) {
      Logging.instance.log("Desktop send: $e\n$s", level: LogLevel.Error);
      if (mounted) {
        // pop building dialog
        Navigator.of(
          context,
          rootNavigator: true,
        ).pop();

        unawaited(
          showDialog<void>(
            context: context,
            builder: (context) {
              return DesktopDialog(
                maxWidth: 450,
                maxHeight: double.infinity,
                child: Padding(
                  padding: const EdgeInsets.only(
                    left: 32,
                    bottom: 32,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            "Transaction failed",
                            style: STextStyles.desktopH3(context),
                          ),
                          const DesktopDialogCloseButton(),
                        ],
                      ),
                      const SizedBox(
                        height: 12,
                      ),
                      Padding(
                        padding: const EdgeInsets.only(
                          right: 32,
                        ),
                        child: Text(
                          e.toString(),
                          textAlign: TextAlign.left,
                          style: STextStyles.desktopTextExtraExtraSmall(context)
                              .copyWith(
                            fontSize: 18,
                          ),
                        ),
                      ),
                      const SizedBox(
                        height: 40,
                      ),
                      Row(
                        children: [
                          Expanded(
                            child: SecondaryButton(
                              buttonHeight: ButtonHeight.l,
                              label: "Ok",
                              onPressed: () {
                                Navigator.of(
                                  context,
                                  rootNavigator: true,
                                ).pop();
                              },
                            ),
                          ),
                          const SizedBox(
                            width: 32,
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      }
    }
  }

  void clearSendForm() {
    sendToController.text = "";
    cryptoAmountController.text = "";
    baseAmountController.text = "";
    memoController.text = "";
    _address = "";
    _addressToggleFlag = false;
    if (mounted) {
      setState(() {});
    }
  }

  void _cryptoAmountChanged() async {
    if (!_cryptoAmountChangeLock) {
      final cryptoAmount = ref.read(pAmountFormatter(coin)).tryParse(
            cryptoAmountController.text,
          );
      final Amount? amount;
      if (cryptoAmount != null) {
        amount = cryptoAmount;
        if (_cachedAmountToSend != null && _cachedAmountToSend == amount) {
          return;
        }
        Logging.instance.log(
          "it changed $amount $_cachedAmountToSend",
          level: LogLevel.Info,
        );
        _cachedAmountToSend = amount;

        final price =
            ref.read(priceAnd24hChangeNotifierProvider).getPrice(coin).item1;

        if (price > Decimal.zero) {
          final String fiatAmountString = (amount!.decimal * price)
              .toAmount(fractionDigits: 2)
              .fiatString(
                locale: ref.read(localeServiceChangeNotifierProvider).locale,
              );

          baseAmountController.text = fiatAmountString;
        }
      } else {
        amount = null;
        _cachedAmountToSend = null;
        baseAmountController.text = "";
      }

      ref.read(pSendAmount.notifier).state = amount;
    }
  }

  // String? _updateInvalidAddressText(String address) {
  //   if (_data != null && _data!.contactLabel == address) {
  //     return null;
  //   }
  //   if (address.isNotEmpty &&
  //       !ref
  //           .read(pWallets)
  //           .getWallet(walletId)
  //           .cryptoCurrency
  //           .validateAddress(address)) {
  //     return "Invalid address";
  //   }
  //   return null;
  // }

  Future<void> scanQr() async {
    try {
      if (FocusScope.of(context).hasFocus) {
        FocusScope.of(context).unfocus();
        await Future<void>.delayed(const Duration(milliseconds: 75));
      }

      final qrResult = await scanner.scan();

      Logging.instance.log(
        "qrResult content: ${qrResult.rawContent}",
        level: LogLevel.Info,
      );

      final results = AddressUtils.parseUri(qrResult.rawContent);

      Logging.instance.log("qrResult parsed: $results", level: LogLevel.Info);

      if (results.isNotEmpty && results["scheme"] == coin.uriScheme) {
        // auto fill address
        _address = results["address"] ?? "";
        sendToController.text = _address!;

        // autofill notes field
        if (results["message"] != null) {
          _note = results["message"]!;
        } else if (results["label"] != null) {
          _note = results["label"]!;
        }

        // autofill amount field
        if (results["amount"] != null) {
          final amount = Decimal.parse(results["amount"]!).toAmount(
            fractionDigits: coin.fractionDigits,
          );
          cryptoAmountController.text = ref
              .read(pAmountFormatter(coin))
              .format(amount, withUnitName: false);
          ref.read(pSendAmount.notifier).state = amount;
        }

        setState(() {
          _addressToggleFlag = sendToController.text.isNotEmpty;
        });

        // now check for non standard encoded basic address
      } else if (ref
          .read(pWallets)
          .getWallet(walletId)
          .cryptoCurrency
          .validateAddress(qrResult.rawContent)) {
        _address = qrResult.rawContent;
        sendToController.text = _address ?? "";

        _setValidAddressProviders(_address);
        setState(() {
          _addressToggleFlag = sendToController.text.isNotEmpty;
        });
      }
    } on PlatformException catch (e, s) {
      // here we ignore the exception caused by not giving permission
      // to use the camera to scan a qr code
      Logging.instance.log(
        "Failed to get camera permissions while trying to scan qr code in SendView: $e\n$s",
        level: LogLevel.Warning,
      );
    } catch (e, s) {
      Logging.instance.log(
        "Failed to scan qr code in SendView: $e\n$s",
        level: LogLevel.Warning,
      );
    }
  }

  void _processQrCodeData(String qrCodeData) {
    try {
      var results = AddressUtils.parseUri(qrCodeData);
      if (results.isNotEmpty && results["scheme"] == coin.uriScheme) {
        _address = (results["address"] ?? "").trim();
        sendToController.text = _address!;

        if (results["amount"] != null) {
          final Amount amount = Decimal.parse(results["amount"]!).toAmount(
            fractionDigits: coin.fractionDigits,
          );
          cryptoAmountController.text = ref.read(pAmountFormatter(coin)).format(
                amount,
                withUnitName: false,
              );
          ref.read(pSendAmount.notifier).state = amount;
        }

        _setValidAddressProviders(_address);
        setState(() {
          _addressToggleFlag = sendToController.text.isNotEmpty;
        });
      }
    } catch (e, s) {
      Logging.instance
          .log("Error processing QR code data: $e\n$s", level: LogLevel.Error);
    }
  }

  void _setValidAddressProviders(String? address) {
    if (isPaynymSend) {
      ref.read(pValidSendToAddress.notifier).state = true;
    } else {
      final wallet = ref.read(pWallets).getWallet(walletId);
      if (wallet is SparkInterface) {
        ref.read(pValidSparkSendToAddress.notifier).state =
            SparkInterface.validateSparkAddress(
          address: address ?? "",
          isTestNet: wallet.cryptoCurrency.network.isTestNet,
        );

        ref.read(pIsExchangeAddress.state).state =
            (coin as Firo).isExchangeAddress(address ?? "");

        if (ref.read(publicPrivateBalanceStateProvider) == FiroType.spark &&
            ref.read(pIsExchangeAddress) &&
            !_isFiroExWarningDisplayed) {
          _isFiroExWarningDisplayed = true;
          showFiroExchangeAddressWarning(
            context,
            () => _isFiroExWarningDisplayed = false,
          );
        }
      }

      ref.read(pValidSendToAddress.notifier).state =
          wallet.cryptoCurrency.validateAddress(address ?? "");
    }
  }

  Future<void> pasteAddress() async {
    final ClipboardData? data = await clipboard.getData(Clipboard.kTextPlain);
    if (data?.text != null && data!.text!.isNotEmpty) {
      String content = data.text!.trim();
      if (content.contains("\n")) {
        content = content.substring(0, content.indexOf("\n"));
      }

      if (coin is Epiccash) {
        // strip http:// and https:// if content contains @
        content = formatAddress(content);
      }

      sendToController.text = content;
      _address = content;

      _setValidAddressProviders(_address);
      setState(() {
        _addressToggleFlag = sendToController.text.isNotEmpty;
      });
    }
  }

  Future<void> pasteMemo() async {
    if (memoController.text.isNotEmpty) {
      setState(() {
        memoController.text = "";
      });
    } else {
      final ClipboardData? data = await clipboard.getData(Clipboard.kTextPlain);
      if (data?.text != null && data!.text!.isNotEmpty) {
        final String content = data.text!.trim();

        setState(() {
          memoController.text = content;
        });
      }
    }
  }

  void fiatTextFieldOnChanged(String baseAmountString) {
    final baseAmount = Amount.tryParseFiatString(
      baseAmountString,
      locale: ref.read(localeServiceChangeNotifierProvider).locale,
    );
    final Amount? amount;
    if (baseAmount != null) {
      final _price =
          ref.read(priceAnd24hChangeNotifierProvider).getPrice(coin).item1;

      if (_price == Decimal.zero) {
        amount = Decimal.zero.toAmount(fractionDigits: coin.fractionDigits);
      } else {
        amount = baseAmount <= Amount.zero
            ? Decimal.zero.toAmount(fractionDigits: coin.fractionDigits)
            : (baseAmount.decimal / _price)
                .toDecimal(scaleOnInfinitePrecision: coin.fractionDigits)
                .toAmount(fractionDigits: coin.fractionDigits);
      }
      if (_cachedAmountToSend != null && _cachedAmountToSend == amount) {
        return;
      }
      _cachedAmountToSend = amount;
      Logging.instance
          .log("it changed $amount $_cachedAmountToSend", level: LogLevel.Info);

      final amountString = ref.read(pAmountFormatter(coin)).format(
            amount!,
            withUnitName: false,
          );

      _cryptoAmountChangeLock = true;
      cryptoAmountController.text = amountString;
      _cryptoAmountChangeLock = false;
    } else {
      amount = Decimal.zero.toAmount(fractionDigits: coin.fractionDigits);
      _cryptoAmountChangeLock = true;
      cryptoAmountController.text = "";
      _cryptoAmountChangeLock = false;
    }
    // setState(() {
    //   _calculateFeesFuture = calculateFees(
    //       Format.decimalAmountToSatoshis(
    //           _amountToSend!));
    // });
    ref.read(pSendAmount.notifier).state = amount;
  }

  Future<void> sendAllTapped() async {
    final info = ref.read(pWalletInfo(walletId));

    if (coin is Firo) {
      switch (ref.read(publicPrivateBalanceStateProvider.state).state) {
        case FiroType.public:
          cryptoAmountController.text = info.cachedBalance.spendable.decimal
              .toStringAsFixed(coin.fractionDigits);
          break;
        case FiroType.lelantus:
          cryptoAmountController.text = info
              .cachedBalanceSecondary.spendable.decimal
              .toStringAsFixed(coin.fractionDigits);
          break;
        case FiroType.spark:
          cryptoAmountController.text = info
              .cachedBalanceTertiary.spendable.decimal
              .toStringAsFixed(coin.fractionDigits);
          break;
      }
    } else {
      cryptoAmountController.text = info.cachedBalance.spendable.decimal
          .toStringAsFixed(coin.fractionDigits);
    }
  }

  void _showDesktopCoinControl() async {
    final amount = ref.read(pSendAmount);
    await showDialog<void>(
      context: context,
      builder: (context) => DesktopCoinControlUseDialog(
        walletId: widget.walletId,
        amountToSend: amount,
      ),
    );
  }

  @override
  void initState() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.refresh(feeSheetSessionCacheProvider);
      ref.refresh(pIsExchangeAddress);
      ref.read(pValidSendToAddress.state).state = false;
      ref.read(pValidSparkSendToAddress.state).state = false;
    });

    // _calculateFeesFuture = calculateFees(0);
    _data = widget.autoFillData;
    walletId = widget.walletId;
    coin = ref.read(pWalletInfo(walletId)).coin;
    clipboard = widget.clipboard;
    scanner = widget.barcodeScanner;
    isStellar = coin is Stellar;

    sendToController = TextEditingController();
    cryptoAmountController = TextEditingController();
    baseAmountController = TextEditingController();
    memoController = TextEditingController();
    // feeController = TextEditingController();

    onCryptoAmountChanged = _cryptoAmountChanged;
    cryptoAmountController.addListener(onCryptoAmountChanged);

    if (_data != null) {
      if (_data!.amount != null) {
        cryptoAmountController.text = _data!.amount!.toString();
      }
      sendToController.text = _data!.contactLabel;
      _address = _data!.address;
      _addressToggleFlag = true;
    }

    if (isPaynymSend) {
      sendToController.text = widget.accountLite!.nymName;
      WidgetsBinding.instance.addPostFrameCallback(
        (_) => _setValidAddressProviders(sendToController.text),
      );
    }

    _cryptoFocus.addListener(() {
      if (!_cryptoFocus.hasFocus && !_baseFocus.hasFocus) {
        if (ref.read(pSendAmount) == null) {
          if (ref.read(sendAmountProvider) != Amount.zero && mounted) {
            ref.read(sendAmountProvider.state).state = Amount.zero;
          }
        } else {
          ref.read(sendAmountProvider.state).state = ref.read(pSendAmount)!;
        }
      }
    });

    _baseFocus.addListener(() {
      if (!_cryptoFocus.hasFocus && !_baseFocus.hasFocus) {
        if (ref.read(pSendAmount) == null) {
          ref.refresh(sendAmountProvider);
        } else {
          ref.read(sendAmountProvider.state).state = ref.read(pSendAmount)!;
        }
      }
    });

    super.initState();
  }

  @override
  void dispose() {
    cryptoAmountController.removeListener(onCryptoAmountChanged);

    sendToController.dispose();
    cryptoAmountController.dispose();
    baseAmountController.dispose();
    memoController.dispose();
    // feeController.dispose();

    _addressFocusNode.dispose();
    _cryptoFocus.dispose();
    _baseFocus.dispose();
    _memoFocus.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    debugPrint("BUILD: $runtimeType");
    final String locale = ref.watch(
      localeServiceChangeNotifierProvider.select((value) => value.locale),
    );

    // add listener for epic cash to strip http:// and https:// prefixes if the address also ocntains an @ symbol (indicating an epicbox address)
    if (coin is Epiccash) {
      sendToController.addListener(() {
        _address = sendToController.text;

        if (_address != null && _address!.isNotEmpty) {
          _address = _address!.trim();
          if (_address!.contains("\n")) {
            _address = _address!.substring(0, _address!.indexOf("\n"));
          }

          sendToController.text = formatAddress(_address!);
        }
      });
    }

    final firoType = ref.watch(publicPrivateBalanceStateProvider);

    final isExchangeAddress = ref.watch(pIsExchangeAddress);
    ref.listen(publicPrivateBalanceStateProvider, (previous, next) {
      if (previous != next &&
          next == FiroType.spark &&
          isExchangeAddress &&
          !_isFiroExWarningDisplayed) {
        _isFiroExWarningDisplayed = true;
        WidgetsBinding.instance.addPostFrameCallback(
          (_) => showFiroExchangeAddressWarning(
            context,
            () => _isFiroExWarningDisplayed = false,
          ),
        );
      }
    });

    final showCoinControl = ref.watch(
          prefsChangeNotifierProvider.select(
            (value) => value.enableCoinControl,
          ),
        ) &&
        ref.watch(pWallets).getWallet(walletId) is CoinControlInterface &&
        (coin is Firo ? firoType == FiroType.public : true);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(
          height: 4,
        ),
        if (coin is Firo)
          Text(
            "Send from",
            style: STextStyles.desktopTextExtraSmall(context).copyWith(
              color: Theme.of(context)
                  .extension<StackColors>()!
                  .textFieldActiveSearchIconRight,
            ),
            textAlign: TextAlign.left,
          ),
        if (coin is Firo)
          const SizedBox(
            height: 10,
          ),
        if (coin is Firo)
          DropdownButtonHideUnderline(
            child: DropdownButton2(
              isExpanded: true,
              value: firoType,
              items: [
                DropdownMenuItem(
                  value: FiroType.spark,
                  child: Row(
                    children: [
                      Text(
                        "Spark balance",
                        style: STextStyles.itemSubtitle12(context),
                      ),
                      const SizedBox(
                        width: 10,
                      ),
                      Text(
                        ref.watch(pAmountFormatter(coin)).format(
                              ref
                                  .watch(pWalletBalanceTertiary(walletId))
                                  .spendable,
                            ),
                        style: STextStyles.itemSubtitle(context),
                      ),
                    ],
                  ),
                ),
                DropdownMenuItem(
                  value: FiroType.lelantus,
                  child: Row(
                    children: [
                      Text(
                        "Lelantus balance",
                        style: STextStyles.itemSubtitle12(context),
                      ),
                      const SizedBox(
                        width: 10,
                      ),
                      Text(
                        ref.watch(pAmountFormatter(coin)).format(
                              ref
                                  .watch(pWalletBalanceSecondary(walletId))
                                  .spendable,
                            ),
                        style: STextStyles.itemSubtitle(context),
                      ),
                    ],
                  ),
                ),
                DropdownMenuItem(
                  value: FiroType.public,
                  child: Row(
                    children: [
                      Text(
                        "Public balance",
                        style: STextStyles.itemSubtitle12(context),
                      ),
                      const SizedBox(
                        width: 10,
                      ),
                      Text(
                        ref.watch(pAmountFormatter(coin)).format(
                              ref.watch(pWalletBalance(walletId)).spendable,
                            ),
                        style: STextStyles.itemSubtitle(context),
                      ),
                    ],
                  ),
                ),
              ],
              onChanged: (value) {
                if (value is FiroType) {
                  if (value != FiroType.public) {
                    ref.read(desktopUseUTXOs.state).state = {};
                  }
                  setState(() {
                    ref.read(publicPrivateBalanceStateProvider.state).state =
                        value;
                  });
                }
              },
              iconStyleData: IconStyleData(
                icon: SvgPicture.asset(
                  Assets.svg.chevronDown,
                  width: 12,
                  height: 6,
                  color: Theme.of(context).extension<StackColors>()!.textDark3,
                ),
              ),
              dropdownStyleData: DropdownStyleData(
                offset: const Offset(0, -10),
                elevation: 0,
                decoration: BoxDecoration(
                  color: Theme.of(context)
                      .extension<StackColors>()!
                      .textFieldDefaultBG,
                  borderRadius: BorderRadius.circular(
                    Constants.size.circularBorderRadius,
                  ),
                ),
              ),
              menuItemStyleData: const MenuItemStyleData(
                padding: EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 8,
                ),
              ),
            ),
          ),
        if (coin is Firo)
          const SizedBox(
            height: 20,
          ),
        if (isPaynymSend)
          Text(
            "Send to PayNym address",
            style: STextStyles.smallMed12(context),
            textAlign: TextAlign.left,
          ),
        if (isPaynymSend)
          const SizedBox(
            height: 10,
          ),
        if (isPaynymSend)
          TextField(
            key: const Key("sendViewPaynymAddressFieldKey"),
            controller: sendToController,
            enabled: false,
            readOnly: true,
            style: STextStyles.desktopTextFieldLabel(context).copyWith(
              fontSize: 16,
            ),
            decoration: const InputDecoration(
              contentPadding: EdgeInsets.symmetric(
                vertical: 18,
                horizontal: 16,
              ),
            ),
          ),
        if (isPaynymSend)
          const SizedBox(
            height: 20,
          ),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              "Amount",
              style: STextStyles.desktopTextExtraSmall(context).copyWith(
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .textFieldActiveSearchIconRight,
              ),
              textAlign: TextAlign.left,
            ),
            if (coin is! Ethereum && coin is! Tezos)
              CustomTextButton(
                text: "Send all ${coin.ticker}",
                onTap: sendAllTapped,
              ),
          ],
        ),
        const SizedBox(
          height: 10,
        ),
        TextField(
          autocorrect: Util.isDesktop ? false : true,
          enableSuggestions: Util.isDesktop ? false : true,
          style: STextStyles.smallMed14(context).copyWith(
            color: Theme.of(context).extension<StackColors>()!.textDark,
          ),
          key: const Key("amountInputFieldCryptoTextFieldKey"),
          controller: cryptoAmountController,
          focusNode: _cryptoFocus,
          keyboardType: Util.isDesktop
              ? null
              : const TextInputType.numberWithOptions(
                  signed: false,
                  decimal: true,
                ),
          textAlign: TextAlign.right,
          inputFormatters: [
            AmountInputFormatter(
              decimals: coin.fractionDigits,
              unit: ref.watch(pAmountUnit(coin)),
              locale: locale,
            ),
            // // regex to validate a crypto amount with 8 decimal places
            // TextInputFormatter.withFunction((oldValue, newValue) =>
            //     RegExp(r'^([0-9]*[,.]?[0-9]{0,8}|[,.][0-9]{0,8})$')
            //             .hasMatch(newValue.text)
            //         ? newValue
            //         : oldValue),
          ],
          onChanged: (newValue) {},
          decoration: InputDecoration(
            contentPadding: const EdgeInsets.only(
              top: 22,
              right: 12,
              bottom: 22,
            ),
            hintText: "0",
            hintStyle: STextStyles.desktopTextExtraSmall(context).copyWith(
              color: Theme.of(context)
                  .extension<StackColors>()!
                  .textFieldDefaultText,
            ),
            prefixIcon: FittedBox(
              fit: BoxFit.scaleDown,
              child: Padding(
                padding: const EdgeInsets.all(12),
                child: Text(
                  ref.watch(pAmountUnit(coin)).unitForCoin(coin),
                  style: STextStyles.smallMed14(context).copyWith(
                    color: Theme.of(context)
                        .extension<StackColors>()!
                        .accentColorDark,
                  ),
                ),
              ),
            ),
          ),
        ),
        if (Prefs.instance.externalCalls)
          const SizedBox(
            height: 10,
          ),
        if (Prefs.instance.externalCalls)
          TextField(
            autocorrect: Util.isDesktop ? false : true,
            enableSuggestions: Util.isDesktop ? false : true,
            style: STextStyles.smallMed14(context).copyWith(
              color: Theme.of(context).extension<StackColors>()!.textDark,
            ),
            key: const Key("amountInputFieldFiatTextFieldKey"),
            controller: baseAmountController,
            focusNode: _baseFocus,
            keyboardType: Util.isDesktop
                ? null
                : const TextInputType.numberWithOptions(
                    signed: false,
                    decimal: true,
                  ),
            textAlign: TextAlign.right,
            inputFormatters: [
              AmountInputFormatter(
                decimals: 2,
                locale: locale,
              ),
              // // regex to validate a fiat amount with 2 decimal places
              // TextInputFormatter.withFunction((oldValue, newValue) =>
              //     RegExp(r'^([0-9]*[,.]?[0-9]{0,2}|[,.][0-9]{0,2})$')
              //             .hasMatch(newValue.text)
              //         ? newValue
              //         : oldValue),
            ],
            onChanged: fiatTextFieldOnChanged,
            decoration: InputDecoration(
              contentPadding: const EdgeInsets.only(
                top: 22,
                right: 12,
                bottom: 22,
              ),
              hintText: "0",
              hintStyle: STextStyles.desktopTextExtraSmall(context).copyWith(
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .textFieldDefaultText,
              ),
              prefixIcon: FittedBox(
                fit: BoxFit.scaleDown,
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: Text(
                    ref.watch(
                      prefsChangeNotifierProvider
                          .select((value) => value.currency),
                    ),
                    style: STextStyles.smallMed14(context).copyWith(
                      color: Theme.of(context)
                          .extension<StackColors>()!
                          .accentColorDark,
                    ),
                  ),
                ),
              ),
            ),
          ),
        if (showCoinControl)
          const SizedBox(
            height: 10,
          ),
        if (showCoinControl)
          RoundedContainer(
            color: Colors.transparent,
            borderColor:
                Theme.of(context).extension<StackColors>()!.textFieldDefaultBG,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  "Coin control",
                  style: STextStyles.desktopTextExtraExtraSmall(context),
                ),
                CustomTextButton(
                  text: ref.watch(desktopUseUTXOs.state).state.isEmpty
                      ? "Select coins"
                      : "Selected coins (${ref.watch(desktopUseUTXOs.state).state.length})",
                  onTap: _showDesktopCoinControl,
                ),
              ],
            ),
          ),
        const SizedBox(
          height: 20,
        ),
        if (!isPaynymSend)
          Text(
            "Send to",
            style: STextStyles.desktopTextExtraSmall(context).copyWith(
              color: Theme.of(context)
                  .extension<StackColors>()!
                  .textFieldActiveSearchIconRight,
            ),
            textAlign: TextAlign.left,
          ),
        if (!isPaynymSend)
          const SizedBox(
            height: 10,
          ),
        if (!isPaynymSend)
          ClipRRect(
            borderRadius: BorderRadius.circular(
              Constants.size.circularBorderRadius,
            ),
            child: TextField(
              minLines: 1,
              maxLines: 5,
              key: const Key("sendViewAddressFieldKey"),
              controller: sendToController,
              readOnly: false,
              autocorrect: false,
              enableSuggestions: false,
              // inputFormatters: <TextInputFormatter>[
              //   FilteringTextInputFormatter.allow(
              //       RegExp("[a-zA-Z0-9]{34}")),
              // ],
              toolbarOptions: const ToolbarOptions(
                copy: false,
                cut: false,
                paste: true,
                selectAll: false,
              ),
              onChanged: (newValue) {
                _address = newValue;
                _setValidAddressProviders(_address);

                setState(() {
                  _addressToggleFlag = newValue.isNotEmpty;
                });
              },
              focusNode: _addressFocusNode,
              style: STextStyles.desktopTextExtraSmall(context).copyWith(
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .textFieldActiveText,
                height: 1.8,
              ),
              decoration: standardInputDecoration(
                "Enter ${coin.ticker} address",
                _addressFocusNode,
                context,
                desktopMed: true,
              ).copyWith(
                contentPadding: const EdgeInsets.only(
                  left: 16,
                  top: 11,
                  bottom: 12,
                  right: 5,
                ),
                suffixIcon: Padding(
                  padding: sendToController.text.isEmpty
                      ? const EdgeInsets.only(right: 8)
                      : const EdgeInsets.only(right: 0),
                  child: UnconstrainedBox(
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceAround,
                      children: [
                        _addressToggleFlag
                            ? TextFieldIconButton(
                                key: const Key(
                                  "sendViewClearAddressFieldButtonKey",
                                ),
                                onTap: () {
                                  sendToController.text = "";
                                  _address = "";
                                  _setValidAddressProviders(_address);
                                  setState(() {
                                    _addressToggleFlag = false;
                                  });
                                },
                                child: const XIcon(),
                              )
                            : TextFieldIconButton(
                                key: const Key(
                                  "sendViewPasteAddressFieldButtonKey",
                                ),
                                onTap: pasteAddress,
                                child: sendToController.text.isEmpty
                                    ? const ClipboardIcon()
                                    : const XIcon(),
                              ),
                        if (sendToController.text.isEmpty)
                          TextFieldIconButton(
                            key: const Key("sendViewAddressBookButtonKey"),
                            onTap: () async {
                              final entry =
                                  await showDialog<ContactAddressEntry?>(
                                context: context,
                                builder: (context) => DesktopDialog(
                                  maxWidth: 696,
                                  maxHeight: 600,
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Row(
                                        mainAxisAlignment:
                                            MainAxisAlignment.spaceBetween,
                                        children: [
                                          Padding(
                                            padding: const EdgeInsets.only(
                                              left: 32,
                                            ),
                                            child: Text(
                                              "Address book",
                                              style: STextStyles.desktopH3(
                                                context,
                                              ),
                                            ),
                                          ),
                                          const DesktopDialogCloseButton(),
                                        ],
                                      ),
                                      Expanded(
                                        child: AddressBookAddressChooser(
                                          coin: coin,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              );

                              if (entry != null) {
                                sendToController.text =
                                    entry.other ?? entry.label;

                                _address = entry.address;

                                _setValidAddressProviders(_address);

                                setState(() {
                                  _addressToggleFlag = true;
                                });
                              }
                            },
                            child: const AddressBookIcon(),
                          ),
                        if (sendToController.text.isEmpty)
                          TextFieldIconButton(
                            semanticsLabel:
                                "Scan QR Button. Opens Camera For Scanning QR Code.",
                            key: const Key(
                              "sendViewScanQrButtonKey",
                            ),
                            onTap: scanWebcam,
                            child: const QrCodeIcon(),
                          ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        if (!isPaynymSend)
          Builder(
            builder: (_) {
              final String? error;

              if (_address == null || _address!.isEmpty) {
                error = null;
              } else if (coin is Firo) {
                if (firoType == FiroType.lelantus) {
                  if (_data != null && _data!.contactLabel == _address) {
                    error = SparkInterface.validateSparkAddress(
                      address: _data!.address,
                      isTestNet: coin.network.isTestNet,
                    )
                        ? "Lelantus to Spark not supported"
                        : null;
                  } else if (ref.watch(pValidSparkSendToAddress)) {
                    error = "Lelantus to Spark not supported";
                  } else {
                    error = ref.watch(pValidSendToAddress)
                        ? null
                        : "Invalid address";
                  }
                } else {
                  if (_data != null && _data!.contactLabel == _address) {
                    error = null;
                  } else if (!ref.watch(pValidSendToAddress) &&
                      !ref.watch(pValidSparkSendToAddress)) {
                    error = "Invalid address";
                  } else {
                    error = null;
                  }
                }
              } else {
                if (_data != null && _data!.contactLabel == _address) {
                  error = null;
                } else if (!ref.watch(pValidSendToAddress)) {
                  error = "Invalid address";
                } else {
                  error = null;
                }
              }

              if (error == null || error.isEmpty) {
                return Container();
              } else {
                return Align(
                  alignment: Alignment.topLeft,
                  child: Padding(
                    padding: const EdgeInsets.only(
                      left: 12.0,
                      top: 4.0,
                    ),
                    child: Text(
                      error,
                      textAlign: TextAlign.left,
                      style: STextStyles.label(context).copyWith(
                        color: Theme.of(context)
                            .extension<StackColors>()!
                            .textError,
                      ),
                    ),
                  ),
                );
              }
            },
          ),
        if (isStellar ||
            (ref.watch(pValidSparkSendToAddress) &&
                firoType != FiroType.lelantus))
          const SizedBox(
            height: 10,
          ),
        if (isStellar ||
            (ref.watch(pValidSparkSendToAddress) &&
                firoType != FiroType.lelantus))
          ClipRRect(
            borderRadius: BorderRadius.circular(
              Constants.size.circularBorderRadius,
            ),
            child: TextField(
              maxLength: (coin is Firo) ? 31 : null,
              minLines: 1,
              maxLines: 5,
              key: const Key("sendViewMemoFieldKey"),
              controller: memoController,
              readOnly: false,
              autocorrect: false,
              enableSuggestions: false,
              focusNode: _memoFocus,
              onChanged: (_) {
                setState(() {});
              },
              style: STextStyles.desktopTextExtraSmall(context).copyWith(
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .textFieldActiveText,
                height: 1.8,
              ),
              decoration: standardInputDecoration(
                "Enter memo (optional)",
                _memoFocus,
                context,
                desktopMed: true,
              ).copyWith(
                counterText: '',
                contentPadding: const EdgeInsets.only(
                  left: 16,
                  top: 11,
                  bottom: 12,
                  right: 5,
                ),
                suffixIcon: Padding(
                  padding: memoController.text.isEmpty
                      ? const EdgeInsets.only(right: 8)
                      : const EdgeInsets.only(right: 0),
                  child: UnconstrainedBox(
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceAround,
                      children: [
                        TextFieldIconButton(
                          key: const Key("sendViewPasteMemoButtonKey"),
                          onTap: pasteMemo,
                          child: memoController.text.isEmpty
                              ? const ClipboardIcon()
                              : const XIcon(),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        if (!isPaynymSend)
          const SizedBox(
            height: 20,
          ),
        if (coin is! NanoCurrency && coin is! Epiccash && coin is! Tezos)
          ConditionalParent(
            condition: ref.watch(pWallets).getWallet(walletId)
                    is ElectrumXInterface &&
                !(((coin is Firo) &&
                    (ref.watch(publicPrivateBalanceStateProvider.state).state ==
                            FiroType.lelantus ||
                        ref
                                .watch(publicPrivateBalanceStateProvider.state)
                                .state ==
                            FiroType.spark))),
            builder: (child) => Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                child,
                CustomTextButton(
                  text: "Edit",
                  onTap: () async {
                    feeSelectionResult = await showDialog<
                        (
                          FeeRateType,
                          String?,
                          String?,
                        )?>(
                      context: context,
                      builder: (_) => DesktopFeeDialog(
                        walletId: walletId,
                      ),
                    );

                    if (feeSelectionResult != null) {
                      if (isCustomFee &&
                          feeSelectionResult!.$1 != FeeRateType.custom) {
                        isCustomFee = false;
                      } else if (!isCustomFee &&
                          feeSelectionResult!.$1 == FeeRateType.custom) {
                        isCustomFee = true;
                      }
                    }

                    setState(() {});
                  },
                ),
              ],
            ),
            child: Text(
              "Transaction fee"
              "${isCustomFee ? "" : " (${coin is Ethereum ? "max" : "estimated"})"}",
              style: STextStyles.desktopTextExtraSmall(context).copyWith(
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .textFieldActiveSearchIconRight,
              ),
              textAlign: TextAlign.left,
            ),
          ),
        if (coin is! NanoCurrency && coin is! Epiccash && coin is! Tezos)
          const SizedBox(
            height: 10,
          ),
        if (coin is! NanoCurrency && coin is! Epiccash && coin is! Tezos)
          if (!isCustomFee)
            Padding(
              padding: const EdgeInsets.all(10),
              child: (feeSelectionResult?.$2 == null)
                  ? FutureBuilder(
                      future: ref.watch(
                        pWallets.select(
                          (value) => value.getWallet(walletId).fees,
                        ),
                      ),
                      builder: (context, snapshot) {
                        if (snapshot.connectionState == ConnectionState.done &&
                            snapshot.hasData) {
                          return DesktopFeeItem(
                            feeObject: snapshot.data,
                            feeRateType: FeeRateType.average,
                            walletId: walletId,
                            isButton: false,
                            feeFor: ({
                              required Amount amount,
                              required FeeRateType feeRateType,
                              required int feeRate,
                              required CryptoCurrency coin,
                            }) async {
                              if (ref
                                      .read(feeSheetSessionCacheProvider)
                                      .average[amount] ==
                                  null) {
                                final wallet =
                                    ref.read(pWallets).getWallet(walletId);

                                if (coin is Monero || coin is Wownero) {
                                  final fee = await wallet.estimateFeeFor(
                                    amount,
                                    MoneroTransactionPriority.regular.raw!,
                                  );
                                  ref
                                      .read(feeSheetSessionCacheProvider)
                                      .average[amount] = fee;
                                } else if ((coin is Firo) &&
                                    ref
                                            .read(
                                              publicPrivateBalanceStateProvider
                                                  .state,
                                            )
                                            .state !=
                                        FiroType.public) {
                                  final firoWallet = wallet as FiroWallet;

                                  if (ref
                                          .read(
                                            publicPrivateBalanceStateProvider
                                                .state,
                                          )
                                          .state ==
                                      FiroType.lelantus) {
                                    ref
                                            .read(feeSheetSessionCacheProvider)
                                            .average[amount] =
                                        await firoWallet
                                            .estimateFeeForLelantus(amount);
                                  } else if (ref
                                          .read(
                                            publicPrivateBalanceStateProvider
                                                .state,
                                          )
                                          .state ==
                                      FiroType.spark) {
                                    ref
                                            .read(feeSheetSessionCacheProvider)
                                            .average[amount] =
                                        await firoWallet
                                            .estimateFeeForSpark(amount);
                                  }
                                } else {
                                  ref
                                          .read(feeSheetSessionCacheProvider)
                                          .average[amount] =
                                      await wallet.estimateFeeFor(
                                    amount,
                                    feeRate,
                                  );
                                }
                              }
                              return ref
                                  .read(feeSheetSessionCacheProvider)
                                  .average[amount]!;
                            },
                            isSelected: true,
                          );
                        } else {
                          return Row(
                            children: [
                              AnimatedText(
                                stringsToLoopThrough: stringsToLoopThrough,
                                style: STextStyles.desktopTextExtraExtraSmall(
                                  context,
                                ).copyWith(
                                  color: Theme.of(context)
                                      .extension<StackColors>()!
                                      .textFieldActiveText,
                                ),
                              ),
                            ],
                          );
                        }
                      },
                    )
                  : (coin is Firo) &&
                          ref
                                  .watch(
                                    publicPrivateBalanceStateProvider.state,
                                  )
                                  .state ==
                              FiroType.lelantus
                      ? Text(
                          "~${ref.watch(pAmountFormatter(coin)).format(
                                Amount(
                                  rawValue: BigInt.parse("3794"),
                                  fractionDigits: coin.fractionDigits,
                                ),
                                indicatePrecisionLoss: false,
                              )}",
                          style: STextStyles.desktopTextExtraExtraSmall(context)
                              .copyWith(
                            color: Theme.of(context)
                                .extension<StackColors>()!
                                .textFieldActiveText,
                          ),
                          textAlign: TextAlign.left,
                        )
                      : Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              feeSelectionResult?.$2 ?? "",
                              style: STextStyles.desktopTextExtraExtraSmall(
                                context,
                              ).copyWith(
                                color: Theme.of(context)
                                    .extension<StackColors>()!
                                    .textFieldActiveText,
                              ),
                              textAlign: TextAlign.left,
                            ),
                            Text(
                              feeSelectionResult?.$3 ?? "",
                              style: STextStyles.desktopTextExtraExtraSmall(
                                context,
                              ).copyWith(
                                color: Theme.of(context)
                                    .extension<StackColors>()!
                                    .textFieldActiveSearchIconRight,
                              ),
                            ),
                          ],
                        ),
            ),
        if (isCustomFee)
          Padding(
            padding: const EdgeInsets.only(
              bottom: 12,
              top: 16,
            ),
            child: FeeSlider(
              coin: coin,
              onSatVByteChanged: (rate) {
                customFeeRate = rate;
              },
            ),
          ),
        const SizedBox(
          height: 36,
        ),
        PrimaryButton(
          buttonHeight: ButtonHeight.l,
          label: "Preview send",
          enabled: ref.watch(pPreviewTxButtonEnabled(coin)),
          onPressed:
              ref.watch(pPreviewTxButtonEnabled(coin)) ? previewSend : null,
        ),
      ],
    );
  }
}

String formatAddress(String epicAddress) {
  // strip http:// or https:// prefixes if the address contains an @ symbol (and is thus an epicbox address)
  if ((epicAddress.startsWith("http://") ||
          epicAddress.startsWith("https://")) &&
      epicAddress.contains("@")) {
    epicAddress = epicAddress.replaceAll("http://", "");
    epicAddress = epicAddress.replaceAll("https://", "");
  }
  // strip mailto: prefix
  if (epicAddress.startsWith("mailto:")) {
    epicAddress = epicAddress.replaceAll("mailto:", "");
  }
  // strip / suffix if the address contains an @ symbol (and is thus an epicbox address)
  if (epicAddress.endsWith("/") && epicAddress.contains("@")) {
    epicAddress = epicAddress.substring(0, epicAddress.length - 1);
  }
  return epicAddress;
}

class QrCodeScannerDialog extends StatefulWidget {
  final String walletId;
  final Function(String) onQrCodeDetected;
  final Function(String) onSnackbar; // This isn't really a snackbar currently.

  QrCodeScannerDialog({
    required this.walletId,
    required this.onQrCodeDetected,
    required this.onSnackbar,
  });

  @override
  _QrCodeScannerDialogState createState() => _QrCodeScannerDialogState();
}

class _QrCodeScannerDialogState extends State<QrCodeScannerDialog> {
  final CameraLinux? _cameraLinuxPlugin =
      Platform.isLinux ? CameraLinux() : null;
  final CameraWindows? _cameraWindowsPlugin =
      Platform.isWindows ? CameraWindows() : null;
  CameraMacOSController? _macOSController;
  bool _isCameraOpen = false;
  Image? _image;
  bool _isScanning = false;
  int _cameraId = -1;
  String? _macOSDeviceId;
  int _imageDelayInMs = 250;

  @override
  void initState() {
    super.initState();
    _isCameraOpen = false;
    _isScanning = false;
    _initializeCamera();
  }

  @override
  void dispose() {
    _stopCamera();
    super.dispose();
  }

  Future<void> _initializeCamera() async {
    try {
      setState(() {
        _isScanning = true; // Show the progress indicator
      });

      if (Platform.isLinux && _cameraLinuxPlugin != null) {
        await _cameraLinuxPlugin!.initializeCamera();
        Logging.instance.log("Linux Camera initialized", level: LogLevel.Info);
      } else if (Platform.isWindows && _cameraWindowsPlugin != null) {
        final List<CameraDescription> cameras =
            await _cameraWindowsPlugin!.availableCameras();
        if (cameras.isEmpty) {
          throw CameraException('No cameras available', 'No cameras found.');
        }
        final CameraDescription camera = cameras[0]; // Could be user-selected.
        _cameraId = await _cameraWindowsPlugin!.createCameraWithSettings(
          camera,
          const MediaSettings(
            resolutionPreset: ResolutionPreset.low,
            fps: 4,
            videoBitrate: 200000,
            enableAudio: false,
          ),
        );
        await _cameraWindowsPlugin!.initializeCamera(_cameraId);
        // await _cameraWindowsPlugin!.onCameraInitialized(_cameraId).first;
        // TODO [prio=low]: Make this work. ^^^
        Logging.instance.log("Windows Camera initialized with ID: $_cameraId",
            level: LogLevel.Info);
      } else if (Platform.isMacOS) {
        final List<CameraMacOSDevice> videoDevices = await CameraMacOS.instance
            .listDevices(deviceType: CameraMacOSDeviceType.video);
        if (videoDevices.isEmpty) {
          throw Exception('No cameras available');
        }
        _macOSDeviceId = videoDevices.first.deviceId;
        await CameraMacOS.instance
            .initialize(cameraMacOSMode: CameraMacOSMode.photo);

        setState(() {
          _isCameraOpen = true;
        });

        Logging.instance.log(
            "macOS Camera initialized with ID: $_macOSDeviceId",
            level: LogLevel.Info);
      }
      if (mounted) {
        setState(() {
          _isCameraOpen = true;
          _isScanning = true;
        });
      }
      unawaited(_captureAndScanImage()); // Could be awaited.
    } catch (e, s) {
      Logging.instance
          .log("Failed to initialize camera: $e\n$s", level: LogLevel.Error);
      if (mounted) {
        widget.onSnackbar("Failed to initialize camera. Please try again.");
        setState(() {
          _isScanning = false;
        });
      }
    }
  }

  Future<void> _stopCamera() async {
    try {
      if (Platform.isLinux && _cameraLinuxPlugin != null) {
        _cameraLinuxPlugin!.stopCamera();
        Logging.instance.log("Linux Camera stopped", level: LogLevel.Info);
      } else if (Platform.isWindows && _cameraWindowsPlugin != null) {
        // if (_cameraId >= 0) {
        await _cameraWindowsPlugin!.dispose(_cameraId);
        Logging.instance.log("Windows Camera stopped with ID: $_cameraId",
            level: LogLevel.Info);
        // } else {
        //   Logging.instance.log("Windows Camera ID is null. Cannot dispose.",
        //       level: LogLevel.Error);
        // }
      } else if (Platform.isMacOS) {
        // if (_macOSDeviceId != null) {
        await CameraMacOS.instance.stopImageStream();
        Logging.instance.log("macOS Camera stopped with ID: $_macOSDeviceId",
            level: LogLevel.Info);
        // } else {
        //   Logging.instance.log("macOS Camera ID is null. Cannot stop.",
        //       level: LogLevel.Error);
        // }
      }
    } catch (e, s) {
      Logging.instance
          .log("Failed to stop camera: $e\n$s", level: LogLevel.Error);
    } finally {
      if (mounted) {
        setState(() {
          _isScanning = false;
          _isCameraOpen = false;
        });
      }
    }
  }

  Future<void> _captureAndScanImage() async {
    while (_isCameraOpen && _isScanning) {
      try {
        String? base64Image;
        if (Platform.isLinux && _cameraLinuxPlugin != null) {
          base64Image = await _cameraLinuxPlugin!.captureImage();
        } else if (Platform.isWindows) {
          final XFile xfile =
              await _cameraWindowsPlugin!.takePicture(_cameraId);
          final bytes = await xfile.readAsBytes();
          base64Image = base64Encode(bytes);
          // We could use a Uint8List to optimize for Windows and macOS.
        } else if (Platform.isMacOS) {
          final macOSimg = await CameraMacOS.instance.takePicture();
          if (macOSimg == null) {
            Logging.instance
                .log("Failed to capture image", level: LogLevel.Error);
            await Future.delayed(Duration(milliseconds: _imageDelayInMs));
            continue;
          }
          final img.Image? image = img.decodeImage(macOSimg.bytes!);
          if (image == null) {
            Logging.instance
                .log("Failed to capture image", level: LogLevel.Error);
            await Future.delayed(Duration(milliseconds: _imageDelayInMs));
            continue;
          }
          base64Image = base64Encode(Uint8List.fromList(img.encodePng(image)));
        }
        if (base64Image == null || base64Image.isEmpty) {
          // Logging.instance
          //     .log("Failed to capture image", level: LogLevel.Error);
          // Spammy.
          await Future.delayed(Duration(milliseconds: _imageDelayInMs));
          continue;
        }
        final img.Image? image = img.decodeImage(base64Decode(base64Image));
        // TODO [prio=low]: Optimize this process. Docs say:
        // > WARNING Since this will check the image data against all known
        // > decoders, it is much slower than using an explicit decoder
        if (image == null) {
          Logging.instance.log("Failed to decode image", level: LogLevel.Error);
          await Future.delayed(Duration(milliseconds: _imageDelayInMs));
          continue;
        }

        if (mounted) {
          setState(() {
            _image = Image.memory(
              base64Decode(base64Image!),
              fit: BoxFit.cover,
            );
          });
        }

        final String? scanResult = await _scanImage(image);
        if (scanResult != null && scanResult.isNotEmpty) {
          widget.onQrCodeDetected(scanResult);
          if (mounted) {
            Navigator.of(context).pop();
          }
          break;
        } else {
          // Logging.instance.log("No QR code found in the image", level: LogLevel.Info);
          // if (mounted) {
          //   widget.onSnackbar("No QR code found in the image.");
          // }
          // Spammy.
        }

        await Future.delayed(Duration(milliseconds: _imageDelayInMs));
      } catch (e, s) {
        // Logging.instance.log("Failed to capture and scan image: $e\n$s", level: LogLevel.Error);
        // Spammy.
        if (mounted) {
          widget.onSnackbar(
              "Error capturing or scanning the image. Please try again.");
        }
      }
    }
  }

  Future<String?> _scanImage(img.Image image) async {
    try {
      final LuminanceSource source = RGBLuminanceSource(
        image.width,
        image.height,
        image
            .convert(numChannels: 4)
            .getBytes(order: img.ChannelOrder.abgr)
            .buffer
            .asInt32List(),
      );
      final BinaryBitmap bitmap =
          BinaryBitmap(GlobalHistogramBinarizer(source));

      final QRCodeReader reader = QRCodeReader();
      final qrDecode = reader.decode(bitmap);
      if (qrDecode.text.isEmpty) {
        return null;
      }
      return qrDecode.text;
    } catch (e, s) {
      // Logging.instance.log("Failed to decode QR code: $e\n$s", level: LogLevel.Error);
      // Spammy.
      return null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return DesktopDialog(
      maxWidth: 696,
      maxHeight: 600,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Padding(
                padding: const EdgeInsets.only(left: 32),
                child: Text(
                  "Scan QR code",
                  style: STextStyles.desktopH3(context),
                ),
              ),
              const DesktopDialogCloseButton(),
            ],
          ),
          Expanded(
            child: _isCameraOpen
                ? _image != null
                    ? _image!
                    : const Center(
                        child: CircularProgressIndicator(),
                      )
                : const Center(
                    child:
                        CircularProgressIndicator(), // Show progress indicator immediately
                  ),
          ),
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Expanded(child: Container()),
                // "Select file" button.
                SecondaryButton(
                  buttonHeight: ButtonHeight.l,
                  label: "Select file",
                  width: 200,
                  onPressed: () async {
                    final result = await FilePicker.platform.pickFiles(
                      type: FileType.custom,
                      allowedExtensions: ["png", "jpg", "jpeg"],
                    );

                    if (result == null || result.files.single.path == null) {
                      widget.onSnackbar("No file selected.");
                      return;
                    }

                    final filePath = result.files.single.path!;
                    try {
                      final img.Image? image =
                          img.decodeImage(File(filePath).readAsBytesSync());
                      if (image == null) {
                        widget.onSnackbar(
                            "Failed to decode image. Please select a valid image file.");
                        return;
                      }

                      final String? scanResult = await _scanImage(image);
                      if (scanResult != null && scanResult.isNotEmpty) {
                        widget.onQrCodeDetected(scanResult);
                        Navigator.of(context).pop();
                      } else {
                        widget.onSnackbar("No QR code found in the image.");
                      }
                    } catch (e, s) {
                      Logging.instance.log("Failed to decode image: $e\n$s",
                          level: LogLevel.Error);
                      widget.onSnackbar(
                          "Error processing the image. Please try again.");
                    }
                  },
                ),
                const SizedBox(width: 16),
                // Close button.
                PrimaryButton(
                  buttonHeight: ButtonHeight.l,
                  label: "Close",
                  width: 272.5,
                  onPressed: () {
                    _stopCamera();
                    Navigator.of(context).pop();
                  },
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
