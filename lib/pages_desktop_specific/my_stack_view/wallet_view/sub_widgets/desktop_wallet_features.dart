/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_svg/svg.dart';

import '../../../../app_config.dart';
import '../../../../models/keys/view_only_wallet_data.dart';
import '../../../../notifications/show_flush_bar.dart';
import '../../../../pages/monkey/monkey_view.dart';
import '../../../../pages/namecoin_names/namecoin_names_home_view.dart';
import '../../../../pages/paynym/paynym_claim_view.dart';
import '../../../../pages/paynym/paynym_home_view.dart';
import '../../../../pages/spark_names/spark_names_home_view.dart';
import '../../../../providers/desktop/current_desktop_menu_item.dart';
import '../../../../providers/global/paynym_api_provider.dart';
import '../../../../providers/providers.dart';
import '../../../../providers/wallet/my_paynym_account_state_provider.dart';
import '../../../../themes/stack_colors.dart';
import '../../../../themes/theme_providers.dart';
import '../../../../utilities/amount/amount.dart';
import '../../../../utilities/assets.dart';
import '../../../../utilities/constants.dart';
import '../../../../utilities/logger.dart';
import '../../../../utilities/text_styles.dart';
import '../../../../wallets/crypto_currency/coins/banano.dart';
import '../../../../wallets/crypto_currency/coins/firo.dart';
import '../../../../wallets/wallet/impl/firo_wallet.dart';
import '../../../../wallets/wallet/impl/namecoin_wallet.dart';
import '../../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../../wallets/wallet/wallet.dart' show Wallet;
import '../../../../wallets/wallet/wallet_mixin_interfaces/cash_fusion_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/coin_control_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/lelantus_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/ordinals_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/paynym_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/rbf_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/spark_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/view_only_option_interface.dart';
import '../../../../widgets/custom_loading_overlay.dart';
import '../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../widgets/desktop/primary_button.dart';
import '../../../../widgets/desktop/secondary_button.dart';
import '../../../../widgets/loading_indicator.dart';
import '../../../../widgets/static_overflow_row/static_overflow_row.dart';
import '../../../cashfusion/desktop_cashfusion_view.dart';
import '../../../churning/desktop_churning_view.dart';
import '../../../coin_control/desktop_coin_control_view.dart';
import '../../../desktop_menu.dart';
import '../../../lelantus_coins/lelantus_coins_view.dart';
import '../../../ordinals/desktop_ordinals_view.dart';
import '../../../spark_coins/spark_coins_view.dart';
import '../desktop_wallet_view.dart';
import 'more_features/more_features_dialog.dart';

enum WalletFeature {
  anonymizeFunds("Anonymize funds", "Anonymize funds"),
  swap("Swap", ""),
  buy("Buy", "Buy cryptocurrency"),
  paynym("PayNym", "Increased address privacy using BIP47"),
  coinControl(
    "Coin control",
    "Control, freeze, and utilize outputs at your discretion",
  ),
  lelantusCoins("Lelantus coins", "View wallet lelantus coins"),
  sparkCoins("Spark coins", "View wallet spark coins"),
  ordinals("Ordinals", "View and control your ordinals in ${AppConfig.prefix}"),
  monkey("MonKey", "Generate Banano MonKey"),
  fusion("Fusion", "Decentralized mixing protocol"),
  churn("Churn", "Churning"),
  namecoinName("Domains", "Namecoin DNS"),
  sparkNames("Names", "Spark names"),

  // special cases
  clearSparkCache("", ""),
  lelantusScanOption("", ""),
  rbf("", ""),
  reuseAddress("", "");

  final String label;
  final String description;
  const WalletFeature(this.label, this.description);
}

class DesktopWalletFeatures extends ConsumerStatefulWidget {
  const DesktopWalletFeatures({super.key, required this.walletId});

  final String walletId;

  @override
  ConsumerState<DesktopWalletFeatures> createState() =>
      _DesktopWalletFeaturesState();
}

class _DesktopWalletFeaturesState extends ConsumerState<DesktopWalletFeatures> {
  Future<void> _onSwapPressed() async {
    ref.read(currentDesktopMenuItemProvider.state).state =
        DesktopMenuItemId.exchange;
    ref.read(prevDesktopMenuItemProvider.state).state =
        DesktopMenuItemId.exchange;
  }

  Future<void> _onBuyPressed() async {
    ref.read(currentDesktopMenuItemProvider.state).state =
        DesktopMenuItemId.buy;
    ref.read(prevDesktopMenuItemProvider.state).state = DesktopMenuItemId.buy;
  }

  Future<void> _onMorePressed(
    List<(WalletFeature, String, FutureOr<void> Function())> options,
  ) async {
    await showDialog<void>(
      context: context,
      builder:
          (_) =>
              MoreFeaturesDialog(walletId: widget.walletId, options: options),
    );
  }

  void _onCoinControlPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopCoinControlView.routeName, arguments: widget.walletId);
  }

  void _onLelantusCoinsPressed() {
    Navigator.of(
      context,
    ).pushNamed(LelantusCoinsView.routeName, arguments: widget.walletId);
  }

  void _onSparkCoinsPressed() {
    Navigator.of(
      context,
    ).pushNamed(SparkCoinsView.routeName, arguments: widget.walletId);
  }

  Future<void> _onAnonymizeAllPressed() async {
    await showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder:
          (context) => DesktopDialog(
            maxWidth: 500,
            maxHeight: double.infinity,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 20),
              child: Column(
                children: [
                  Text("Attention!", style: STextStyles.desktopH2(context)),
                  const SizedBox(height: 16),
                  Text(
                    "You're about to anonymize all of your public funds.",
                    style: STextStyles.desktopTextSmall(context),
                  ),
                  const SizedBox(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      SecondaryButton(
                        width: 200,
                        buttonHeight: ButtonHeight.l,
                        label: "Cancel",
                        onPressed: () {
                          Navigator.of(context).pop();
                        },
                      ),
                      const SizedBox(width: 20),
                      PrimaryButton(
                        width: 200,
                        buttonHeight: ButtonHeight.l,
                        label: "Continue",
                        onPressed: () {
                          Navigator.of(context).pop();

                          unawaited(_attemptAnonymize());
                        },
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
    );
  }

  Future<void> _attemptAnonymize() async {
    bool shouldPop = false;
    unawaited(
      showDialog(
        context: context,
        builder:
            (context) => WillPopScope(
              child: const CustomLoadingOverlay(
                message: "Anonymizing balance",
                eventBus: null,
              ),
              onWillPop: () async => shouldPop,
            ),
      ),
    );
    final firoWallet =
        ref.read(pWallets).getWallet(widget.walletId) as FiroWallet;

    final publicBalance = firoWallet.info.cachedBalance.spendable;
    if (publicBalance <= Amount.zero) {
      shouldPop = true;
      if (context.mounted) {
        Navigator.of(context, rootNavigator: true).pop();
        Navigator.of(
          context,
        ).popUntil(ModalRoute.withName(DesktopWalletView.routeName));
        unawaited(
          showFloatingFlushBar(
            type: FlushBarType.info,
            message: "No funds available to anonymize!",
            context: context,
          ),
        );
      }
      return;
    }

    try {
      // await firoWallet.anonymizeAllLelantus();
      await firoWallet.anonymizeAllSpark();
      shouldPop = true;
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop();
        Navigator.of(
          context,
        ).popUntil(ModalRoute.withName(DesktopWalletView.routeName));
        unawaited(
          showFloatingFlushBar(
            type: FlushBarType.success,
            message: "Anonymize transaction submitted",
            context: context,
          ),
        );
      }
    } catch (e) {
      shouldPop = true;
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop();
        Navigator.of(
          context,
        ).popUntil(ModalRoute.withName(DesktopWalletView.routeName));
        await showDialog<dynamic>(
          context: context,
          builder:
              (_) => DesktopDialog(
                maxWidth: 400,
                maxHeight: 300,
                child: Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        "Anonymize all failed",
                        style: STextStyles.desktopH3(context),
                      ),
                      const Spacer(flex: 1),
                      Text(
                        "Reason: $e",
                        style: STextStyles.desktopTextSmall(context),
                      ),
                      const Spacer(flex: 2),
                      Row(
                        children: [
                          const Spacer(),
                          const SizedBox(width: 16),
                          Expanded(
                            child: PrimaryButton(
                              label: "Ok",
                              buttonHeight: ButtonHeight.l,
                              onPressed:
                                  Navigator.of(
                                    context,
                                    rootNavigator: true,
                                  ).pop,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
        );
      }
    }
  }

  Future<void> _onPaynymPressed() async {
    unawaited(
      showDialog(
        context: context,
        builder: (context) {
          return const LoadingIndicator(width: 100);
        },
      ),
    );

    final wallet =
        ref.read(pWallets).getWallet(widget.walletId) as PaynymInterface;

    final code = await wallet.getPaymentCode(isSegwit: false);

    final account = await ref.read(paynymAPIProvider).nym(code.toString());

    Logging.instance.d("my nym account: $account");

    if (mounted) {
      Navigator.of(context, rootNavigator: true).pop();

      // check if account exists and for matching code to see if claimed
      if (account.value != null && account.value!.nonSegwitPaymentCode.claimed
      // &&
      // account.value!.segwit
      ) {
        ref.read(myPaynymAccountStateProvider.state).state = account.value!;

        await Navigator.of(
          context,
        ).pushNamed(PaynymHomeView.routeName, arguments: widget.walletId);
      } else {
        await Navigator.of(
          context,
        ).pushNamed(PaynymClaimView.routeName, arguments: widget.walletId);
      }
    }
  }

  Future<void> _onMonkeyPressed() async {
    await (Navigator.of(
      context,
    ).pushNamed(MonkeyView.routeName, arguments: widget.walletId));
  }

  void _onOrdinalsPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopOrdinalsView.routeName, arguments: widget.walletId);
  }

  void _onFusionPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopCashFusionView.routeName, arguments: widget.walletId);
  }

  void _onChurnPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopChurningView.routeName, arguments: widget.walletId);
  }

  void _onNamesPressed() {
    Navigator.of(
      context,
    ).pushNamed(NamecoinNamesHomeView.routeName, arguments: widget.walletId);
  }

  void _onSparkNamesPressed() {
    Navigator.of(
      context,
    ).pushNamed(SparkNamesHomeView.routeName, arguments: widget.walletId);
  }

  List<(WalletFeature, String, FutureOr<void> Function())> _getOptions(
    Wallet wallet,
    bool showExchange,
    bool showCoinControl,
    bool firoAdvanced,
  ) {
    final coin = wallet.info.coin;
    final isViewOnly = wallet is ViewOnlyOptionInterface && wallet.isViewOnly;

    return [
      if (!isViewOnly && coin is Firo)
        (
          WalletFeature.anonymizeFunds,
          Assets.svg.recycle,
          _onAnonymizeAllPressed,
        ),
      if (!isViewOnly &&
          Constants.enableExchange &&
          AppConfig.hasFeature(AppFeature.swap) &&
          showExchange)
        (WalletFeature.swap, Assets.svg.swap, _onSwapPressed),

      if (showExchange && AppConfig.hasFeature(AppFeature.buy))
        (WalletFeature.buy, Assets.svg.swap, _onBuyPressed),

      if (wallet is SparkInterface)
        (WalletFeature.sparkNames, Assets.svg.robotHead, _onSparkNamesPressed),

      if (showCoinControl)
        (
          WalletFeature.coinControl,
          Assets.svg.coinControl.gamePad,
          _onCoinControlPressed,
        ),

      if (firoAdvanced && wallet is FiroWallet)
        (
          WalletFeature.lelantusCoins,
          Assets.svg.coinControl.gamePad,
          _onLelantusCoinsPressed,
        ),

      if (firoAdvanced && wallet is FiroWallet)
        (
          WalletFeature.sparkCoins,
          Assets.svg.coinControl.gamePad,
          _onSparkCoinsPressed,
        ),

      if (!isViewOnly && wallet is PaynymInterface)
        (WalletFeature.paynym, Assets.svg.robotHead, _onPaynymPressed),

      if (wallet is OrdinalsInterface)
        (WalletFeature.ordinals, Assets.svg.ordinal, _onOrdinalsPressed),

      if (wallet.info.coin is Banano)
        (WalletFeature.monkey, Assets.svg.monkey, _onMonkeyPressed),

      if (!isViewOnly && wallet is CashFusionInterface)
        (WalletFeature.fusion, Assets.svg.cashFusion, _onFusionPressed),

      if (!isViewOnly && wallet is LibMoneroWallet)
        (WalletFeature.churn, Assets.svg.churn, _onChurnPressed),

      if (wallet is NamecoinWallet)
        (WalletFeature.namecoinName, Assets.svg.robotHead, _onNamesPressed),
    ];
  }

  @override
  Widget build(BuildContext context) {
    final wallet = ref.watch(pWallets).getWallet(widget.walletId);

    final options = _getOptions(
      wallet,
      ref.watch(
        prefsChangeNotifierProvider.select((value) => value.enableExchange),
      ),
      (wallet is CoinControlInterface &&
          ref.watch(
            prefsChangeNotifierProvider.select(
              (value) => value.enableCoinControl,
            ),
          )),
      ref.watch(
        prefsChangeNotifierProvider.select((s) => s.advancedFiroFeatures),
      ),
    );

    final isViewOnly = wallet is ViewOnlyOptionInterface && wallet.isViewOnly;

    final isViewOnlyNoAddressGen =
        wallet is ViewOnlyOptionInterface &&
        wallet.isViewOnly &&
        wallet.viewOnlyType == ViewOnlyWalletType.addressOnly;

    final extraOptions = [
      if (wallet is SparkInterface && !isViewOnly)
        (WalletFeature.clearSparkCache, Assets.svg.key, () => ()),

      if (wallet is LelantusInterface && !isViewOnly)
        (WalletFeature.lelantusScanOption, Assets.svg.key, () => ()),

      if (wallet is RbfInterface) (WalletFeature.rbf, Assets.svg.key, () => ()),

      if (!isViewOnlyNoAddressGen)
        (WalletFeature.reuseAddress, Assets.svg.key, () => ()),
    ];

    return StaticOverflowRow(
      forcedOverflow: extraOptions.isNotEmpty,
      overflowBuilder: (count) {
        return Padding(
          padding: const EdgeInsets.only(left: 16),
          child: SecondaryButton(
            label: "More",
            padding: const EdgeInsets.symmetric(horizontal: 16),
            buttonHeight: ButtonHeight.l,
            icon: SvgPicture.asset(
              Assets.svg.bars,
              height: 20,
              width: 20,
              color:
                  Theme.of(
                    context,
                  ).extension<StackColors>()!.buttonTextSecondary,
            ),
            onPressed:
                () => _onMorePressed([
                  ...options.sublist(options.length - count),
                  ...extraOptions,
                ]),
          ),
        );
      },

      children: options
          .map(
            (option) => Padding(
              padding: const EdgeInsets.only(left: 16),
              child: SecondaryButton(
                label: option.$1.label,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                buttonHeight: ButtonHeight.l,
                icon:
                    option.$1 == WalletFeature.buy
                        ? SvgPicture.file(
                          File(
                            ref.watch(
                              themeProvider.select((value) => value.assets.buy),
                            ),
                          ),
                          height: 20,
                          width: 20,
                          color:
                              Theme.of(
                                context,
                              ).extension<StackColors>()!.buttonTextSecondary,
                        )
                        : SvgPicture.asset(
                          option.$2,
                          height: 20,
                          width: 20,
                          color:
                              Theme.of(
                                context,
                              ).extension<StackColors>()!.buttonTextSecondary,
                        ),
                onPressed: () => option.$3(),
              ),
            ),
          )
          .toList(growable: false),
    );
  }
}
