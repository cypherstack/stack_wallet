/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_svg/svg.dart';

import '../../../../app_config.dart';
import '../../../../models/keys/view_only_wallet_data.dart';
import '../../../../notifications/show_flush_bar.dart';
import '../../../../pages/monkey/monkey_view.dart';
import '../../../../pages/namecoin_names/namecoin_names_home_view.dart';
import '../../../../pages/paynym/paynym_claim_view.dart';
import '../../../../pages/paynym/paynym_home_view.dart';
import '../../../../pages/spark_names/spark_names_home_view.dart';
import '../../../../providers/desktop/current_desktop_menu_item.dart';
import '../../../../providers/global/paynym_api_provider.dart';
import '../../../../providers/providers.dart';
import '../../../../providers/wallet/my_paynym_account_state_provider.dart';
import '../../../../themes/stack_colors.dart';
import '../../../../themes/theme_providers.dart';
import '../../../../utilities/amount/amount.dart';
import '../../../../utilities/assets.dart';
import '../../../../utilities/constants.dart';
import '../../../../utilities/logger.dart';
import '../../../../utilities/text_styles.dart';
import '../../../../wallets/crypto_currency/coins/banano.dart';
import '../../../../wallets/crypto_currency/coins/firo.dart';
import '../../../../wallets/wallet/impl/firo_wallet.dart';
import '../../../../wallets/wallet/impl/namecoin_wallet.dart';
import '../../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../../wallets/wallet/intermediate/lib_salvium_wallet.dart';
import '../../../../wallets/wallet/wallet.dart' show Wallet;
import '../../../../wallets/wallet/wallet_mixin_interfaces/cash_fusion_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/coin_control_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/multi_address_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/mweb_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/ordinals_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/paynym_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/rbf_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/spark_interface.dart';
import '../../../../wallets/wallet/wallet_mixin_interfaces/view_only_option_interface.dart';
import '../../../../widgets/custom_loading_overlay.dart';
import '../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../widgets/desktop/primary_button.dart';
import '../../../../widgets/desktop/secondary_button.dart';
import '../../../../widgets/loading_indicator.dart';
import '../../../../widgets/static_overflow_row/static_overflow_row.dart';
import '../../../cashfusion/desktop_cashfusion_view.dart';
import '../../../churning/desktop_churning_view.dart';
import '../../../coin_control/desktop_coin_control_view.dart';
import '../../../desktop_menu.dart';
import '../../../mweb_utxos_view.dart';
import '../../../ordinals/desktop_ordinals_view.dart';
import '../../../spark_coins/spark_coins_view.dart';
import '../desktop_wallet_view.dart';
import 'more_features/more_features_dialog.dart';

enum WalletFeature {
  anonymizeFunds("Privatize funds", "Privatize funds"),
  swap("Swap", ""),
  buy("Buy", "Buy cryptocurrency"),
  paynym("PayNym", "Increased address privacy using BIP47"),
  coinControl(
    "Coin control",
    "Control, freeze, and utilize outputs at your discretion",
  ),
  sparkCoins("Spark coins", "View wallet spark coins"),
  mwebUtxos("MWEB outputs", "View wallet MWEB outputs"),
  ordinals("Ordinals", "View and control your ordinals in ${AppConfig.prefix}"),
  monkey("MonKey", "Generate Banano MonKey"),
  fusion("Fusion", "Decentralized mixing protocol"),
  churn("Churn", "Churning"),
  namecoinName("Domains", "Namecoin DNS"),
  sparkNames("Names", "Spark names"),

  // special cases
  clearSparkCache("", ""),
  rbf("", ""),
  reuseAddress("", ""),
  enableMweb("", "");

  final String label;
  final String description;
  const WalletFeature(this.label, this.description);
}

class DesktopWalletFeatures extends ConsumerStatefulWidget {
  const DesktopWalletFeatures({super.key, required this.walletId});

  final String walletId;

  @override
  ConsumerState<DesktopWalletFeatures> createState() =>
      _DesktopWalletFeaturesState();
}

class _DesktopWalletFeaturesState extends ConsumerState<DesktopWalletFeatures> {
  Future<void> _onSwapPressed() async {
    ref.read(currentDesktopMenuItemProvider.state).state =
        DesktopMenuItemId.exchange;
    ref.read(prevDesktopMenuItemProvider.state).state =
        DesktopMenuItemId.exchange;
  }

  Future<void> _onBuyPressed() async {
    ref.read(currentDesktopMenuItemProvider.state).state =
        DesktopMenuItemId.buy;
    ref.read(prevDesktopMenuItemProvider.state).state = DesktopMenuItemId.buy;
  }

  Future<void> _onMorePressed(
    List<(WalletFeature, String, FutureOr<void> Function())> options,
  ) async {
    await showDialog<void>(
      context: context,
      builder: (_) =>
          MoreFeaturesDialog(walletId: widget.walletId, options: options),
    );
  }

  void _onCoinControlPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopCoinControlView.routeName, arguments: widget.walletId);
  }

  void _onSparkCoinsPressed() {
    Navigator.of(
      context,
    ).pushNamed(SparkCoinsView.routeName, arguments: widget.walletId);
  }

  void _onMwebUtxosPressed() {
    Navigator.of(
      context,
    ).pushNamed(MwebUtxosView.routeName, arguments: widget.walletId);
  }

  Future<void> _onAnonymizeAllPressed() async {
    await showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (context) => DesktopDialog(
        maxWidth: 500,
        maxHeight: double.infinity,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 20),
          child: Column(
            children: [
              Text("Attention!", style: STextStyles.desktopH2(context)),
              const SizedBox(height: 16),
              Text(
                "You're about to privatize all of your public funds.",
                style: STextStyles.desktopTextSmall(context),
              ),
              const SizedBox(height: 32),
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  SecondaryButton(
                    width: 200,
                    buttonHeight: ButtonHeight.l,
                    label: "Cancel",
                    onPressed: () {
                      Navigator.of(context).pop();
                    },
                  ),
                  const SizedBox(width: 20),
                  PrimaryButton(
                    width: 200,
                    buttonHeight: ButtonHeight.l,
                    label: "Continue",
                    onPressed: () {
                      Navigator.of(context).pop();

                      unawaited(_attemptAnonymize());
                    },
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _attemptAnonymize() async {
    bool shouldPop = false;
    unawaited(
      showDialog(
        context: context,
        builder: (context) => WillPopScope(
          child: const CustomLoadingOverlay(
            message: "Privatizing balance",
            eventBus: null,
          ),
          onWillPop: () async => shouldPop,
        ),
      ),
    );

    final wallet = ref.read(pWallets).getWallet(widget.walletId);
    final publicBalance = wallet.info.cachedBalance.spendable;
    if (publicBalance <= Amount.zero) {
      shouldPop = true;
      if (context.mounted) {
        Navigator.of(context, rootNavigator: true).pop();
        Navigator.of(
          context,
        ).popUntil(ModalRoute.withName(DesktopWalletView.routeName));
        unawaited(
          showFloatingFlushBar(
            type: FlushBarType.info,
            message: "No funds available to privatize!",
            context: context,
          ),
        );
      }
      return;
    }

    try {
      if (wallet is MwebInterface && wallet.info.isMwebEnabled) {
        await wallet.anonymizeAllMweb();
      } else {
        await (wallet as FiroWallet).anonymizeAllSpark();
      }
      shouldPop = true;
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop();
        Navigator.of(
          context,
        ).popUntil(ModalRoute.withName(DesktopWalletView.routeName));
        unawaited(
          showFloatingFlushBar(
            type: FlushBarType.success,
            message: "Privatize transaction submitted",
            context: context,
          ),
        );
      }
    } catch (e) {
      shouldPop = true;
      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop();
        Navigator.of(
          context,
        ).popUntil(ModalRoute.withName(DesktopWalletView.routeName));
        await showDialog<dynamic>(
          context: context,
          builder: (_) => DesktopDialog(
            maxWidth: 400,
            maxHeight: 300,
            child: Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    "Privatize all failed",
                    style: STextStyles.desktopH3(context),
                  ),
                  const Spacer(flex: 1),
                  Text(
                    "Reason: $e",
                    style: STextStyles.desktopTextSmall(context),
                  ),
                  const Spacer(flex: 2),
                  Row(
                    children: [
                      const Spacer(),
                      const SizedBox(width: 16),
                      Expanded(
                        child: PrimaryButton(
                          label: "Ok",
                          buttonHeight: ButtonHeight.l,
                          onPressed: Navigator.of(
                            context,
                            rootNavigator: true,
                          ).pop,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        );
      }
    }
  }

  Future<void> _onPaynymPressed() async {
    unawaited(
      showDialog(
        context: context,
        builder: (context) {
          return const LoadingIndicator(width: 100);
        },
      ),
    );

    final wallet =
        ref.read(pWallets).getWallet(widget.walletId) as PaynymInterface;

    final code = await wallet.getPaymentCode(isSegwit: false);

    final account = await ref.read(paynymAPIProvider).nym(code.toString());

    Logging.instance.d("my nym account: $account");

    if (mounted) {
      Navigator.of(context, rootNavigator: true).pop();

      // check if account exists and for matching code to see if claimed
      if (account.value != null && account.value!.nonSegwitPaymentCode.claimed
      // &&
      // account.value!.segwit
      ) {
        ref.read(myPaynymAccountStateProvider.state).state = account.value!;

        await Navigator.of(
          context,
        ).pushNamed(PaynymHomeView.routeName, arguments: widget.walletId);
      } else {
        await Navigator.of(
          context,
        ).pushNamed(PaynymClaimView.routeName, arguments: widget.walletId);
      }
    }
  }

  Future<void> _onMonkeyPressed() async {
    await (Navigator.of(
      context,
    ).pushNamed(MonkeyView.routeName, arguments: widget.walletId));
  }

  void _onOrdinalsPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopOrdinalsView.routeName, arguments: widget.walletId);
  }

  void _onFusionPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopCashFusionView.routeName, arguments: widget.walletId);
  }

  void _onChurnPressed() {
    Navigator.of(
      context,
    ).pushNamed(DesktopChurningView.routeName, arguments: widget.walletId);
  }

  void _onNamesPressed() {
    Navigator.of(
      context,
    ).pushNamed(NamecoinNamesHomeView.routeName, arguments: widget.walletId);
  }

  void _onSparkNamesPressed() {
    Navigator.of(
      context,
    ).pushNamed(SparkNamesHomeView.routeName, arguments: widget.walletId);
  }

  List<(WalletFeature, String, FutureOr<void> Function())> _getOptions(
    Wallet wallet,
    bool showExchange,
    bool showCoinControl,
    bool firoAdvanced,
  ) {
    final coin = wallet.info.coin;
    final isViewOnly = wallet is ViewOnlyOptionInterface && wallet.isViewOnly;

    return [
      if (!isViewOnly &&
          (coin is Firo ||
              (wallet is MwebInterface && wallet.info.isMwebEnabled)))
        (
          WalletFeature.anonymizeFunds,
          Assets.svg.recycle,
          _onAnonymizeAllPressed,
        ),

      if (wallet is SparkInterface)
        (WalletFeature.sparkNames, Assets.svg.robotHead, _onSparkNamesPressed),

      if (!isViewOnly &&
          Constants.enableExchange &&
          AppConfig.hasFeature(AppFeature.swap) &&
          showExchange)
        (WalletFeature.swap, Assets.svg.swap, _onSwapPressed),

      if (showExchange && AppConfig.hasFeature(AppFeature.buy))
        (WalletFeature.buy, Assets.svg.swap, _onBuyPressed),

      if (showCoinControl)
        (
          WalletFeature.coinControl,
          Assets.svg.coinControl.gamePad,
          _onCoinControlPressed,
        ),

      if (firoAdvanced && wallet is FiroWallet)
        (
          WalletFeature.sparkCoins,
          Assets.svg.coinControl.gamePad,
          _onSparkCoinsPressed,
        ),

      if (kDebugMode && !isViewOnly && wallet is MwebInterface)
        (
          WalletFeature.mwebUtxos,
          Assets.svg.coinControl.gamePad,
          _onMwebUtxosPressed,
        ),

      if (!isViewOnly && wallet is PaynymInterface)
        (WalletFeature.paynym, Assets.svg.robotHead, _onPaynymPressed),

      if (wallet is OrdinalsInterface)
        (WalletFeature.ordinals, Assets.svg.ordinal, _onOrdinalsPressed),

      if (wallet.info.coin is Banano)
        (WalletFeature.monkey, Assets.svg.monkey, _onMonkeyPressed),

      if (AppConfig.hasFeature(AppFeature.tor) &&
          !isViewOnly &&
          wallet is CashFusionInterface)
        (WalletFeature.fusion, Assets.svg.cashFusion, _onFusionPressed),

      if (!isViewOnly &&
          (wallet is LibMoneroWallet || wallet is LibSalviumWallet))
        (WalletFeature.churn, Assets.svg.churn, _onChurnPressed),

      if (wallet is NamecoinWallet)
        (WalletFeature.namecoinName, Assets.svg.robotHead, _onNamesPressed),
    ];
  }

  @override
  Widget build(BuildContext context) {
    final wallet = ref.watch(pWallets).getWallet(widget.walletId);

    final options = _getOptions(
      wallet,
      wallet is! FiroWallet &&
          ref.watch(
            prefsChangeNotifierProvider.select((value) => value.enableExchange),
          ),
      (wallet is CoinControlInterface &&
          ref.watch(
            prefsChangeNotifierProvider.select(
              (value) => value.enableCoinControl,
            ),
          )),
      ref.watch(
        prefsChangeNotifierProvider.select((s) => s.advancedFiroFeatures),
      ),
    );

    final isViewOnly = wallet is ViewOnlyOptionInterface && wallet.isViewOnly;

    final bool canGen;
    if (isViewOnly && wallet.viewOnlyType == ViewOnlyWalletType.addressOnly) {
      canGen = false;
    } else {
      final supportsMweb =
          wallet is MwebInterface &&
          !wallet.info.isViewOnly &&
          wallet.info.isMwebEnabled;

      canGen =
          (wallet is MultiAddressInterface ||
          wallet is SparkInterface ||
          supportsMweb);
    }

    final showMwebOption = wallet is MwebInterface && !wallet.isViewOnly;

    final extraOptions = [
      if (wallet is SparkInterface && !isViewOnly)
        (WalletFeature.clearSparkCache, Assets.svg.key, () => ()),

      if (wallet is RbfInterface) (WalletFeature.rbf, Assets.svg.key, () => ()),

      if (canGen) (WalletFeature.reuseAddress, Assets.svg.key, () => ()),

      if (showMwebOption) (WalletFeature.enableMweb, Assets.svg.key, () => ()),
    ];

    return StaticOverflowRow(
      forcedOverflow: extraOptions.isNotEmpty,
      overflowBuilder: (count) {
        return Padding(
          padding: const EdgeInsets.only(left: 16),
          child: SecondaryButton(
            label: "More",
            padding: const EdgeInsets.symmetric(horizontal: 16),
            buttonHeight: ButtonHeight.l,
            icon: SvgPicture.asset(
              Assets.svg.bars,
              height: 20,
              width: 20,
              color: Theme.of(
                context,
              ).extension<StackColors>()!.buttonTextSecondary,
            ),
            onPressed: () => _onMorePressed([
              ...options.sublist(options.length - count),
              ...extraOptions,
            ]),
          ),
        );
      },

      children: options
          .map(
            (option) => Padding(
              padding: const EdgeInsets.only(left: 16),
              child: SecondaryButton(
                label: option.$1.label,
                padding: const EdgeInsets.symmetric(horizontal: 16),
                buttonHeight: ButtonHeight.l,
                icon: option.$1 == WalletFeature.buy
                    ? SvgPicture.file(
                        File(
                          ref.watch(
                            themeProvider.select((value) => value.assets.buy),
                          ),
                        ),
                        height: 20,
                        width: 20,
                        color: Theme.of(
                          context,
                        ).extension<StackColors>()!.buttonTextSecondary,
                      )
                    : SvgPicture.asset(
                        option.$2,
                        height: 20,
                        width: 20,
                        color: Theme.of(
                          context,
                        ).extension<StackColors>()!.buttonTextSecondary,
                      ),
                onPressed: () => option.$3(),
              ),
            ),
          )
          .toList(growable: false),
    );
  }
}
