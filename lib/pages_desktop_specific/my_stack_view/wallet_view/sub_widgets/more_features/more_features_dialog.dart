/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:wakelock_plus/wakelock_plus.dart';

import '../../../../../db/sqlite/firo_cache.dart';
import '../../../../../providers/db/main_db_provider.dart';
import '../../../../../providers/global/wallets_provider.dart';
import '../../../../../themes/stack_colors.dart';
import '../../../../../themes/theme_providers.dart';
import '../../../../../utilities/assets.dart';
import '../../../../../utilities/logger.dart';
import '../../../../../utilities/show_loading.dart';
import '../../../../../utilities/text_styles.dart';
import '../../../../../utilities/util.dart';
import '../../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../../wallets/isar/models/wallet_info.dart';
import '../../../../../wallets/isar/providers/wallet_info_provider.dart';
import '../../../../../widgets/custom_buttons/draggable_switch_button.dart';
import '../../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../../widgets/desktop/desktop_dialog_close_button.dart';
import '../../../../../widgets/desktop/primary_button.dart';
import '../../../../../widgets/desktop/secondary_button.dart';
import '../../../../../widgets/rounded_container.dart';
import '../../../../../widgets/stack_dialog.dart';
import '../desktop_wallet_features.dart';

class MoreFeaturesDialog extends ConsumerStatefulWidget {
  const MoreFeaturesDialog({
    super.key,
    required this.walletId,
    required this.options,
  });

  final String walletId;
  final List<(WalletFeature, String, FutureOr<void> Function())> options;

  @override
  ConsumerState<MoreFeaturesDialog> createState() => _MoreFeaturesDialogState();
}

class _MoreFeaturesDialogState extends ConsumerState<MoreFeaturesDialog> {
  bool _isUpdatingLelantusScanning = false; // Mutex.

  Future<void> _switchToggled(bool newValue) async {
    if (_isUpdatingLelantusScanning) return;
    _isUpdatingLelantusScanning = true; // Lock mutex.

    try {
      // Toggle enableLelantusScanning in wallet info.
      await ref
          .read(pWalletInfo(widget.walletId))
          .updateOtherData(
            newEntries: {WalletInfoKeys.enableLelantusScanning: newValue},
            isar: ref.read(mainDBProvider).isar,
          );

      if (newValue) {
        await _doRescanMaybe();
      }
    } finally {
      // ensure _isUpdatingLelantusScanning is set to false no matter what
      _isUpdatingLelantusScanning = false;
    }
  }

  bool _switchRbfToggledLock = false; // Mutex.
  Future<void> _switchRbfToggled(bool newValue) async {
    if (_switchRbfToggledLock) {
      return;
    }
    _switchRbfToggledLock = true; // Lock mutex.

    try {
      // Toggle enableOptInRbf in wallet info.
      await ref
          .read(pWalletInfo(widget.walletId))
          .updateOtherData(
            newEntries: {WalletInfoKeys.enableOptInRbf: newValue},
            isar: ref.read(mainDBProvider).isar,
          );
    } finally {
      // ensure _switchRbfToggledLock is set to false no matter what
      _switchRbfToggledLock = false;
    }
  }

  Future<void> _doRescanMaybe() async {
    final shouldRescan = await showDialog<bool>(
      context: context,
      builder: (context) {
        return DesktopDialog(
          maxWidth: 700,
          child: Column(
            children: [
              const DesktopDialogCloseButton(),
              const SizedBox(height: 5),
              Text(
                "Rescan may be required",
                style: STextStyles.desktopH2(context),
                textAlign: TextAlign.left,
              ),
              const SizedBox(height: 16),
              const Spacer(),
              Text(
                "A blockchain rescan may be required to fully recover all lelantus history."
                "\nThis may take a while.",
                style: STextStyles.desktopTextMedium(context).copyWith(
                  color: Theme.of(context).extension<StackColors>()!.textDark3,
                ),
                textAlign: TextAlign.center,
              ),
              const Spacer(),
              Padding(
                padding: const EdgeInsets.only(left: 32, right: 32, bottom: 32),
                child: Row(
                  children: [
                    Expanded(
                      child: SecondaryButton(
                        label: "Rescan now",
                        onPressed: () {
                          Navigator.of(context).pop(true);
                        },
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: PrimaryButton(
                        label: "Later",
                        onPressed: () => Navigator.of(context).pop(false),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );

    if (mounted && shouldRescan == true) {
      try {
        if (!Platform.isLinux) await WakelockPlus.enable();

        Exception? e;
        if (mounted) {
          await showLoading(
            whileFuture: ref
                .read(pWallets)
                .getWallet(widget.walletId)
                .recover(isRescan: true),
            context: context,
            message: "Rescanning blockchain",
            subMessage:
                "This may take a while.\nPlease do not exit this screen.",
            rootNavigator: Util.isDesktop,
            onException: (ex) => e = ex,
          );

          if (e != null) {
            throw e!;
          }
        }
      } catch (e, s) {
        Logging.instance.e("$e\n$s", error: e, stackTrace: s);
        if (mounted) {
          // show error
          await showDialog<dynamic>(
            context: context,
            useSafeArea: false,
            barrierDismissible: true,
            builder:
                (context) => StackDialog(
                  title: "Rescan failed",
                  message: e.toString(),
                  rightButton: TextButton(
                    style: Theme.of(context)
                        .extension<StackColors>()!
                        .getSecondaryEnabledButtonStyle(context),
                    child: Text(
                      "Ok",
                      style: STextStyles.itemSubtitle12(context),
                    ),
                    onPressed: () {
                      Navigator.of(
                        context,
                        rootNavigator: Util.isDesktop,
                      ).pop();
                    },
                  ),
                ),
          );
        }
      } finally {
        if (!Platform.isLinux) await WakelockPlus.disable();
      }
    }
  }

  late final DSBController _switchController;

  bool _switchReuseAddressToggledLock = false; // Mutex.
  Future<void> _switchReuseAddressToggled() async {
    if (_switchReuseAddressToggledLock) {
      return;
    }
    _switchReuseAddressToggledLock = true; // Lock mutex.

    try {
      if (_switchController.isOn?.call() != true) {
        final canContinue = await showDialog<bool?>(
          context: context,
          builder: (context) {
            return DesktopDialog(
              maxWidth: 576,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(left: 32),
                        child: Text(
                          "Warning!",
                          style: STextStyles.desktopH3(context),
                        ),
                      ),
                      const DesktopDialogCloseButton(),
                    ],
                  ),
                  Padding(
                    padding: const EdgeInsets.only(
                      top: 8,
                      left: 32,
                      right: 32,
                      bottom: 32,
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          "Reusing addresses reduces your privacy and security.  Are you sure you want to reuse addresses by default?",
                          style: STextStyles.desktopTextSmall(context),
                        ),
                        const SizedBox(height: 43),
                        Row(
                          children: [
                            Expanded(
                              child: SecondaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(false);
                                },
                                label: "Cancel",
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: PrimaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(true);
                                },
                                label: "Continue",
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            );
          },
        );

        if (canContinue == true) {
          await _updateAddressReuse(true);
        }
      } else {
        await _updateAddressReuse(false);
      }
    } finally {
      // ensure _switchReuseAddressToggledLock is set to false no matter what.
      _switchReuseAddressToggledLock = false;
    }
  }

  Future<void> _updateAddressReuse(bool shouldReuse) async {
    await ref
        .read(pWalletInfo(widget.walletId))
        .updateOtherData(
          newEntries: {WalletInfoKeys.reuseAddress: shouldReuse},
          isar: ref.read(mainDBProvider).isar,
        );

    if (_switchController.isOn != null) {
      if (_switchController.isOn!.call() != shouldReuse) {
        _switchController.activate?.call();
      }
    }
  }

  @override
  void initState() {
    _switchController = DSBController();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final wallet = ref.watch(
      pWallets.select((value) => value.getWallet(widget.walletId)),
    );

    return DesktopDialog(
      maxHeight: double.infinity,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Padding(
                padding: const EdgeInsets.only(left: 32),
                child: Text(
                  "More features",
                  style: STextStyles.desktopH3(context),
                ),
              ),
              const DesktopDialogCloseButton(),
            ],
          ),

          ...widget.options.map((option) {
            switch (option.$1) {
              case WalletFeature.buy:
                // Buy has a special icon
                return _MoreFeaturesItem(
                  label: option.$1.label,
                  detail: option.$1.description,
                  isSvgFile: true,
                  iconAsset: ref.watch(
                    themeProvider.select((value) => value.assets.buy),
                  ),
                  onPressed: () async {
                    Navigator.of(context, rootNavigator: true).pop();
                    option.$3();
                  },
                );

              case WalletFeature.clearSparkCache:
                return _MoreFeaturesClearSparkCacheItem(
                  cryptoCurrency: wallet.cryptoCurrency,
                );

              case WalletFeature.lelantusScanOption:
                return _MoreFeaturesItemBase(
                  child: Row(
                    children: [
                      const SizedBox(width: 3),
                      SizedBox(
                        height: 20,
                        width: 40,
                        child: DraggableSwitchButton(
                          isOn:
                              ref.watch(
                                    pWalletInfo(
                                      widget.walletId,
                                    ).select((value) => value.otherData),
                                  )[WalletInfoKeys.enableLelantusScanning]
                                  as bool? ??
                              false,
                          onValueChanged: _switchToggled,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Scan for Lelantus transactions",
                            style: STextStyles.w600_20(context),
                          ),
                        ],
                      ),
                    ],
                  ),
                );

              case WalletFeature.rbf:
                return _MoreFeaturesItemBase(
                  child: Row(
                    children: [
                      const SizedBox(width: 3),
                      SizedBox(
                        height: 20,
                        width: 40,
                        child: DraggableSwitchButton(
                          isOn:
                              ref.watch(
                                    pWalletInfo(
                                      widget.walletId,
                                    ).select((value) => value.otherData),
                                  )[WalletInfoKeys.enableOptInRbf]
                                  as bool? ??
                              false,
                          onValueChanged: _switchRbfToggled,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Flag outgoing transactions with opt-in RBF",
                            style: STextStyles.w600_20(context),
                          ),
                        ],
                      ),
                    ],
                  ),
                );

              case WalletFeature.reuseAddress:
                return _MoreFeaturesItemBase(
                  onPressed: _switchReuseAddressToggled,
                  child: Row(
                    children: [
                      const SizedBox(width: 3),
                      SizedBox(
                        height: 20,
                        width: 40,
                        child: IgnorePointer(
                          child: DraggableSwitchButton(
                            isOn:
                                ref.watch(
                                      pWalletInfo(
                                        widget.walletId,
                                      ).select((value) => value.otherData),
                                    )[WalletInfoKeys.reuseAddress]
                                    as bool? ??
                                false,
                            controller: _switchController,
                          ),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Reuse receiving address",
                            style: STextStyles.w600_20(context),
                          ),
                        ],
                      ),
                    ],
                  ),
                );

              default:
                return _MoreFeaturesItem(
                  label: option.$1.label,
                  detail: option.$1.description,
                  iconAsset: option.$2,
                  onPressed: () async {
                    Navigator.of(context, rootNavigator: true).pop();
                    option.$3();
                  },
                );
            }
          }),

          const SizedBox(height: 28),
        ],
      ),
    );
  }
}

class _MoreFeaturesItem extends StatefulWidget {
  const _MoreFeaturesItem({
    super.key,
    required this.label,
    required this.detail,
    required this.iconAsset,
    this.isSvgFile = false,
    this.onPressed,
  });

  static const double iconSizeBG = 46;
  static const double iconSize = 24;

  final String label;
  final String detail;
  final String iconAsset;
  final bool isSvgFile;
  final Future<void> Function()? onPressed;

  @override
  State<_MoreFeaturesItem> createState() => _MoreFeaturesItemState();
}

class _MoreFeaturesItemState extends State<_MoreFeaturesItem> {
  bool _onPressedLock = false;

  @override
  Widget build(BuildContext context) {
    return _MoreFeaturesItemBase(
      onPressed: () async {
        if (_onPressedLock) {
          return;
        }
        _onPressedLock = true;
        try {
          await widget.onPressed?.call();
        } finally {
          _onPressedLock = false;
        }
      },
      child: Row(
        children: [
          RoundedContainer(
            padding: const EdgeInsets.all(0),
            color: Theme.of(context).extension<StackColors>()!.settingsIconBack,
            width: _MoreFeaturesItem.iconSizeBG,
            height: _MoreFeaturesItem.iconSizeBG,
            radiusMultiplier: _MoreFeaturesItem.iconSizeBG,
            child: Center(
              child:
                  widget.isSvgFile
                      ? SvgPicture.file(
                        File(widget.iconAsset),
                        width: _MoreFeaturesItem.iconSize,
                        height: _MoreFeaturesItem.iconSize,
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.settingsIconIcon,
                      )
                      : SvgPicture.asset(
                        widget.iconAsset,
                        width: _MoreFeaturesItem.iconSize,
                        height: _MoreFeaturesItem.iconSize,
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.settingsIconIcon,
                      ),
            ),
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(widget.label, style: STextStyles.w600_20(context)),
              Text(
                widget.detail,
                style: STextStyles.desktopTextExtraExtraSmall(context),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _MoreFeaturesItemBase extends StatelessWidget {
  const _MoreFeaturesItemBase({super.key, required this.child, this.onPressed});

  final Widget child;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 32),
      child: RoundedContainer(
        color: Colors.transparent,
        borderColor:
            Theme.of(context).extension<StackColors>()!.textFieldDefaultBG,
        onPressed: onPressed,
        child: child,
      ),
    );
  }
}

class _MoreFeaturesClearSparkCacheItem extends StatefulWidget {
  const _MoreFeaturesClearSparkCacheItem({
    super.key,
    required this.cryptoCurrency,
  });

  final CryptoCurrency cryptoCurrency;

  @override
  State<_MoreFeaturesClearSparkCacheItem> createState() =>
      _MoreFeaturesClearSparkCacheItemState();
}

class _MoreFeaturesClearSparkCacheItemState
    extends State<_MoreFeaturesClearSparkCacheItem> {
  bool _onPressedLock = false;

  static const label = "Reset Spark electrumx cache";

  @override
  Widget build(BuildContext context) {
    return _MoreFeaturesItemBase(
      onPressed: () async {
        if (_onPressedLock) {
          return;
        }
        _onPressedLock = true;
        try {
          await FiroCacheCoordinator.clearSharedCache(
            widget.cryptoCurrency.network,
          );
          setState(() {
            // trigger rebuild for cache size display
          });
        } finally {
          _onPressedLock = false;
        }
      },
      child: Row(
        children: [
          RoundedContainer(
            padding: const EdgeInsets.all(0),
            color: Theme.of(context).extension<StackColors>()!.settingsIconBack,
            width: _MoreFeaturesItem.iconSizeBG,
            height: _MoreFeaturesItem.iconSizeBG,
            radiusMultiplier: _MoreFeaturesItem.iconSizeBG,
            child: Center(
              child: SvgPicture.asset(
                Assets.svg.x,
                width: _MoreFeaturesItem.iconSize,
                height: _MoreFeaturesItem.iconSize,
                color:
                    Theme.of(
                      context,
                    ).extension<StackColors>()!.settingsIconIcon,
              ),
            ),
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: STextStyles.w600_20(context)),
              FutureBuilder(
                future: FiroCacheCoordinator.getSparkCacheSize(
                  widget.cryptoCurrency.network,
                ),
                builder: (_, snapshot) {
                  return Text(
                    snapshot.data ?? "",
                    style: STextStyles.desktopTextExtraExtraSmall(context),
                  );
                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}
