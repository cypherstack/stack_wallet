/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';

import '../../../../../db/sqlite/firo_cache.dart';
import '../../../../../providers/db/main_db_provider.dart';
import '../../../../../providers/global/wallets_provider.dart';
import '../../../../../themes/stack_colors.dart';
import '../../../../../themes/theme_providers.dart';
import '../../../../../utilities/assets.dart';
import '../../../../../utilities/text_styles.dart';
import '../../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../../wallets/isar/models/wallet_info.dart';
import '../../../../../wallets/isar/providers/wallet_info_provider.dart';
import '../../../../../widgets/custom_buttons/draggable_switch_button.dart';
import '../../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../../widgets/desktop/desktop_dialog_close_button.dart';
import '../../../../../widgets/desktop/primary_button.dart';
import '../../../../../widgets/desktop/secondary_button.dart';
import '../../../../../widgets/rounded_container.dart';
import '../desktop_wallet_features.dart';

class MoreFeaturesDialog extends ConsumerStatefulWidget {
  const MoreFeaturesDialog({
    super.key,
    required this.walletId,
    required this.options,
  });

  final String walletId;
  final List<(WalletFeature, String, FutureOr<void> Function())> options;

  @override
  ConsumerState<MoreFeaturesDialog> createState() => _MoreFeaturesDialogState();
}

class _MoreFeaturesDialogState extends ConsumerState<MoreFeaturesDialog> {
  bool _switchRbfToggledLock = false; // Mutex.
  Future<void> _switchRbfToggled(bool newValue) async {
    if (_switchRbfToggledLock) {
      return;
    }
    _switchRbfToggledLock = true; // Lock mutex.

    try {
      // Toggle enableOptInRbf in wallet info.
      await ref
          .read(pWalletInfo(widget.walletId))
          .updateOtherData(
            newEntries: {WalletInfoKeys.enableOptInRbf: newValue},
            isar: ref.read(mainDBProvider).isar,
          );
    } finally {
      // ensure _switchRbfToggledLock is set to false no matter what
      _switchRbfToggledLock = false;
    }
  }

  late final DSBController _switchControllerAddressReuse;
  late final DSBController _switchControllerMwebToggle;

  bool _switchReuseAddressToggledLock = false; // Mutex.
  Future<void> _switchReuseAddressToggled() async {
    if (_switchReuseAddressToggledLock) {
      return;
    }
    _switchReuseAddressToggledLock = true; // Lock mutex.

    try {
      if (_switchControllerAddressReuse.isOn?.call() != true) {
        final canContinue = await showDialog<bool?>(
          context: context,
          builder: (context) {
            return DesktopDialog(
              maxWidth: 576,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(left: 32),
                        child: Text(
                          "Warning!",
                          style: STextStyles.desktopH3(context),
                        ),
                      ),
                      const DesktopDialogCloseButton(),
                    ],
                  ),
                  Padding(
                    padding: const EdgeInsets.only(
                      top: 8,
                      left: 32,
                      right: 32,
                      bottom: 32,
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          "Reusing addresses reduces your privacy and security.  Are you sure you want to reuse addresses by default?",
                          style: STextStyles.desktopTextSmall(context),
                        ),
                        const SizedBox(height: 43),
                        Row(
                          children: [
                            Expanded(
                              child: SecondaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(false);
                                },
                                label: "Cancel",
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: PrimaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(true);
                                },
                                label: "Continue",
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            );
          },
        );

        if (canContinue == true) {
          await _updateAddressReuse(true);
        }
      } else {
        await _updateAddressReuse(false);
      }
    } finally {
      // ensure _switchReuseAddressToggledLock is set to false no matter what.
      _switchReuseAddressToggledLock = false;
    }
  }

  Future<void> _updateAddressReuse(bool shouldReuse) async {
    await ref
        .read(pWalletInfo(widget.walletId))
        .updateOtherData(
          newEntries: {WalletInfoKeys.reuseAddress: shouldReuse},
          isar: ref.read(mainDBProvider).isar,
        );

    if (_switchControllerAddressReuse.isOn != null) {
      if (_switchControllerAddressReuse.isOn!.call() != shouldReuse) {
        _switchControllerAddressReuse.activate?.call();
      }
    }
  }

  bool _switchMwebToggleToggledLock = false; // Mutex.
  Future<void> _switchMwebToggleToggled() async {
    if (_switchMwebToggleToggledLock) {
      return;
    }
    _switchMwebToggleToggledLock = true; // Lock mutex.

    try {
      if (_switchControllerMwebToggle.isOn?.call() != true) {
        final canContinue = await showDialog<bool?>(
          context: context,
          builder: (context) {
            return DesktopDialog(
              maxWidth: 576,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(left: 32),
                        child: Text(
                          "Warning!",
                          style: STextStyles.desktopH3(context),
                        ),
                      ),
                      const DesktopDialogCloseButton(),
                    ],
                  ),
                  Padding(
                    padding: const EdgeInsets.only(
                      top: 8,
                      left: 32,
                      right: 32,
                      bottom: 32,
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          "TODO warning about extra data downloaded and initial sync/scan time",
                          style: STextStyles.desktopTextSmall(context),
                        ),
                        const SizedBox(height: 43),
                        Row(
                          children: [
                            Expanded(
                              child: SecondaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(false);
                                },
                                label: "Cancel",
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: PrimaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(true);
                                },
                                label: "Continue",
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            );
          },
        );

        if (canContinue == true) {
          await _updateMwebToggle(true);

          unawaited(ref.read(pWallets).getWallet(widget.walletId).init());
        }
      } else {
        await _updateMwebToggle(false);
      }
    } finally {
      // ensure _switchMwebToggleToggledLock is set to false no matter what.
      _switchMwebToggleToggledLock = false;
    }
  }

  Future<void> _updateMwebToggle(bool shouldReuse) async {
    await ref
        .read(pWalletInfo(widget.walletId))
        .updateOtherData(
          newEntries: {WalletInfoKeys.mwebEnabled: shouldReuse},
          isar: ref.read(mainDBProvider).isar,
        );

    if (_switchControllerMwebToggle.isOn != null) {
      if (_switchControllerMwebToggle.isOn!.call() != shouldReuse) {
        _switchControllerMwebToggle.activate?.call();
      }
    }
  }

  @override
  void initState() {
    _switchControllerAddressReuse = DSBController();
    _switchControllerMwebToggle = DSBController();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final wallet = ref.watch(
      pWallets.select((value) => value.getWallet(widget.walletId)),
    );

    return DesktopDialog(
      maxHeight: double.infinity,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Padding(
                padding: const EdgeInsets.only(left: 32),
                child: Text(
                  "More features",
                  style: STextStyles.desktopH3(context),
                ),
              ),
              const DesktopDialogCloseButton(),
            ],
          ),

          ...widget.options.map((option) {
            switch (option.$1) {
              case WalletFeature.buy:
                // Buy has a special icon
                return _MoreFeaturesItem(
                  label: option.$1.label,
                  detail: option.$1.description,
                  isSvgFile: true,
                  iconAsset: ref.watch(
                    themeProvider.select((value) => value.assets.buy),
                  ),
                  onPressed: () async {
                    Navigator.of(context, rootNavigator: true).pop();
                    option.$3();
                  },
                );

              case WalletFeature.clearSparkCache:
                return _MoreFeaturesClearSparkCacheItem(
                  cryptoCurrency: wallet.cryptoCurrency,
                );

              case WalletFeature.rbf:
                return _MoreFeaturesItemBase(
                  child: Row(
                    children: [
                      const SizedBox(width: 3),
                      SizedBox(
                        height: 20,
                        width: 40,
                        child: DraggableSwitchButton(
                          isOn:
                              ref.watch(
                                    pWalletInfo(
                                      widget.walletId,
                                    ).select((value) => value.otherData),
                                  )[WalletInfoKeys.enableOptInRbf]
                                  as bool? ??
                              false,
                          onValueChanged: _switchRbfToggled,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Flag outgoing transactions with opt-in RBF",
                            style: STextStyles.w600_20(context),
                          ),
                        ],
                      ),
                    ],
                  ),
                );

              case WalletFeature.reuseAddress:
                return _MoreFeaturesItemBase(
                  onPressed: _switchReuseAddressToggled,
                  child: Row(
                    children: [
                      const SizedBox(width: 3),
                      SizedBox(
                        height: 20,
                        width: 40,
                        child: IgnorePointer(
                          child: DraggableSwitchButton(
                            isOn:
                                ref.watch(
                                      pWalletInfo(
                                        widget.walletId,
                                      ).select((value) => value.otherData),
                                    )[WalletInfoKeys.reuseAddress]
                                    as bool? ??
                                false,
                            controller: _switchControllerAddressReuse,
                          ),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Reuse receiving address",
                            style: STextStyles.w600_20(context),
                          ),
                        ],
                      ),
                    ],
                  ),
                );

              case WalletFeature.enableMweb:
                return _MoreFeaturesItemBase(
                  onPressed: _switchMwebToggleToggled,
                  child: Row(
                    children: [
                      const SizedBox(width: 3),
                      SizedBox(
                        height: 20,
                        width: 40,
                        child: IgnorePointer(
                          child: DraggableSwitchButton(
                            isOn:
                                ref.watch(
                                      pWalletInfo(
                                        widget.walletId,
                                      ).select((value) => value.otherData),
                                    )[WalletInfoKeys.mwebEnabled]
                                    as bool? ??
                                false,
                            controller: _switchControllerMwebToggle,
                          ),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Enable MWEB",
                            style: STextStyles.w600_20(context),
                          ),
                        ],
                      ),
                    ],
                  ),
                );

              default:
                return _MoreFeaturesItem(
                  label: option.$1.label,
                  detail: option.$1.description,
                  iconAsset: option.$2,
                  onPressed: () async {
                    Navigator.of(context, rootNavigator: true).pop();
                    option.$3();
                  },
                );
            }
          }),

          const SizedBox(height: 28),
        ],
      ),
    );
  }
}

class _MoreFeaturesItem extends StatefulWidget {
  const _MoreFeaturesItem({
    super.key,
    required this.label,
    required this.detail,
    required this.iconAsset,
    this.isSvgFile = false,
    this.onPressed,
  });

  static const double iconSizeBG = 46;
  static const double iconSize = 24;

  final String label;
  final String detail;
  final String iconAsset;
  final bool isSvgFile;
  final Future<void> Function()? onPressed;

  @override
  State<_MoreFeaturesItem> createState() => _MoreFeaturesItemState();
}

class _MoreFeaturesItemState extends State<_MoreFeaturesItem> {
  bool _onPressedLock = false;

  @override
  Widget build(BuildContext context) {
    return _MoreFeaturesItemBase(
      onPressed: () async {
        if (_onPressedLock) {
          return;
        }
        _onPressedLock = true;
        try {
          await widget.onPressed?.call();
        } finally {
          _onPressedLock = false;
        }
      },
      child: Row(
        children: [
          RoundedContainer(
            padding: const EdgeInsets.all(0),
            color: Theme.of(context).extension<StackColors>()!.settingsIconBack,
            width: _MoreFeaturesItem.iconSizeBG,
            height: _MoreFeaturesItem.iconSizeBG,
            radiusMultiplier: _MoreFeaturesItem.iconSizeBG,
            child: Center(
              child:
                  widget.isSvgFile
                      ? SvgPicture.file(
                        File(widget.iconAsset),
                        width: _MoreFeaturesItem.iconSize,
                        height: _MoreFeaturesItem.iconSize,
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.settingsIconIcon,
                      )
                      : SvgPicture.asset(
                        widget.iconAsset,
                        width: _MoreFeaturesItem.iconSize,
                        height: _MoreFeaturesItem.iconSize,
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.settingsIconIcon,
                      ),
            ),
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(widget.label, style: STextStyles.w600_20(context)),
              Text(
                widget.detail,
                style: STextStyles.desktopTextExtraExtraSmall(context),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _MoreFeaturesItemBase extends StatelessWidget {
  const _MoreFeaturesItemBase({super.key, required this.child, this.onPressed});

  final Widget child;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 32),
      child: RoundedContainer(
        color: Colors.transparent,
        borderColor:
            Theme.of(context).extension<StackColors>()!.textFieldDefaultBG,
        onPressed: onPressed,
        child: child,
      ),
    );
  }
}

class _MoreFeaturesClearSparkCacheItem extends StatefulWidget {
  const _MoreFeaturesClearSparkCacheItem({
    super.key,
    required this.cryptoCurrency,
  });

  final CryptoCurrency cryptoCurrency;

  @override
  State<_MoreFeaturesClearSparkCacheItem> createState() =>
      _MoreFeaturesClearSparkCacheItemState();
}

class _MoreFeaturesClearSparkCacheItemState
    extends State<_MoreFeaturesClearSparkCacheItem> {
  bool _onPressedLock = false;

  static const label = "Reset Spark electrumx cache";

  @override
  Widget build(BuildContext context) {
    return _MoreFeaturesItemBase(
      onPressed: () async {
        if (_onPressedLock) {
          return;
        }
        _onPressedLock = true;
        try {
          await FiroCacheCoordinator.clearSharedCache(
            widget.cryptoCurrency.network,
          );
          setState(() {
            // trigger rebuild for cache size display
          });
        } finally {
          _onPressedLock = false;
        }
      },
      child: Row(
        children: [
          RoundedContainer(
            padding: const EdgeInsets.all(0),
            color: Theme.of(context).extension<StackColors>()!.settingsIconBack,
            width: _MoreFeaturesItem.iconSizeBG,
            height: _MoreFeaturesItem.iconSizeBG,
            radiusMultiplier: _MoreFeaturesItem.iconSizeBG,
            child: Center(
              child: SvgPicture.asset(
                Assets.svg.x,
                width: _MoreFeaturesItem.iconSize,
                height: _MoreFeaturesItem.iconSize,
                color:
                    Theme.of(
                      context,
                    ).extension<StackColors>()!.settingsIconIcon,
              ),
            ),
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: STextStyles.w600_20(context)),
              FutureBuilder(
                future: FiroCacheCoordinator.getSparkCacheSize(
                  widget.cryptoCurrency.network,
                ),
                builder: (_, snapshot) {
                  return Text(
                    snapshot.data ?? "",
                    style: STextStyles.desktopTextExtraExtraSmall(context),
                  );
                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}
