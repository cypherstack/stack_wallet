/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:wakelock_plus/wakelock_plus.dart';

import '../../../../../app_config.dart';
import '../../../../../db/sqlite/firo_cache.dart';
import '../../../../../models/keys/view_only_wallet_data.dart';
import '../../../../../providers/db/main_db_provider.dart';
import '../../../../../providers/global/prefs_provider.dart';
import '../../../../../providers/global/wallets_provider.dart';
import '../../../../../themes/stack_colors.dart';
import '../../../../../utilities/assets.dart';
import '../../../../../utilities/logger.dart';
import '../../../../../utilities/show_loading.dart';
import '../../../../../utilities/text_styles.dart';
import '../../../../../utilities/util.dart';
import '../../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../../wallets/isar/models/wallet_info.dart';
import '../../../../../wallets/isar/providers/wallet_info_provider.dart';
import '../../../../../wallets/wallet/impl/firo_wallet.dart';
import '../../../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/cash_fusion_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/coin_control_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/lelantus_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/ordinals_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/paynym_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/rbf_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/spark_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/view_only_option_interface.dart';
import '../../../../../widgets/custom_buttons/draggable_switch_button.dart';
import '../../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../../widgets/desktop/desktop_dialog_close_button.dart';
import '../../../../../widgets/desktop/primary_button.dart';
import '../../../../../widgets/desktop/secondary_button.dart';
import '../../../../../widgets/rounded_container.dart';
import '../../../../../widgets/stack_dialog.dart';

class MoreFeaturesDialog extends ConsumerStatefulWidget {
  const MoreFeaturesDialog({
    super.key,
    required this.walletId,
    required this.onPaynymPressed,
    required this.onCoinControlPressed,
    required this.onLelantusCoinsPressed,
    required this.onSparkCoinsPressedPressed,
    required this.onAnonymizeAllPressed,
    required this.onWhirlpoolPressed,
    required this.onOrdinalsPressed,
    required this.onMonkeyPressed,
    required this.onFusionPressed,
    required this.onChurnPressed,
  });

  final String walletId;
  final VoidCallback? onPaynymPressed;
  final VoidCallback? onCoinControlPressed;
  final VoidCallback? onLelantusCoinsPressed;
  final VoidCallback? onSparkCoinsPressedPressed;
  final VoidCallback? onAnonymizeAllPressed;
  final VoidCallback? onWhirlpoolPressed;
  final VoidCallback? onOrdinalsPressed;
  final VoidCallback? onMonkeyPressed;
  final VoidCallback? onFusionPressed;
  final VoidCallback? onChurnPressed;

  @override
  ConsumerState<MoreFeaturesDialog> createState() => _MoreFeaturesDialogState();
}

class _MoreFeaturesDialogState extends ConsumerState<MoreFeaturesDialog> {
  bool _isUpdatingLelantusScanning = false; // Mutex.

  Future<void> _switchToggled(bool newValue) async {
    if (_isUpdatingLelantusScanning) return;
    _isUpdatingLelantusScanning = true; // Lock mutex.

    try {
      // Toggle enableLelantusScanning in wallet info.
      await ref.read(pWalletInfo(widget.walletId)).updateOtherData(
        newEntries: {
          WalletInfoKeys.enableLelantusScanning: newValue,
        },
        isar: ref.read(mainDBProvider).isar,
      );

      if (newValue) {
        await _doRescanMaybe();
      }
    } finally {
      // ensure _isUpdatingLelantusScanning is set to false no matter what
      _isUpdatingLelantusScanning = false;
    }
  }

  bool _switchRbfToggledLock = false; // Mutex.
  Future<void> _switchRbfToggled(bool newValue) async {
    if (_switchRbfToggledLock) {
      return;
    }
    _switchRbfToggledLock = true; // Lock mutex.

    try {
      // Toggle enableOptInRbf in wallet info.
      await ref.read(pWalletInfo(widget.walletId)).updateOtherData(
        newEntries: {
          WalletInfoKeys.enableOptInRbf: newValue,
        },
        isar: ref.read(mainDBProvider).isar,
      );
    } finally {
      // ensure _switchRbfToggledLock is set to false no matter what
      _switchRbfToggledLock = false;
    }
  }

  Future<void> _doRescanMaybe() async {
    final shouldRescan = await showDialog<bool>(
      context: context,
      builder: (context) {
        return DesktopDialog(
          maxWidth: 700,
          child: Column(
            children: [
              const DesktopDialogCloseButton(),
              const SizedBox(
                height: 5,
              ),
              Text(
                "Rescan may be required",
                style: STextStyles.desktopH2(context),
                textAlign: TextAlign.left,
              ),
              const SizedBox(
                height: 16,
              ),
              const Spacer(),
              Text(
                "A blockchain rescan may be required to fully recover all lelantus history."
                "\nThis may take a while.",
                style: STextStyles.desktopTextMedium(context).copyWith(
                  color: Theme.of(context).extension<StackColors>()!.textDark3,
                ),
                textAlign: TextAlign.center,
              ),
              const Spacer(),
              Padding(
                padding: const EdgeInsets.only(
                  left: 32,
                  right: 32,
                  bottom: 32,
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: SecondaryButton(
                        label: "Rescan now",
                        onPressed: () {
                          Navigator.of(context).pop(true);
                        },
                      ),
                    ),
                    const SizedBox(
                      width: 16,
                    ),
                    Expanded(
                      child: PrimaryButton(
                        label: "Later",
                        onPressed: () => Navigator.of(context).pop(false),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );

    if (mounted && shouldRescan == true) {
      try {
        if (!Platform.isLinux) await WakelockPlus.enable();

        Exception? e;
        if (mounted) {
          await showLoading(
            whileFuture: ref.read(pWallets).getWallet(widget.walletId).recover(
                  isRescan: true,
                ),
            context: context,
            message: "Rescanning blockchain",
            subMessage:
                "This may take a while.\nPlease do not exit this screen.",
            rootNavigator: Util.isDesktop,
            onException: (ex) => e = ex,
          );

          if (e != null) {
            throw e!;
          }
        }
      } catch (e, s) {
        Logging.instance.e("$e\n$s", error: e, stackTrace: s);
        if (mounted) {
          // show error
          await showDialog<dynamic>(
            context: context,
            useSafeArea: false,
            barrierDismissible: true,
            builder: (context) => StackDialog(
              title: "Rescan failed",
              message: e.toString(),
              rightButton: TextButton(
                style: Theme.of(context)
                    .extension<StackColors>()!
                    .getSecondaryEnabledButtonStyle(context),
                child: Text(
                  "Ok",
                  style: STextStyles.itemSubtitle12(context),
                ),
                onPressed: () {
                  Navigator.of(context, rootNavigator: Util.isDesktop).pop();
                },
              ),
            ),
          );
        }
      } finally {
        if (!Platform.isLinux) await WakelockPlus.disable();
      }
    }
  }

  late final DSBController _switchController;

  bool _switchReuseAddressToggledLock = false; // Mutex.
  Future<void> _switchReuseAddressToggled() async {
    if (_switchReuseAddressToggledLock) {
      return;
    }
    _switchReuseAddressToggledLock = true; // Lock mutex.

    try {
      if (_switchController.isOn?.call() != true) {
        final canContinue = await showDialog<bool?>(
          context: context,
          builder: (context) {
            return DesktopDialog(
              maxWidth: 576,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(left: 32),
                        child: Text(
                          "Warning!",
                          style: STextStyles.desktopH3(context),
                        ),
                      ),
                      const DesktopDialogCloseButton(),
                    ],
                  ),
                  Padding(
                    padding: const EdgeInsets.only(
                      top: 8,
                      left: 32,
                      right: 32,
                      bottom: 32,
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(
                          "Reusing addresses reduces your privacy and security.  Are you sure you want to reuse addresses by default?",
                          style: STextStyles.desktopTextSmall(context),
                        ),
                        const SizedBox(
                          height: 43,
                        ),
                        Row(
                          children: [
                            Expanded(
                              child: SecondaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(false);
                                },
                                label: "Cancel",
                              ),
                            ),
                            const SizedBox(
                              width: 16,
                            ),
                            Expanded(
                              child: PrimaryButton(
                                buttonHeight: ButtonHeight.l,
                                onPressed: () {
                                  Navigator.of(context).pop(true);
                                },
                                label: "Continue",
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            );
          },
        );

        if (canContinue == true) {
          await _updateAddressReuse(true);
        }
      } else {
        await _updateAddressReuse(false);
      }
    } finally {
      // ensure _switchReuseAddressToggledLock is set to false no matter what.
      _switchReuseAddressToggledLock = false;
    }
  }

  Future<void> _updateAddressReuse(bool shouldReuse) async {
    await ref.read(pWalletInfo(widget.walletId)).updateOtherData(
      newEntries: {
        WalletInfoKeys.reuseAddress: shouldReuse,
      },
      isar: ref.read(mainDBProvider).isar,
    );

    if (_switchController.isOn != null) {
      if (_switchController.isOn!.call() != shouldReuse) {
        _switchController.activate?.call();
      }
    }
  }

  @override
  void initState() {
    _switchController = DSBController();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final wallet = ref.watch(
      pWallets.select(
        (value) => value.getWallet(widget.walletId),
      ),
    );

    final coinControlPrefEnabled = ref.watch(
      prefsChangeNotifierProvider.select(
        (value) => value.enableCoinControl,
      ),
    );

    final isViewOnly = wallet is ViewOnlyOptionInterface && wallet.isViewOnly;
    final isViewOnlyNoAddressGen = wallet is ViewOnlyOptionInterface &&
        wallet.isViewOnly &&
        wallet.viewOnlyType == ViewOnlyWalletType.addressOnly;

    return DesktopDialog(
      maxHeight: double.infinity,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Padding(
                padding: const EdgeInsets.only(
                  left: 32,
                ),
                child: Text(
                  "More features",
                  style: STextStyles.desktopH3(context),
                ),
              ),
              const DesktopDialogCloseButton(),
            ],
          ),
          if (!isViewOnly && wallet.info.coin is Firo)
            _MoreFeaturesItem(
              label: "Anonymize funds",
              detail: "Anonymize funds",
              iconAsset: Assets.svg.recycle,
              onPressed: () async => widget.onAnonymizeAllPressed?.call(),
            ),
          // TODO: [prio=med]
          // if (manager.hasWhirlpoolSupport)
          //   _MoreFeaturesItem(
          //     label: "Whirlpool",
          //     detail: "Powerful Bitcoin privacy enhancer",
          //     iconAsset: Assets.svg.whirlPool,
          //     onPressed: () => widget.onWhirlpoolPressed?.call(),
          //   ),
          if (wallet is CoinControlInterface && coinControlPrefEnabled)
            _MoreFeaturesItem(
              label: "Coin control",
              detail: "Control, freeze, and utilize outputs at your discretion",
              iconAsset: Assets.svg.coinControl.gamePad,
              onPressed: () async => widget.onCoinControlPressed?.call(),
            ),
          if (wallet is FiroWallet &&
              ref.watch(prefsChangeNotifierProvider
                  .select((s) => s.advancedFiroFeatures)))
            _MoreFeaturesItem(
              label: "Lelantus Coins",
              detail: "View wallet lelantus coins",
              iconAsset: Assets.svg.coinControl.gamePad,
              onPressed: () async => widget.onLelantusCoinsPressed?.call(),
            ),
          if (wallet is FiroWallet &&
              ref.watch(prefsChangeNotifierProvider
                  .select((s) => s.advancedFiroFeatures)))
            _MoreFeaturesItem(
              label: "Spark Coins",
              detail: "View wallet spark coins",
              iconAsset: Assets.svg.coinControl.gamePad,
              onPressed: () async => widget.onSparkCoinsPressedPressed?.call(),
            ),
          if (!isViewOnly && wallet is PaynymInterface)
            _MoreFeaturesItem(
              label: "PayNym",
              detail: "Increased address privacy using BIP47",
              iconAsset: Assets.svg.robotHead,
              onPressed: () async => widget.onPaynymPressed?.call(),
            ),
          if (wallet is OrdinalsInterface)
            _MoreFeaturesItem(
              label: "Ordinals",
              detail: "View and control your ordinals in ${AppConfig.prefix}",
              iconAsset: Assets.svg.ordinal,
              onPressed: () async => widget.onOrdinalsPressed?.call(),
            ),
          if (wallet.info.coin is Banano)
            _MoreFeaturesItem(
              label: "MonKey",
              detail: "Generate Banano MonKey",
              iconAsset: Assets.svg.monkey,
              onPressed: () async => widget.onMonkeyPressed?.call(),
            ),
          if (!isViewOnly && wallet is CashFusionInterface)
            _MoreFeaturesItem(
              label: "Fusion",
              detail: "Decentralized mixing protocol",
              iconAsset: Assets.svg.cashFusion,
              onPressed: () async => widget.onFusionPressed?.call(),
            ),
          if (!isViewOnly && wallet is LibMoneroWallet)
            _MoreFeaturesItem(
              label: "Churn",
              detail: "Churning",
              iconAsset: Assets.svg.churn,
              onPressed: () async => widget.onChurnPressed?.call(),
            ),
          if (wallet is SparkInterface && !isViewOnly)
            _MoreFeaturesClearSparkCacheItem(
              cryptoCurrency: wallet.cryptoCurrency,
            ),
          if (wallet is LelantusInterface && !isViewOnly)
            _MoreFeaturesItemBase(
              child: Row(
                children: [
                  const SizedBox(width: 3),
                  SizedBox(
                    height: 20,
                    width: 40,
                    child: DraggableSwitchButton(
                      isOn: ref.watch(
                            pWalletInfo(widget.walletId)
                                .select((value) => value.otherData),
                          )[WalletInfoKeys.enableLelantusScanning] as bool? ??
                          false,
                      onValueChanged: _switchToggled,
                    ),
                  ),
                  const SizedBox(
                    width: 16,
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        "Scan for Lelantus transactions",
                        style: STextStyles.w600_20(context),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          if (wallet is RbfInterface)
            _MoreFeaturesItemBase(
              child: Row(
                children: [
                  const SizedBox(width: 3),
                  SizedBox(
                    height: 20,
                    width: 40,
                    child: DraggableSwitchButton(
                      isOn: ref.watch(
                            pWalletInfo(widget.walletId)
                                .select((value) => value.otherData),
                          )[WalletInfoKeys.enableOptInRbf] as bool? ??
                          false,
                      onValueChanged: _switchRbfToggled,
                    ),
                  ),
                  const SizedBox(
                    width: 16,
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        "Flag outgoing transactions with opt-in RBF",
                        style: STextStyles.w600_20(context),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          // reuseAddress preference.
          if (!isViewOnlyNoAddressGen)
            _MoreFeaturesItemBase(
              onPressed: _switchReuseAddressToggled,
              child: Row(
                children: [
                  const SizedBox(width: 3),
                  SizedBox(
                    height: 20,
                    width: 40,
                    child: IgnorePointer(
                      child: DraggableSwitchButton(
                        isOn: ref.watch(
                              pWalletInfo(widget.walletId)
                                  .select((value) => value.otherData),
                            )[WalletInfoKeys.reuseAddress] as bool? ??
                            false,
                        controller: _switchController,
                      ),
                    ),
                  ),
                  const SizedBox(
                    width: 16,
                  ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        "Reuse receiving address",
                        style: STextStyles.w600_20(context),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          const SizedBox(
            height: 28,
          ),
        ],
      ),
    );
  }
}

class _MoreFeaturesItem extends StatefulWidget {
  const _MoreFeaturesItem({
    super.key,
    required this.label,
    required this.detail,
    required this.iconAsset,
    this.onPressed,
  });

  static const double iconSizeBG = 46;
  static const double iconSize = 24;

  final String label;
  final String detail;
  final String iconAsset;
  final Future<void> Function()? onPressed;

  @override
  State<_MoreFeaturesItem> createState() => _MoreFeaturesItemState();
}

class _MoreFeaturesItemState extends State<_MoreFeaturesItem> {
  bool _onPressedLock = false;

  @override
  Widget build(BuildContext context) {
    return _MoreFeaturesItemBase(
      onPressed: () async {
        if (_onPressedLock) {
          return;
        }
        _onPressedLock = true;
        try {
          await widget.onPressed?.call();
        } finally {
          _onPressedLock = false;
        }
      },
      child: Row(
        children: [
          RoundedContainer(
            padding: const EdgeInsets.all(0),
            color: Theme.of(context).extension<StackColors>()!.settingsIconBack,
            width: _MoreFeaturesItem.iconSizeBG,
            height: _MoreFeaturesItem.iconSizeBG,
            radiusMultiplier: _MoreFeaturesItem.iconSizeBG,
            child: Center(
              child: SvgPicture.asset(
                widget.iconAsset,
                width: _MoreFeaturesItem.iconSize,
                height: _MoreFeaturesItem.iconSize,
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .settingsIconIcon,
              ),
            ),
          ),
          const SizedBox(
            width: 16,
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                widget.label,
                style: STextStyles.w600_20(context),
              ),
              Text(
                widget.detail,
                style: STextStyles.desktopTextExtraExtraSmall(context),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _MoreFeaturesItemBase extends StatelessWidget {
  const _MoreFeaturesItemBase({
    super.key,
    required this.child,
    this.onPressed,
  });

  final Widget child;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(
        vertical: 6,
        horizontal: 32,
      ),
      child: RoundedContainer(
        color: Colors.transparent,
        borderColor:
            Theme.of(context).extension<StackColors>()!.textFieldDefaultBG,
        onPressed: onPressed,
        child: child,
      ),
    );
  }
}

class _MoreFeaturesClearSparkCacheItem extends StatefulWidget {
  const _MoreFeaturesClearSparkCacheItem({
    super.key,
    required this.cryptoCurrency,
  });

  final CryptoCurrency cryptoCurrency;

  @override
  State<_MoreFeaturesClearSparkCacheItem> createState() =>
      _MoreFeaturesClearSparkCacheItemState();
}

class _MoreFeaturesClearSparkCacheItemState
    extends State<_MoreFeaturesClearSparkCacheItem> {
  bool _onPressedLock = false;

  static const label = "Reset Spark electrumx cache";

  @override
  Widget build(BuildContext context) {
    return _MoreFeaturesItemBase(
      onPressed: () async {
        if (_onPressedLock) {
          return;
        }
        _onPressedLock = true;
        try {
          await FiroCacheCoordinator.clearSharedCache(
            widget.cryptoCurrency.network,
          );
          setState(() {
            // trigger rebuild for cache size display
          });
        } finally {
          _onPressedLock = false;
        }
      },
      child: Row(
        children: [
          RoundedContainer(
            padding: const EdgeInsets.all(0),
            color: Theme.of(context).extension<StackColors>()!.settingsIconBack,
            width: _MoreFeaturesItem.iconSizeBG,
            height: _MoreFeaturesItem.iconSizeBG,
            radiusMultiplier: _MoreFeaturesItem.iconSizeBG,
            child: Center(
              child: SvgPicture.asset(
                Assets.svg.x,
                width: _MoreFeaturesItem.iconSize,
                height: _MoreFeaturesItem.iconSize,
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .settingsIconIcon,
              ),
            ),
          ),
          const SizedBox(
            width: 16,
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: STextStyles.w600_20(context),
              ),
              FutureBuilder(
                future: FiroCacheCoordinator.getSparkCacheSize(
                  widget.cryptoCurrency.network,
                ),
                builder: (_, snapshot) {
                  return Text(
                    snapshot.data ?? "",
                    style: STextStyles.desktopTextExtraExtraSmall(context),
                  );
                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}
