/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../providers/desktop/current_desktop_menu_item.dart';
import '../providers/global/active_wallet_provider.dart';
import '../providers/global/auto_swb_service_provider.dart';
import '../providers/global/notifications_provider.dart';
import '../providers/global/prefs_provider.dart';
import '../providers/global/wallets_provider.dart';
import '../providers/ui/transaction_filter_provider.dart';
import '../providers/ui/unread_notifications_provider.dart';
import '../route_generator.dart';
import '../themes/stack_colors.dart';
import '../utilities/enums/backup_frequency_type.dart';
import '../utilities/idle_monitor.dart';
import '../utilities/prefs.dart';
import '../widgets/background.dart';
import 'address_book_view/desktop_address_book.dart';
import 'desktop_buy/desktop_buy_view.dart';
import 'desktop_exchange/desktop_exchange_view.dart';
import 'desktop_menu.dart';
import 'my_stack_view/my_stack_view.dart';
import 'notifications/desktop_notifications_view.dart';
import 'password/desktop_unlock_app_dialog.dart';
import 'settings/desktop_settings_view.dart';
import 'settings/settings_menu/desktop_about_view.dart';
import 'settings/settings_menu/desktop_support_view.dart';

class DesktopHomeView extends ConsumerStatefulWidget {
  const DesktopHomeView({super.key});

  static const String routeName = "/desktopHome";

  @override
  ConsumerState<DesktopHomeView> createState() => _DesktopHomeViewState();
}

class _DesktopHomeViewState extends ConsumerState<DesktopHomeView> {
  final GlobalKey myStackViewNavKey = GlobalKey<NavigatorState>();
  late final Navigator myStackViewNav;
  IdleMonitor? _idleMonitor;

  void _onIdle() async {
    final context = myStackViewNavKey.currentContext;
    if (context != null) {
      await showDialog<void>(
        barrierDismissible: false,
        context: context,
        useSafeArea: false,
        builder:
            (context) => const Background(
              child: Center(child: DesktopUnlockAppDialog()),
            ),
      );
    }
  }

  late AutoLockInfo _autoLockInfo;
  void _prefsTimeoutListener() {
    final prefs = ref.read(prefsChangeNotifierProvider);
    if (mounted && prefs.autoLockInfo != _autoLockInfo) {
      _autoLockInfo = prefs.autoLockInfo;
      if (_autoLockInfo.enabled) {
        _idleMonitor?.detach();
        _idleMonitor = IdleMonitor(
          timeout: Duration(minutes: _autoLockInfo.minutes),
          onIdle: _onIdle,
        );
        _idleMonitor!.attach();
      } else {
        _idleMonitor?.detach();
        _idleMonitor = null;
      }
    }
  }

  @override
  void initState() {
    _autoLockInfo = ref.read(prefsChangeNotifierProvider).autoLockInfo;
    if (_autoLockInfo.enabled) {
      _idleMonitor = IdleMonitor(
        timeout: Duration(minutes: _autoLockInfo.minutes),
        onIdle: _onIdle,
      );
    }

    myStackViewNav = Navigator(
      key: myStackViewNavKey,
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: MyStackView.routeName,
    );
    _idleMonitor?.attach();

    ref.read(prefsChangeNotifierProvider).addListener(_prefsTimeoutListener);

    // WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
    //   showOneTimeTorHasBeenAddedDialogIfRequired(context);
    // });

    super.initState();
  }

  @override
  dispose() {
    ref.read(prefsChangeNotifierProvider).removeListener(_prefsTimeoutListener);
    _idleMonitor?.detach();
    super.dispose();
  }

  final Map<DesktopMenuItemId, Widget> contentViews = {
    DesktopMenuItemId.myStack: Container(
      // key: Key("desktopStackHomeKey"),
      // onGenerateRoute: RouteGenerator.generateRoute,
      // initialRoute: MyStackView.routeName,
    ),
    DesktopMenuItemId.exchange: const Navigator(
      key: Key("desktopExchangeHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopExchangeView.routeName,
    ),
    DesktopMenuItemId.buy: const Navigator(
      key: Key("desktopBuyHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopBuyView.routeName,
    ),
    DesktopMenuItemId.notifications: const Navigator(
      key: Key("desktopNotificationsHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopNotificationsView.routeName,
    ),
    DesktopMenuItemId.addressBook: const Navigator(
      key: Key("desktopAddressBookHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopAddressBook.routeName,
    ),
    DesktopMenuItemId.settings: const Navigator(
      key: Key("desktopSettingHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopSettingsView.routeName,
    ),
    DesktopMenuItemId.support: const Navigator(
      key: Key("desktopSupportHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopSupportView.routeName,
    ),
    DesktopMenuItemId.about: const Navigator(
      key: Key("desktopAboutHomeKey"),
      onGenerateRoute: RouteGenerator.generateRoute,
      initialRoute: DesktopAboutView.routeName,
    ),
  };

  void onMenuSelectionWillChange(DesktopMenuItemId newKey) {
    // handle logging out of active wallet
    if (ref.read(prevDesktopMenuItemProvider.state).state ==
            DesktopMenuItemId.myStack &&
        ref.read(prevDesktopMenuItemProvider.state).state == newKey) {
      Navigator.of(
        myStackViewNavKey.currentContext!,
      ).popUntil(ModalRoute.withName(MyStackView.routeName));
      if (ref.read(currentWalletIdProvider.state).state != null) {
        final wallet = ref
            .read(pWallets)
            .getWallet(ref.read(currentWalletIdProvider)!);

        if (wallet.shouldAutoSync) {
          wallet.shouldAutoSync = false;
        }
        ref.read(transactionFilterProvider.state).state = null;
        if (ref.read(prefsChangeNotifierProvider).isAutoBackupEnabled &&
            ref.read(prefsChangeNotifierProvider).backupFrequencyType ==
                BackupFrequencyType.afterClosingAWallet) {
          ref.read(autoSWBServiceProvider).doBackup();
        }

        // ref.read(managerProvider.notifier).isActiveWallet = false;
        // TODO: call exit here?
        // wallet.exit(); ??
      }
    }
    ref.read(prevDesktopMenuItemProvider.state).state = newKey;

    // check for unread notifications and refresh provider before
    // showing notifications view
    if (newKey == DesktopMenuItemId.notifications) {
      ref.refresh(unreadNotificationsStateProvider);
    }
    // mark notifications as read if leaving notifications view
    if (ref.read(currentDesktopMenuItemProvider.state).state ==
            DesktopMenuItemId.notifications &&
        newKey != DesktopMenuItemId.notifications) {
      final Set<int> unreadNotificationIds =
          ref.read(unreadNotificationsStateProvider.state).state;

      if (unreadNotificationIds.isNotEmpty) {
        final List<Future<void>> futures = [];
        for (int i = 0; i < unreadNotificationIds.length - 1; i++) {
          futures.add(
            ref
                .read(notificationsProvider)
                .markAsRead(unreadNotificationIds.elementAt(i), false),
          );
        }

        // wait for multiple to update if any
        Future.wait(futures).then((_) {
          // only notify listeners once
          ref
              .read(notificationsProvider)
              .markAsRead(unreadNotificationIds.last, true);
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Theme.of(context).extension<StackColors>()!.background,
      child: Background(
        child: Row(
          children: [
            DesktopMenu(
              // onSelectionChanged: onMenuSelectionChanged,
              onSelectionWillChange: onMenuSelectionWillChange,
            ),
            Container(
              width: 1,
              color: Theme.of(context).extension<StackColors>()!.background,
            ),
            Expanded(
              child: IndexedStack(
                index:
                    ref
                                .watch(currentDesktopMenuItemProvider.state)
                                .state
                                .index >
                            0
                        ? 1
                        : 0,
                children: [
                  myStackViewNav,
                  contentViews[ref
                      .watch(currentDesktopMenuItemProvider.state)
                      .state]!,
                ],
              ),
            ),
            // Expanded(
            //   child: contentViews[
            //       ref.watch(currentDesktopMenuItemProvider.state).state]!,
            // ),
          ],
        ),
      ),
    );
  }
}
