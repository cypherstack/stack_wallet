/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/svg.dart';
import 'package:isar/isar.dart';

import '../../../models/isar/models/isar_models.dart';
import '../../../pages/receive_view/addresses/address_card.dart';
import '../../../providers/db/main_db_provider.dart';
import '../../../themes/stack_colors.dart';
import '../../../utilities/assets.dart';
import '../../../utilities/constants.dart';
import '../../../utilities/text_styles.dart';
import '../../../utilities/util.dart';
import '../../../wallets/isar/providers/wallet_info_provider.dart';
import '../../../widgets/icon_widgets/x_icon.dart';
import '../../../widgets/rounded_white_container.dart';
import '../../../widgets/stack_text_field.dart';
import '../../../widgets/textfield_icon_button.dart';
import '../desktop_wallet_addresses_view.dart';

class DesktopAddressList extends ConsumerStatefulWidget {
  const DesktopAddressList({
    super.key,
    required this.walletId,
    this.searchHeight,
  });

  final String walletId;
  final double? searchHeight;

  @override
  ConsumerState<DesktopAddressList> createState() => _DesktopAddressListState();
}

class _DesktopAddressListState extends ConsumerState<DesktopAddressList> {
  final bool isDesktop = Util.isDesktop;

  String _searchString = "";

  late final TextEditingController _searchController;
  final searchFieldFocusNode = FocusNode();

  List<Id> _search(String term) {
    if (term.isEmpty) {
      return ref
          .read(mainDBProvider)
          .getAddresses(widget.walletId)
          .filter()
          .group(
            (q) => q
                .subTypeEqualTo(AddressSubType.change)
                .or()
                .subTypeEqualTo(AddressSubType.receiving)
                .or()
                .subTypeEqualTo(AddressSubType.paynymReceive)
                .or()
                .subTypeEqualTo(AddressSubType.paynymNotification),
          )
          .and()
          .not()
          .typeEqualTo(AddressType.nonWallet)
          .and()
          .group(
            (q) => q
                .group(
                  (q2) => q2
                      .typeEqualTo(AddressType.frostMS)
                      .and()
                      .zSafeFrostEqualTo(true),
                )
                .or()
                .not()
                .typeEqualTo(AddressType.frostMS),
          )
          .sortByDerivationIndex()
          .idProperty()
          .findAllSync();
    }

    final labels = ref
        .read(mainDBProvider)
        .getAddressLabels(widget.walletId)
        .filter()
        .group(
          (q) => q
              .valueContains(term, caseSensitive: false)
              .or()
              .addressStringContains(term, caseSensitive: false)
              .or()
              .group(
                (q) => q
                    .tagsIsNotNull()
                    .and()
                    .tagsElementContains(term, caseSensitive: false),
              ),
        )
        .findAllSync();

    if (labels.isEmpty) {
      return [];
    }

    return ref
        .read(mainDBProvider)
        .getAddresses(widget.walletId)
        .filter()
        .anyOf<AddressLabel, Address>(
          labels,
          (q, e) => q.valueEqualTo(e.addressString),
        )
        .group(
          (q) => q
              .subTypeEqualTo(AddressSubType.change)
              .or()
              .subTypeEqualTo(AddressSubType.receiving)
              .or()
              .subTypeEqualTo(AddressSubType.paynymReceive)
              .or()
              .subTypeEqualTo(AddressSubType.paynymNotification),
        )
        .and()
        .not()
        .typeEqualTo(AddressType.nonWallet)
        .and()
        .group(
          (q) => q
              .group(
                (q2) => q2
                    .typeEqualTo(AddressType.frostMS)
                    .and()
                    .zSafeFrostEqualTo(true),
              )
              .or()
              .not()
              .typeEqualTo(AddressType.frostMS),
        )
        .sortByDerivationIndex()
        .idProperty()
        .findAllSync();
  }

  @override
  void initState() {
    _searchController = TextEditingController();

    super.initState();
  }

  @override
  void dispose() {
    _searchController.dispose();
    searchFieldFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final coin = ref.watch(pWalletCoin(widget.walletId));

    final ids = _search(_searchString);

    return Column(
      children: [
        SizedBox(
          height: widget.searchHeight!,
          child: Center(
            child: ClipRRect(
              borderRadius: BorderRadius.circular(
                Constants.size.circularBorderRadius,
              ),
              child: TextField(
                autocorrect: !isDesktop,
                enableSuggestions: !isDesktop,
                controller: _searchController,
                focusNode: searchFieldFocusNode,
                onChanged: (value) {
                  setState(() {
                    _searchString = value;
                  });
                },
                style: isDesktop
                    ? STextStyles.desktopTextExtraSmall(context).copyWith(
                        color: Theme.of(context)
                            .extension<StackColors>()!
                            .textFieldActiveText,
                        height: 1.8,
                      )
                    : STextStyles.field(context),
                decoration: standardInputDecoration(
                  "Search...",
                  searchFieldFocusNode,
                  context,
                  desktopMed: isDesktop,
                ).copyWith(
                  prefixIcon: Padding(
                    padding: EdgeInsets.symmetric(
                      horizontal: isDesktop ? 12 : 10,
                      vertical: isDesktop ? 18 : 16,
                    ),
                    child: SvgPicture.asset(
                      Assets.svg.search,
                      width: isDesktop ? 20 : 16,
                      height: isDesktop ? 20 : 16,
                    ),
                  ),
                  suffixIcon: _searchController.text.isNotEmpty
                      ? Padding(
                          padding: const EdgeInsets.only(right: 0),
                          child: UnconstrainedBox(
                            child: Row(
                              children: [
                                TextFieldIconButton(
                                  child: const XIcon(),
                                  onTap: () async {
                                    setState(() {
                                      _searchController.text = "";
                                      _searchString = "";
                                    });
                                  },
                                ),
                              ],
                            ),
                          ),
                        )
                      : null,
                ),
              ),
            ),
          ),
        ),
        const SizedBox(
          height: 20,
        ),
        Expanded(
          child: RoundedWhiteContainer(
            padding: EdgeInsets.zero,
            child: ListView.separated(
              shrinkWrap: true,
              itemCount: ids.length,
              separatorBuilder: (_, __) => Container(
                height: 1,
                color: Theme.of(context)
                    .extension<StackColors>()!
                    .backgroundAppBar,
              ),
              itemBuilder: (_, index) => Padding(
                padding: const EdgeInsets.all(4),
                child: AddressCard(
                  key: Key("addressCardDesktop_key_${ids[index]}"),
                  walletId: widget.walletId,
                  addressId: ids[index],
                  coin: coin,
                  onPressed: () {
                    ref.read(desktopSelectedAddressId.state).state = ids[index];
                  },
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}
