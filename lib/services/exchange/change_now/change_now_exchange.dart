/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:decimal/decimal.dart';
import 'package:uuid/uuid.dart';

import '../../../models/exchange/response_objects/estimate.dart';
import '../../../models/exchange/response_objects/range.dart';
import '../../../models/exchange/response_objects/trade.dart';
import '../../../models/isar/exchange_cache/currency.dart';
import '../../../models/isar/exchange_cache/pair.dart';
import '../exchange.dart';
import '../exchange_response.dart';
import 'change_now_api.dart';

class ChangeNowExchange extends Exchange {
  ChangeNowExchange._();

  static ChangeNowExchange? _instance;
  static ChangeNowExchange get instance => _instance ??= ChangeNowExchange._();

  static const exchangeName = "ChangeNOW";

  @override
  String get name => exchangeName;

  @override
  Future<ExchangeResponse<Trade>> createTrade({
    required String from,
    required String to,
    String? fromNetwork,
    String? toNetwork,
    required bool fixedRate,
    required Decimal amount,
    required String addressTo,
    String? extraId,
    required String addressRefund,
    required String refundExtraId,
    Estimate? estimate,
    required bool reversed,
  }) async {
    final response = await ChangeNowAPI.instance.createExchangeTransaction(
      fromCurrency: from,
      fromNetwork: fromNetwork ?? "",
      toCurrency: to,
      toNetwork: toNetwork ?? "",
      address: addressTo,
      rateId: estimate?.rateId,
      refundAddress: addressRefund,
      refundExtraId: refundExtraId,
      fromAmount: reversed ? null : amount,
      toAmount: reversed ? amount : null,
      flow: fixedRate ? CNFlow.fixedRate : CNFlow.standard,
      type: reversed ? CNExchangeType.reverse : CNExchangeType.direct,
    );

    if (response.exception != null) {
      return ExchangeResponse(exception: response.exception);
    }

    final statusResponse = await ChangeNowAPI.instance.getTransactionStatus(
      id: response.value!.id,
    );
    if (statusResponse.exception != null) {
      return ExchangeResponse(exception: statusResponse.exception);
    }

    return ExchangeResponse(
      value: Trade.fromCNExchangeTransaction(
        response.value!.copyWithStatus(statusResponse.value!),
        reversed,
      ),
    );
  }

  @override
  Future<ExchangeResponse<List<Currency>>> getAllCurrencies(
    bool fixedRate,
  ) async {
    return await ChangeNowAPI.instance.getAvailableCurrencies();
  }
  //
  // @override
  // Future<ExchangeResponse<List<Currency>>> getPairedCurrencies(
  //   String forCurrency,
  //   bool fixedRate,
  // ) async {
  //   return await ChangeNowAPI.instance.getPairedCurrencies(
  //     ticker: forCurrency,
  //     fixedRate: fixedRate,
  //   );
  // }
  //
  // @override
  // Future<ExchangeResponse<List<Pair>>> getAllPairs(bool fixedRate) async {
  //   if (fixedRate) {
  //     final markets =
  //         await ChangeNowAPI.instance.getAvailableFixedRateMarkets();
  //
  //     if (markets.value == null) {
  //       return ExchangeResponse(exception: markets.exception);
  //     }
  //
  //     final List<Pair> pairs = [];
  //     for (final market in markets.value!) {
  //       pairs.add(
  //         Pair(
  //           exchangeName: ChangeNowExchange.exchangeName,
  //           from: market.from,
  //           to: market.to,
  //           rateType: SupportedRateType.fixed,
  //         ),
  //       );
  //     }
  //     return ExchangeResponse(value: pairs);
  //   } else {
  //     return await ChangeNowAPI.instance.getAvailableFloatingRatePairs();
  //   }
  // }

  @override
  Future<ExchangeResponse<List<Estimate>>> getEstimates(
    String from,
    String? fromNetwork,
    String to,
    String? toNetwork,
    Decimal amount,
    bool fixedRate,
    bool reversed,
  ) async {
    final response = await ChangeNowAPI.instance.getEstimatedExchangeAmount(
      fromCurrency: from,
      fromNetwork: fromNetwork,
      toCurrency: to,
      toNetwork: toNetwork,
      flow: fixedRate ? CNFlow.fixedRate : CNFlow.standard,
      type: reversed ? CNExchangeType.reverse : CNExchangeType.direct,
      fromAmount: reversed ? null : amount,
      toAmount: reversed ? amount : null,

      useRateId: fixedRate ? true : null,
    );

    return ExchangeResponse(
      value: response.value == null ? null : [response.value!],
      exception: response.exception,
    );
  }

  @override
  Future<ExchangeResponse<Range>> getRange(
    String from,
    String? fromNetwork,
    String to,
    String? toNetwork,
    bool fixedRate,
  ) async {
    return await ChangeNowAPI.instance.getRange(
      fromCurrency: from,
      fromNetwork: fromNetwork,
      toCurrency: to,
      toNetwork: toNetwork,
      flow: fixedRate ? CNFlow.fixedRate : CNFlow.standard,
    );
  }

  @override
  Future<ExchangeResponse<List<Pair>>> getPairsFor(
    String currency,
    bool fixedRate,
  ) async {
    // TODO: implement getPairsFor
    throw UnimplementedError();
  }

  @override
  Future<ExchangeResponse<Trade>> getTrade(String tradeId) async {
    final response = await ChangeNowAPI.instance.getTransactionStatus(
      id: tradeId,
    );
    if (response.exception != null) {
      return ExchangeResponse(exception: response.exception);
    }
    final t = response.value!;
    final timestamp = DateTime.tryParse(t.createdAt) ?? DateTime.now();

    final trade = Trade(
      uuid: const Uuid().v1(),
      tradeId: tradeId,
      rateType: "",
      direction: "",
      timestamp: timestamp,
      updatedAt: DateTime.tryParse(t.updatedAt) ?? timestamp,
      payInCurrency: t.fromCurrency,
      payInAmount: t.expectedAmountFrom ?? "",
      payInAddress: t.payinAddress,
      payInNetwork: "",
      payInExtraId: t.payinExtraId ?? "",
      payInTxid: t.payinHash ?? "",
      payOutCurrency: t.toCurrency,
      payOutAmount: t.expectedAmountTo ?? "",
      payOutAddress: t.payoutAddress,
      payOutNetwork: "",
      payOutExtraId: t.payoutExtraId ?? "",
      payOutTxid: t.payoutHash ?? "",
      refundAddress: t.refundAddress ?? "",
      refundExtraId: t.refundExtraId ?? "",
      status: t.status.name,
      exchangeName: ChangeNowExchange.exchangeName,
    );

    return ExchangeResponse(value: trade);
  }

  @override
  Future<ExchangeResponse<Trade>> updateTrade(Trade trade) async {
    final response = await ChangeNowAPI.instance.getTransactionStatus(
      id: trade.tradeId,
    );
    if (response.exception != null) {
      return ExchangeResponse(exception: response.exception);
    }
    final t = response.value!;
    final timestamp = DateTime.tryParse(t.createdAt) ?? DateTime.now();

    final _trade = Trade(
      uuid: trade.uuid,
      tradeId: trade.tradeId,
      rateType: trade.rateType,
      direction: trade.direction,
      timestamp: timestamp,
      updatedAt: DateTime.tryParse(t.updatedAt) ?? timestamp,
      payInCurrency: t.fromCurrency,
      payInAmount: t.amountFrom ?? t.expectedAmountFrom ?? trade.payInAmount,
      payInAddress: t.payinAddress,
      payInNetwork: trade.payInNetwork,
      payInExtraId: t.payinExtraId ?? "",
      payInTxid: t.payinHash ?? "",
      payOutCurrency: t.toCurrency,
      payOutAmount: t.amountTo ?? t.expectedAmountTo ?? trade.payOutAmount,
      payOutAddress: t.payoutAddress,
      payOutNetwork: trade.payOutNetwork,
      payOutExtraId: t.payoutExtraId ?? "",
      payOutTxid: t.payoutHash ?? "",
      refundAddress: t.refundAddress ?? "",
      refundExtraId: t.refundExtraId ?? "",
      status: t.status.name,
      exchangeName: ChangeNowExchange.exchangeName,
    );

    return ExchangeResponse(value: _trade);
  }

  @override
  Future<ExchangeResponse<List<Trade>>> getTrades() async {
    // TODO: implement getTrades
    throw UnimplementedError();
  }

  // ChangeNow does not support Tor.
  //
  // This code isn't required because the Exchange abstract class has a
  // default implementation that returns false.  This serves as an example and
  // reminder in case ChangeNow files are copied to create a new exchange (or
  // if ChangeNow ever supports Tor).
  /*
  @override
  bool get supportsTor => true;
  */
}
