/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import 'package:decimal/decimal.dart';
import 'package:flutter/foundation.dart';

import '../../../app_config.dart';
import '../../../exceptions/exchange/exchange_exception.dart';
import '../../../exceptions/exchange/pair_unavailable_exception.dart';
import '../../../external_api_keys.dart';
import '../../../models/exchange/change_now/cn_exchange_transaction.dart';
import '../../../models/exchange/change_now/cn_exchange_transaction_status.dart';
import '../../../models/exchange/change_now/estimated_exchange_amount.dart';
import '../../../models/exchange/response_objects/estimate.dart';
import '../../../models/exchange/response_objects/range.dart';
import '../../../models/isar/exchange_cache/currency.dart';
import '../../../models/isar/exchange_cache/pair.dart';
import '../../../networking/http.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/prefs.dart';
import '../../tor_service.dart';
import '../exchange_response.dart';
import 'change_now_exchange.dart';

enum CNFlow {
  standard("standard"),
  fixedRate("fixed-rate");

  const CNFlow(this.value);
  final String value;
}

enum CNExchangeType {
  direct("direct"),
  reverse("reverse");

  const CNExchangeType(this.value);
  final String value;
}

class ChangeNowAPI {
  static const String scheme = "https";
  static const String authority = "api.changenow.io";
  static const String apiVersionV2 = "/v2";

  final HTTP client;

  @visibleForTesting
  ChangeNowAPI({HTTP? http}) : client = http ?? HTTP();

  static final ChangeNowAPI _instance = ChangeNowAPI();
  static ChangeNowAPI get instance => _instance;

  Uri _buildUriV2(String path, Map<String, dynamic>? params) {
    return Uri.https(authority, apiVersionV2 + path, params);
  }

  Future<dynamic> _makeGetRequestV2(Uri uri, String apiKey) async {
    Logging.instance.t("ChangeNOW _makeGetRequestV2 to $uri");

    try {
      final response = await client.get(
        url: uri,
        headers: {
          "Content-Type": "application/json",
          "x-changenow-api-key": apiKey,
        },
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      final data = response.body;
      final parsed = jsonDecode(data);

      return parsed;
    } catch (e, s) {
      Logging.instance.e("_makeRequestV2($uri) threw", error: e, stackTrace: s);
      rethrow;
    }
  }

  Future<dynamic> _makePostRequestV2(
    Uri uri,
    Map<String, String> body,
    String apiKey,
  ) async {
    Logging.instance.t("ChangeNOW _makePostRequestV2 to $uri");
    try {
      final response = await client.post(
        url: uri,
        headers: {
          "Content-Type": "application/json",
          "x-changenow-api-key": apiKey,
        },
        body: jsonEncode(body),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      String? data;
      try {
        data = response.body;
        final parsed = jsonDecode(data);

        return parsed;
      } catch (e, s) {
        Logging.instance.e(
          "ChangeNOW api failed to parse: $data",
          error: e,
          stackTrace: s,
        );
        rethrow;
      }
    } catch (e, s) {
      Logging.instance.e(
        "_makePostRequestV2($uri) threw",
        error: e,
        stackTrace: s,
      );
      rethrow;
    }
  }

  /// Retrieves the list of available currencies from the API.
  ///
  /// - Set [active] to `true` to return only active currencies.
  /// - Set [buy] to `true` to return only currencies available for buying.
  /// - Set [sell] to `true` to return only currencies available for selling.
  /// - Set [flow] to specify the type of exchange flow.
  ///   Options are [CNFlow.standard] (default) or [CNFlow.fixedRate].
  Future<ExchangeResponse<List<Currency>>> getAvailableCurrencies({
    bool? active,
    bool? buy,
    bool? sell,
    CNFlow flow = CNFlow.standard,
    String? apiKey,
  }) async {
    final params = {
      "flow": flow.value,
      if (active != null) "active": active.toString(),
      if (buy != null) "buy": buy.toString(),
      if (sell != null) "sell": sell.toString(),
    };

    final uri = _buildUriV2("/exchange/currencies", params);

    try {
      // json array is expected here
      final jsonArray = await _makeGetRequestV2(
        uri,
        apiKey ?? kChangeNowApiKey,
      );

      try {
        final result = await compute(_parseAvailableCurrenciesJson, (
          jsonList: jsonArray as List<dynamic>,
          fixedRateFlow: flow == CNFlow.fixedRate,
        ));
        return result;
      } catch (e, s) {
        Logging.instance.e(
          "getAvailableCurrencies exception: ",
          error: e,
          stackTrace: s,
        );
        return ExchangeResponse(
          exception: ExchangeException(
            "Error: $jsonArray",
            ExchangeExceptionType.serializeResponseError,
          ),
        );
      }
    } catch (e, s) {
      Logging.instance.e(
        "getAvailableCurrencies exception: ",
        error: e,
        stackTrace: s,
      );
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  ExchangeResponse<List<Currency>> _parseAvailableCurrenciesJson(
    ({List<dynamic> jsonList, bool fixedRateFlow}) args,
  ) {
    try {
      final List<Currency> currencies = [];

      for (final json in args.jsonList) {
        try {
          final map = Map<String, dynamic>.from(json as Map);
          currencies.add(
            Currency.fromJson(
              map,
              rateType: (map["supportsFixedRate"] as bool)
                  ? SupportedRateType.both
                  : SupportedRateType.estimated,
              exchangeName: ChangeNowExchange.exchangeName,
            ),
          );
        } catch (_) {
          return ExchangeResponse(
            exception: ExchangeException(
              "Failed to serialize $json",
              ExchangeExceptionType.serializeResponseError,
            ),
          );
        }
      }

      return ExchangeResponse(value: currencies);
    } catch (_) {
      rethrow;
    }
  }

  /// Retrieves the minimum amount required to exchange [fromCurrency] to [toCurrency].
  ///
  /// If you attempt to exchange less than this amount, the transaction may fail.
  ///
  /// - [fromCurrency]: Ticker of the currency you want to exchange (e.g., "btc").
  /// - [toCurrency]: Ticker of the currency you want to receive (e.g., "usdt").
  /// - [fromNetwork]: (Optional) Network of the currency you want to exchange (e.g., "btc").
  /// - [toNetwork]: (Optional) Network of the currency you want to receive (e.g., "eth").
  /// - [flow]: (Optional) Exchange flow type. Defaults to [CNFlow.standard].
  /// - [apiKey]: (Optional) API key if required.
  Future<ExchangeResponse<Decimal>> getMinimalExchangeAmount({
    required String fromCurrency,
    required String toCurrency,
    String? fromNetwork,
    String? toNetwork,
    CNFlow flow = CNFlow.standard,
    String? apiKey,
  }) async {
    final params = {
      "fromCurrency": fromCurrency,
      "toCurrency": toCurrency,
      "flow": flow.value,
      if (fromNetwork != null) "fromNetwork": fromNetwork,
      if (toNetwork != null) "toNetwork": toNetwork,
    };

    final uri = _buildUriV2("/exchange/min-amount", params);

    try {
      // simple json object is expected here
      final json = await _makeGetRequestV2(uri, apiKey ?? kChangeNowApiKey);

      try {
        final value = Decimal.parse(json["minAmount"].toString());
        return ExchangeResponse(value: value);
      } catch (_) {
        return ExchangeResponse(
          exception: ExchangeException(
            "Failed to serialize $json",
            ExchangeExceptionType.serializeResponseError,
          ),
        );
      }
    } catch (e, s) {
      Logging.instance.e(
        "getMinimalExchangeAmount exception: ",
        error: e,
        stackTrace: s,
      );
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  /// Retrieves the minimum and maximum exchangeable amounts for a given currency pair.
  ///
  /// Attempting to exchange less than the minimum or more than the maximum may result in a failed transaction.
  /// Every asset pair has a minimum exchange amount, and some also have a maximum.
  ///
  /// - [fromCurrency]: Ticker of the currency you want to exchange (e.g., "btc").
  /// - [toCurrency]: Ticker of the currency you want to receive (e.g., "eth").
  /// - [fromNetwork]: (Optional) Network of the currency you want to exchange (e.g., "btc").
  /// - [toNetwork]: (Optional) Network of the currency you want to receive (e.g., "eth").
  /// - [flow]: (Optional) Type of exchange flow. Defaults to [CNFlow.standard].
  /// - [apiKey]: (Optional) API key if required.
  Future<ExchangeResponse<Range>> getRange({
    required String fromCurrency,
    required String toCurrency,
    String? fromNetwork,
    String? toNetwork,
    CNFlow flow = CNFlow.standard,
    String? apiKey,
  }) async {
    final params = {
      "fromCurrency": fromCurrency,
      "toCurrency": toCurrency,
      "flow": flow.value,
      if (fromNetwork != null) "fromNetwork": fromNetwork,
      if (toNetwork != null) "toNetwork": toNetwork,
    };

    final uri = _buildUriV2("/exchange/range", params);

    try {
      final jsonObject = await _makeGetRequestV2(
        uri,
        apiKey ?? kChangeNowApiKey,
      );

      final json = Map<String, dynamic>.from(jsonObject as Map);
      return ExchangeResponse(
        value: Range(
          max: Decimal.tryParse(json["maxAmount"]?.toString() ?? ""),
          min: Decimal.tryParse(json["minAmount"]?.toString() ?? ""),
        ),
      );
    } catch (e, s) {
      Logging.instance.f("getRange exception: ", error: e, stackTrace: s);
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  /// Retrieves an estimated amount of [toCurrency] you would receive for a given input amount of [fromCurrency].
  ///
  /// - [fromCurrency]: Ticker of the currency you want to exchange (e.g., "btc").
  /// - [toCurrency]: Ticker of the currency you want to receive (e.g., "eth").
  /// - [fromAmount]: (Required if [type] is [CNExchangeType.direct]) Amount to exchange. Must be greater than 0.
  /// - [toAmount]: (Required if [type] is [CNExchangeType.reverse]) Desired amount to receive. Must be greater than 0.
  /// - [fromNetwork]: (Optional) Network of the currency you want to exchange (e.g., "btc").
  /// - [toNetwork]: (Optional) Network of the currency you want to receive (e.g., "eth").
  /// - [flow]: (Optional) Type of exchange flow. Defaults to [CNFlow.standard].
  /// - [type]: (Optional) Exchange direction. Either [CNExchangeType.direct] or [CNExchangeType.reverse]. Defaults to [CNExchangeType.direct].
  /// - [useRateId]: (Optional) For fixed-rate flow. When true, the response includes a [rateId] for locking the rate in the next request.
  /// - [isTopUp]: (Optional) If true, gets an estimate for a balance top-up (no withdrawal fee).
  /// - [apiKey]: (Optional) API key if required.
  Future<ExchangeResponse<Estimate>> getEstimatedExchangeAmount({
    required String fromCurrency,
    required String toCurrency,
    Decimal? fromAmount,
    Decimal? toAmount,
    String? fromNetwork,
    String? toNetwork,
    CNFlow flow = CNFlow.standard,
    CNExchangeType type = CNExchangeType.direct,
    bool? useRateId,
    bool? isTopUp,
    String? apiKey,
  }) async {
    final params = {
      "fromCurrency": fromCurrency,
      "toCurrency": toCurrency,
      if (fromAmount != null) "fromAmount": fromAmount.toString(),
      if (toAmount != null) "toAmount": toAmount.toString(),
      if (fromNetwork != null) "fromNetwork": fromNetwork,
      if (toNetwork != null) "toNetwork": toNetwork,
      "flow": flow.value,
      "type": type.value,
      if (useRateId != null) "useRateId": useRateId.toString(),
      if (isTopUp != null) "isTopUp": isTopUp.toString(),
    };

    final uri = _buildUriV2("/exchange/estimated-amount", params);

    try {
      // simple json object is expected here
      final json = await _makeGetRequestV2(uri, apiKey ?? kChangeNowApiKey);

      try {
        final map = Map<String, dynamic>.from(json as Map);

        if (map["error"] != null) {
          if (map["error"] == "pair_is_inactive") {
            return ExchangeResponse(
              exception: PairUnavailableException(
                map["message"] as String,
                ExchangeExceptionType.generic,
              ),
            );
          } else {
            return ExchangeResponse(
              exception: ExchangeException(
                map["message"] as String,
                ExchangeExceptionType.generic,
              ),
            );
          }
        }

        final value = EstimatedExchangeAmount.fromJson(map);
        final reversed = value.type == CNExchangeType.reverse;
        return ExchangeResponse(
          value: Estimate(
            estimatedAmount: reversed ? value.fromAmount : value.toAmount,
            fixedRate: value.flow == CNFlow.fixedRate,
            reversed: reversed,
            rateId: value.rateId,
            warningMessage: value.warningMessage,
            exchangeProvider: ChangeNowExchange.exchangeName,
          ),
        );
      } catch (e, s) {
        Logging.instance.f(json, error: e, stackTrace: s);
        return ExchangeResponse(
          exception: ExchangeException(
            "Failed to serialize $json",
            ExchangeExceptionType.serializeResponseError,
          ),
        );
      }
    } catch (e, s) {
      Logging.instance.e(
        "getEstimatedExchangeAmount exception: ",
        error: e,
        stackTrace: s,
      );
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  /// Creates a new exchange transaction.
  ///
  /// This method initializes a currency exchange by specifying the source and destination
  /// currencies, the exchange direction, recipient details, and optional metadata.
  ///
  /// If using a fixed-rate flow, you **must** provide a [rateId] obtained from a prior estimate
  /// to lock in the rate. If using a standard flow, [rateId] can be left null.
  ///
  /// Parameters:
  /// - [fromCurrency]: Ticker of the currency you want to exchange (e.g., "btc").
  /// - [fromNetwork]: Network of the currency you want to exchange (e.g., "btc").
  /// - [toCurrency]: Ticker of the currency you want to receive (e.g., "usdt").
  /// - [toNetwork]: Network of the currency you want to receive (e.g., "eth").
  /// - [fromAmount]: Amount of currency you want to exchange (used in "direct" flow).
  /// - [toAmount]: Amount of currency you want to receive (used in "reverse" flow).
  /// - [flow]: Type of exchange flow. Either [CNFlow.standard] or [CNFlow.fixedRate].
  /// - [type]: Direction of the exchange. Use [CNExchangeType.direct] to define the amount to send,
  ///   or [CNExchangeType.reverse] to define the amount to receive.
  /// - [address]: Wallet address that will receive the exchanged funds.
  /// - [extraId]: (Optional) Extra ID required by some currencies (e.g., memo, tag).
  /// - [refundAddress]: (Optional) Address used to refund funds in case of timeout or failure.
  /// - [refundExtraId]: (Optional) Extra ID for the refund address if required.
  /// - [userId]: (Optional) Internal user identifier for partners with special access.
  /// - [payload]: (Optional) Arbitrary string to store additional context for the transaction.
  /// - [contactEmail]: (Optional) Email address to contact the user in case of issues.
  /// - [rateId]: (Required for fixed-rate) The rate ID returned from the estimate step to freeze the exchange rate.
  /// - [apiKey]: (Optional) Your API key, if authentication is required.
  ///
  /// Returns a [Future] resolving to [ExchangeResponse] containing the created [ExchangeTransaction].
  Future<ExchangeResponse<CNExchangeTransaction>> createExchangeTransaction({
    required String fromCurrency,
    required String fromNetwork,
    required String toCurrency,
    required String toNetwork,
    Decimal? fromAmount,
    Decimal? toAmount,
    CNFlow flow = CNFlow.standard,
    CNExchangeType type = CNExchangeType.direct,
    required String address,
    String? extraId,
    String? refundAddress,
    String? refundExtraId,
    String? userId,
    String? payload,
    String? contactEmail,
    required String? rateId,
    String? apiKey,
  }) async {
    final Map<String, String> body = {
      "fromCurrency": fromCurrency,
      "fromNetwork": fromNetwork ?? "",
      "toCurrency": toCurrency,
      "toNetwork": toNetwork ?? "",
      "fromAmount": fromAmount?.toString() ?? "",
      "toAmount": toAmount?.toString() ?? "",
      "flow": flow.value,
      "type": type.value,
      "address": address,
      "extraId": extraId ?? "",
      "refundAddress": refundAddress ?? "",
      "refundExtraId": refundExtraId ?? "",
      "userId": userId ?? "",
      "payload": payload ?? "",
      "contactEmail": contactEmail ?? "",
      "rateId": rateId ?? "",
    };

    final uri = _buildUriV2("/exchange", null);

    try {
      // simple json object is expected here
      final json = await _makePostRequestV2(
        uri,
        body,
        apiKey ?? kChangeNowApiKey,
      );

      json["date"] = DateTime.now().toIso8601String();

      try {
        final value = CNExchangeTransaction.fromJson(
          Map<String, dynamic>.from(json as Map),
        );
        return ExchangeResponse(value: value);
      } catch (e, s) {
        if (json["error"] == "rate_id_not_found_or_expired") {
          return ExchangeResponse(
            exception: ExchangeException(
              "Rate ID not found or expired",
              ExchangeExceptionType.serializeResponseError,
            ),
          );
        }
        Logging.instance.f(json, error: e, stackTrace: s);
        return ExchangeResponse(
          exception: ExchangeException(
            "Failed to serialize $json",
            ExchangeExceptionType.serializeResponseError,
          ),
        );
      }
    } catch (e, s) {
      Logging.instance.e(
        "createFixedRateExchangeTransaction exception: ",
        error: e,
        stackTrace: s,
      );
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }

  Future<ExchangeResponse<CNExchangeTransactionStatus>> getTransactionStatus({
    required String id,
    String? apiKey,
  }) async {
    final uri = _buildUriV2("/exchange/by-id", {"id": id});

    try {
      // simple json object is expected here
      final json = await _makeGetRequestV2(uri, apiKey ?? kChangeNowApiKey);

      try {
        final value = CNExchangeTransactionStatus.fromMap(
          Map<String, dynamic>.from(json as Map),
        );
        return ExchangeResponse(value: value);
      } catch (e, s) {
        Logging.instance.f(json, error: e, stackTrace: s);
        return ExchangeResponse(
          exception: ExchangeException(
            "Failed to serialize $json",
            ExchangeExceptionType.serializeResponseError,
          ),
        );
      }
    } catch (e, s) {
      Logging.instance.e(
        "getTransactionStatus exception: ",
        error: e,
        stackTrace: s,
      );
      return ExchangeResponse(
        exception: ExchangeException(
          e.toString(),
          ExchangeExceptionType.generic,
        ),
      );
    }
  }
}
