/*
 * This file is part of Stack Wallet.
 *
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import 'package:flutter/material.dart';

import '../app_config.dart';
import '../db/hive/db.dart';
import '../utilities/logger.dart';

@Deprecated("Legacy support only. Do not use.")
class WalletInfo {
  final String coinIdentifier;
  final String walletId;
  final String name;

  @Deprecated("Legacy support only. Do not use.")
  const WalletInfo({
    required this.coinIdentifier,
    required this.walletId,
    required this.name,
  });

  @Deprecated("Legacy support only. Do not use.")
  factory WalletInfo.fromJson(Map<String, dynamic> jsonObject) {
    return WalletInfo(
      coinIdentifier: jsonObject["coin"] as String,
      walletId: jsonObject["id"] as String,
      name: jsonObject["name"] as String,
    );
  }

  @Deprecated("Legacy support only. Do not use.")
  Map<String, String> toMap() {
    return {
      "name": name,
      "id": walletId,
      "coin": coinIdentifier,
    };
  }

  @Deprecated("Legacy support only. Do not use.")
  String toJsonString() {
    return jsonEncode(toMap());
  }

  @override
  @Deprecated("Legacy support only. Do not use.")
  String toString() {
    return "WalletInfo: ${toJsonString()}";
  }
}

@Deprecated("Legacy support only. Do not use.")
class WalletsService extends ChangeNotifier {
  @Deprecated("Legacy support only. Do not use.")
  Future<Map<String, WalletInfo>>? _walletNames;
  @Deprecated("Legacy support only. Do not use.")
  Future<Map<String, WalletInfo>> get walletNames =>
      _walletNames ??= _fetchWalletNames();

  @Deprecated("Legacy support only. Do not use.")
  WalletsService();

  @Deprecated("Legacy support only. Do not use.")
  Future<Map<String, WalletInfo>> _fetchWalletNames() async {
    final names = DB.instance
        .get<dynamic>(boxName: DB.boxNameAllWalletsData, key: 'names') as Map?;
    if (names == null) {
      Logging.instance.logd(
        "Fetched wallet 'names' returned null. Setting initializing 'names'",
        level: LogLevel.Info,
      );
      await DB.instance.put<dynamic>(
        boxName: DB.boxNameAllWalletsData,
        key: 'names',
        value: <String, dynamic>{},
      );
      return {};
    }
    Logging.instance.logd("Fetched wallet names: $names", level: LogLevel.Info);
    final mapped = Map<String, dynamic>.from(names);
    mapped.removeWhere((name, dyn) {
      final jsonObject = Map<String, dynamic>.from(dyn as Map);
      try {
        AppConfig.getCryptoCurrencyFor(jsonObject["coin"] as String);
        return false;
      } catch (e, s) {
        Logging.instance.logd(
          "Error, ${jsonObject["coin"]} does not exist",
          level: LogLevel.Error,
        );
        return true;
      }
    });

    return mapped.map(
      (name, dyn) => MapEntry(
        name,
        WalletInfo.fromJson(Map<String, dynamic>.from(dyn as Map)),
      ),
    );
  }
}
