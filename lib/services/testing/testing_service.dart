/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-08-14
 *
 */

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';

import '../../utilities/logger.dart';
import 'testing_models.dart';
import 'test_suite_interface.dart';
import 'test_suites/tor_test_suite.dart';
import 'test_suites/monero_wallet_test_suite.dart';

final testingServiceProvider = StateNotifierProvider<TestingService, TestingSessionState>((ref) {
  return TestingService();
});

class TestingService extends StateNotifier<TestingSessionState> {
  TestingService() : super(TestingSessionState(
    suiteStatuses: {
      for (var type in TestSuiteType.values) type: TestSuiteStatus.waiting
    },
    isRunning: false,
    completed: 0,
    total: TestSuiteType.values.length,
  ));

  final Map<TestSuiteType, TestSuiteInterface> _testSuites = {};
  final StreamController<TestingSessionState> _statusController = StreamController<TestingSessionState>.broadcast();
  bool _cancelled = false;

  Stream<TestingSessionState> get statusStream => _statusController.stream;

  void _initializeTestSuites() {
    _testSuites[TestSuiteType.tor] = TorTestSuite();
    _testSuites[TestSuiteType.moneroWallet] = MoneroWalletTestSuite();
  }

  Future<void> runAllTests() async {
    if (state.isRunning) return;
    
    _cancelled = false;
    _initializeTestSuites();
    
    state = state.copyWith(
      isRunning: true,
      completed: 0,
      suiteStatuses: {
        for (var type in TestSuiteType.values) type: TestSuiteStatus.waiting
      },
    );
    _statusController.add(state);

    try {
      for (final type in TestSuiteType.values) {
        if (_cancelled) break;

        await runTestSuite(type);
      }
    } catch (e) {
      Logging.instance.log(Level.error, "Error running test suites: $e");
    } finally {
      state = state.copyWith(isRunning: false);
      _statusController.add(state);
    }
  }

  Future<void> runTestSuite(TestSuiteType type) async {
    if (_cancelled) return;

    final suite = _testSuites[type];
    if (suite == null) return;

    final updatedStatuses = Map<TestSuiteType, TestSuiteStatus>.from(state.suiteStatuses);
    updatedStatuses[type] = TestSuiteStatus.running;
    
    state = state.copyWith(suiteStatuses: updatedStatuses);
    _statusController.add(state);

    try {
      final result = await suite.runTests().timeout(
        const Duration(seconds: 30),
        onTimeout: () => const TestResult(
          success: false,
          message: "Test suite timed out",
          executionTime: Duration(seconds: 30),
        ),
      );

      if (_cancelled) return;

      updatedStatuses[type] = result.success ? TestSuiteStatus.passed : TestSuiteStatus.failed;
      
      final completed = updatedStatuses.values
          .where((status) => status == TestSuiteStatus.passed || status == TestSuiteStatus.failed)
          .length;

      state = state.copyWith(
        suiteStatuses: updatedStatuses,
        completed: completed,
      );
      _statusController.add(state);

      await suite.cleanup();
    } catch (e) {
      if (_cancelled) return;

      updatedStatuses[type] = TestSuiteStatus.failed;
      
      final completed = updatedStatuses.values
          .where((status) => status == TestSuiteStatus.passed || status == TestSuiteStatus.failed)
          .length;

      state = state.copyWith(
        suiteStatuses: updatedStatuses,
        completed: completed,
      );
      _statusController.add(state);

      Logging.instance.log(Level.error, "Error running $type test suite: $e");
    }
  }

  Future<void> cancelTesting() async {
    _cancelled = true;
    state = state.copyWith(isRunning: false);
    _statusController.add(state);
    
    for (final suite in _testSuites.values) {
      await suite.cleanup();
    }
  }

  Future<void> resetTestResults() async {
    state = TestingSessionState(
      suiteStatuses: {
        for (var type in TestSuiteType.values) type: TestSuiteStatus.waiting
      },
      isRunning: false,
      completed: 0,
      total: TestSuiteType.values.length,
    );
    _statusController.add(state);
  }

  TestSuiteInterface? getTestSuite(TestSuiteType type) {
    return _testSuites[type];
  }

  String getDisplayNameForTestSuite(TestSuiteType type) {
    switch (type) {
      case TestSuiteType.tor:
        return "Tor Service";
      case TestSuiteType.moneroWallet:
        return "Monero Wallet FFI";
    }
  }

  @override
  void dispose() {
    _statusController.close();
    super.dispose();
  }
}