/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-08-14
 *
 */

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'package:compat/old_cw_core/path_for_wallet.dart' as lib_monero_compat;
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import 'package:cs_monero/cs_monero.dart' as lib_monero;
import 'package:tuple/tuple.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/stack_file_system.dart';
import '../../../pages/settings_views/global_settings_view/stack_backup_views/helpers/restore_create_backup.dart';
import '../test_suite_interface.dart';
import '../testing_models.dart';
import 'test_data/polyseed_vectors.dart';

class MoneroWalletTestSuite implements TestSuiteInterface {
  final StreamController<TestSuiteStatus> _statusController = 
      StreamController<TestSuiteStatus>.broadcast();
  TestSuiteStatus _status = TestSuiteStatus.waiting;

  @override
  String get displayName => "Monero Wallet FFI";

  @override
  Widget get icon => const Icon(Icons.account_balance_wallet, size: 32);

  @override
  TestSuiteStatus get status => _status;

  @override
  Stream<TestSuiteStatus> get statusStream => _statusController.stream;

  @override
  Future<TestResult> runTests() async {
    final stopwatch = Stopwatch()..start();
    
    try {
      _updateStatus(TestSuiteStatus.running);
      
      Logging.instance.log(Level.info, "Starting Monero wallet test suite...");

      await _testMnemonicGeneration();

      await _testStackWalletBackupRoundTrip();

      // TODO: FIXME.
      // await _testPolyseedRestoration();
      
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.passed);
      
      return TestResult(
        success: true,
        message: "üëçüëç All Monero wallet FFI tests passed successfully",
        executionTime: stopwatch.elapsed,
      );
      
    } catch (e, stackTrace) {
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.failed);
      
      Logging.instance.log(Level.error, 
        "Monero wallet test suite failed: $e\n$stackTrace"
      );
      
      return TestResult(
        success: false,
        message: "Monero wallet FFI tests failed: $e",
        executionTime: stopwatch.elapsed,
      );
    }
  }

  Future<void> _testMnemonicGeneration() async {
    Logging.instance.log(Level.info, "Testing mnemonic generation and wallet creation...");
    
    final tempDir = await StackFileSystem.applicationRootDirectory();
    final walletName = "test_wallet_${Random().nextInt(10000)}";
    final walletPath = "${tempDir.path}/$walletName";
    const walletPassword = "1";
    
    try {
      // Test 16-word mnemonic generation.
      await _testWalletCreation(
        walletPath: "${walletPath}_16", 
        password: walletPassword,
        seedType: lib_monero.MoneroSeedType.sixteen,
        expectedWordCount: 16,
      );
      
      // Test 25-word mnemonic generation.
      await _testWalletCreation(
        walletPath: "${walletPath}_25",
        password: walletPassword,
        seedType: lib_monero.MoneroSeedType.twentyFive,
        expectedWordCount: 25,
      );
      
      Logging.instance.log(Level.info, "üëç Mnemonic generation tests passed");
      
    } finally {
      // Cleanup test wallet files
      await _cleanupTestWallets([
        "${walletPath}_16",
        "${walletPath}_25",
      ]);
    }
  }

  /// Tests wallet creation with different seed types.
  ///
  /// Attempts to ensure validity of the Monero FFI integration.
  Future<void> _testWalletCreation({
    required String walletPath,
    required String password,
    required lib_monero.MoneroSeedType seedType,
    required int expectedWordCount,
  }) async {
    lib_monero.Wallet? wallet;
    
    try {
      // Create new wallet with specified seed type.
      wallet = await lib_monero.MoneroWallet.create(
        path: walletPath,
        password: password,
        seedType: seedType,
        seedOffset: "",
      );
      
      // Validate mnemonic word count
      final mnemonic = await wallet.getSeed();
      final words = mnemonic.split(' ');
      
      if (words.length != expectedWordCount) {
        throw Exception(
          "Expected $expectedWordCount words, got ${words.length}: $mnemonic"
        );
      }
      
      // Validate wallet address generation.
      final address = await wallet.getAddress();
      if (address.value.isEmpty) {
        throw Exception("Generated wallet has empty address");
      }
      
      // Validate key derivation
      final secretSpendKey = wallet.getPrivateSpendKey();
      final secretViewKey = wallet.getPrivateViewKey();
      
      if (secretSpendKey.isEmpty || secretViewKey.isEmpty) {
        throw Exception("Generated wallet has empty keys");
      }
      
      Logging.instance.log(Level.info, 
        "Successfully created $expectedWordCount-word wallet: $address"
      );
      
    } finally {
      await wallet?.close();
    }
  }

  /// Tests restoration of a wallet from a polyseed vector.
  ///
  /// Attempts to ensure soundness of the Monero FFI integration.
  Future<void> _testPolyseedRestoration() async {
    Logging.instance.log(Level.info, "Testing polyseed vector restoration...");

    final walletName = "polyseed_restore_${Random().nextInt(10000)}";
    const walletPassword = "1";

    final Directory root = await StackFileSystem.applicationRootDirectory();
    final walletPath = await lib_monero_compat.pathForWalletDir(
      name: walletName,
      type: "monero",
      appRoot: root,
    );
    
    lib_monero.Wallet? wallet;
    
    try {
      const testVector = MoneroTestVectors.polyseedVector;
      
      // Restore wallet from polyseed mnemonic.
      wallet = await lib_monero.MoneroWallet.restoreWalletFromSeed(
        path: walletPath,
        password: walletPassword,
        seed: testVector.mnemonic,
        restoreHeight: 0, // Polyseed vectors don't require a restore height.
        seedOffset: "",
      );
      
      // Validate restored mnemonic matches vector.
      final restoredMnemonic = wallet.getSeed();
      if (restoredMnemonic != testVector.mnemonic) {
        throw Exception(
          "Restored mnemonic doesn't match: expected '${testVector.mnemonic}', got '$restoredMnemonic'"
        );
      }

      final address = wallet.getAddress().value;
      if (address != testVector.expectedMainAddress.toString()) {
        throw Exception(
          "Address mismatch: expected '${testVector.expectedMainAddress}', got '$address'"
        );
      }

      final secretSpendKey = wallet.getPrivateSpendKey();
      if (secretSpendKey != testVector.expectedSecretSpendKey) {
        throw Exception(
          "Secret spend key mismatch: expected '${testVector.expectedSecretSpendKey}', got '$secretSpendKey'"
        );
      }

      final secretViewKey = wallet.getPrivateViewKey();
      if (secretViewKey != testVector.expectedSecretViewKey) {
        throw Exception(
          "Secret view key mismatch: expected '${testVector.expectedSecretViewKey}', got '$secretViewKey'"
        );
      }

      final publicSpendKey = wallet.getPublicSpendKey();
      if (publicSpendKey != testVector.expectedPublicSpendKey) {
        throw Exception(
          "Public spend key mismatch: expected '${testVector.expectedPublicSpendKey}', got '$publicSpendKey'"
        );
      }
      
      final publicViewKey = wallet.getPublicViewKey();
      if (publicViewKey != testVector.expectedPublicViewKey) {
        throw Exception(
          "Public view key mismatch: expected '${testVector.expectedPublicViewKey}', got '$publicViewKey'"
        );
      }
      
      Logging.instance.log(Level.info, "üëç Polyseed restoration test passed successfully");
      
    } finally {
      await wallet?.close();
      await _cleanupTestWallets([walletPath]);
    }
  }

  /// Cleans up test wallet files and dir created during the tests.
  Future<void> _cleanupTestWallets(List<String> walletPaths) async {
    for (final walletPath in walletPaths) {
      try {
        final walletFile = File(walletPath);
        final keysFile = File("$walletPath.keys");
        final addressFile = File("$walletPath.address.txt");
        
        if (await walletFile.exists()) {
          await walletFile.delete();
        }
        if (await keysFile.exists()) {
          await keysFile.delete();
        }
        if (await addressFile.exists()) {
          await addressFile.delete();
        }

        // Clean the directory if it's empty.
        final dir = Directory(walletPath);
        if (await dir.exists() && (await dir.list().isEmpty)) {
          await dir.delete();
        }
        
        Logging.instance.log(Level.info, "Cleaned up test wallet: $walletPath");
      } catch (e) {
        Logging.instance.log(Level.warning, "Failed to cleanup wallet $walletPath: $e");
      }
    }
  }

  /// Tests Stack Wallet Backup round-trip functionality.
  ///
  /// Creates Monero wallets with both 16-word and 25-word mnemonics, saves the mnemonics,
  /// creates backups, restores the backups, and verifies the restored mnemonics match the originals.
  Future<void> _testStackWalletBackupRoundTrip() async {
    Logging.instance.log(Level.info, "Testing Stack Wallet Backup round-trip for Monero...");

    final tempDir = await StackFileSystem.applicationRootDirectory();
    final testId = Random().nextInt(10000);

    try {
      // Test 16-word mnemonic backup.
      await _testBackupWithSeedType(
        tempDir: tempDir,
        testId: testId,
        seedType: lib_monero.MoneroSeedType.sixteen,
        expectedWordCount: 16,
        suffix: "16",
      );

      // Test 25-word mnemonic backup.
      await _testBackupWithSeedType(
        tempDir: tempDir,
        testId: testId,
        seedType: lib_monero.MoneroSeedType.twentyFive,
        expectedWordCount: 25,
        suffix: "25",
      );

      Logging.instance.log(Level.info, "‚úì All Stack Wallet Backup round-trip tests passed successfully!");
    } catch (e) {
      Logging.instance.log(Level.error, "Stack Wallet Backup round-trip test failed: $e");
      rethrow;
    }
  }

  /// Tests Stack Wallet Backup round-trip functionality for a specific seed type.
  Future<void> _testBackupWithSeedType({
    required Directory tempDir,
    required int testId,
    required lib_monero.MoneroSeedType seedType,
    required int expectedWordCount,
    required String suffix,
  }) async {
    Logging.instance.log(Level.info, "Testing ${expectedWordCount}-word mnemonic backup...");

    final walletName = "test_monero_backup_${testId}_$suffix";
    final walletPath = "${tempDir.path}/$walletName";
    final backupPath = "${tempDir.path}/${walletName}_backup.swb";
    const walletPassword = "testpass123";
    const backupPassword = "backuppass456";

    lib_monero.Wallet? originalWallet;
    String? originalMnemonic;

    try {
      // Step 1: Create a new Monero wallet using lib_monero directly.
      Logging.instance.log(Level.info, "Step 1: Creating new ${expectedWordCount}-word Monero wallet...");

      originalWallet = await lib_monero.MoneroWallet.create(
        path: walletPath,
        password: walletPassword,
        seedType: seedType,
        seedOffset: "",
      );

      // Step 2: Save the original mnemonic out-of-band.
      Logging.instance.log(Level.info, "Step 2: Saving original mnemonic...");
      originalMnemonic = await originalWallet.getSeed();

      if (originalMnemonic.isEmpty) {
        throw Exception("Failed to retrieve mnemonic from created wallet");
      }

      final originalWords = originalMnemonic.split(' ');
      Logging.instance.log(Level.info, "Original mnemonic has ${originalWords.length} words");

      // Validate the mnemonic format.
      if (originalWords.length != expectedWordCount) {
        throw Exception("Expected ${expectedWordCount}-word mnemonic, got ${originalWords.length} words");
      }

      // Step 3: Create a Stack Wallet Backup.
      Logging.instance.log(Level.info, "Step 3: Creating Stack Wallet Backup...");

      // Create a minimal backup JSON with just our test wallet.
      final backupJson = {
        "wallets": [
          {
            "name": walletName,
            "id": "test_wallet_${testId}_$suffix",
            "mnemonic": originalMnemonic,
            "mnemonicPassphrase": "",
            "coinName": "monero",
            "storedChainHeight": 0,
            "restoreHeight": 0,
            "notes": {},
            "isFavorite": false,
            "otherDataJsonString": null,
          }
        ],
        "prefs": {
          "currency": "USD",
          "useBiometrics": false,
          "hasPin": false,
          "language": "en",
          "showFavoriteWallets": true,
          "wifiOnly": false,
          "syncType": "allWalletsOnStartup",
          "walletIdsSyncOnStartup": [],
          "showTestNetCoins": false,
          "isAutoBackupEnabled": false,
          "autoBackupLocation": null,
          "backupFrequencyType": "BackupFrequencyType.everyAppStart",
          "lastAutoBackup": DateTime.now().toString(),
        },
        "nodes": [],
        "addressBookEntries": [],
        "tradeHistory": [],
        "tradeTxidLookupData": [],
        "tradeNotes": {},
      };

      final jsonString = jsonEncode(backupJson);

      // Encrypt and save the backup.
      final success = await SWB.encryptStackWalletWithPassphrase(
        backupPath,
        backupPassword,
        jsonString,
      );

      if (!success) {
        throw Exception("Failed to create Stack Wallet Backup");
      }

      Logging.instance.log(Level.info, "Backup created successfully at: $backupPath");

      // Step 4: Restore the Stack Wallet Backup.
      Logging.instance.log(Level.info, "Step 4: Restoring Stack Wallet Backup...");

      final restoredJsonString = await SWB.decryptStackWalletWithPassphrase(
        Tuple2(backupPath, backupPassword),
      );

      if (restoredJsonString == null) {
        throw Exception("Failed to decrypt Stack Wallet Backup");
      }

      final restoredJson = jsonDecode(restoredJsonString) as Map<String, dynamic>;
      final restoredWallets = restoredJson["wallets"] as List<dynamic>;

      if (restoredWallets.isEmpty) {
        throw Exception("No wallets found in restored backup");
      }

      final restoredWalletData = restoredWallets.first as Map<String, dynamic>;
      final restoredMnemonic = restoredWalletData["mnemonic"] as String;

      // Step 5: Verify that the restored mnemonic matches the original.
      Logging.instance.log(Level.info, "Step 5: Verifying mnemonic integrity...");

      if (restoredMnemonic != originalMnemonic) {
        throw Exception(
          "Mnemonic mismatch!\n"
          "Original:  $originalMnemonic\n"
          "Restored:  $restoredMnemonic"
        );
      }

      // Additional verification: check word count.
      final restoredWords = restoredMnemonic.split(' ');

      if (originalWords.length != restoredWords.length) {
        throw Exception(
          "Word count mismatch: original ${originalWords.length}, restored ${restoredWords.length}"
        );
      }

      // Verify each word matches.
      for (int i = 0; i < originalWords.length; i++) {
        if (originalWords[i] != restoredWords[i]) {
          throw Exception(
            "Word mismatch at position $i: '${originalWords[i]}' != '${restoredWords[i]}'"
          );
        }
      }

      // Step 6: Additional test - verify we can recreate the wallet from the restored mnemonic.
      Logging.instance.log(Level.info, "Step 6: Testing wallet restoration with recovered mnemonic...");

      final testWalletPath = "${tempDir.path}/test_restore_${testId}_$suffix";
      lib_monero.Wallet? restoredWallet;

      try {
        restoredWallet = await lib_monero.MoneroWallet.restoreWalletFromSeed(
          path: testWalletPath,
          password: walletPassword,
          seed: restoredMnemonic,
          restoreHeight: 0,
          seedOffset: "",
        );

        final restoredMnemonicFromWallet = await restoredWallet.getSeed();

        if (restoredMnemonicFromWallet != originalMnemonic) {
          throw Exception(
            "Restored wallet mnemonic doesn't match original!\n"
            "Original: $originalMnemonic\n"
            "From restored wallet: $restoredMnemonicFromWallet"
          );
        }

        Logging.instance.log(Level.info, "‚úì Successfully restored ${expectedWordCount}-word wallet from backup mnemonic");

      } finally {
        await restoredWallet?.close();
        // Clean up restored wallet files.
        final testWalletFile = File(testWalletPath);
        final testKeysFile = File("$testWalletPath.keys");
        final testAddressFile = File("$testWalletPath.address.txt");

        if (await testWalletFile.exists()) await testWalletFile.delete();
        if (await testKeysFile.exists()) await testKeysFile.delete();
        if (await testAddressFile.exists()) await testAddressFile.delete();
      }

      Logging.instance.log(Level.info, "‚úì ${expectedWordCount}-word Stack Wallet Backup round-trip test passed!");
      Logging.instance.log(Level.info, "‚úì Original and restored mnemonics match perfectly");
      Logging.instance.log(Level.info, "‚úì Verified ${originalWords.length}-word mnemonic integrity");
      Logging.instance.log(Level.info, "‚úì Confirmed ${expectedWordCount}-word wallet can be restored from backup mnemonic");

    } finally {
      // Cleanup.
      try {
        await originalWallet?.close();

        // Clean up test files.
        final walletFile = File(walletPath);
        final keysFile = File("$walletPath.keys");
        final addressFile = File("$walletPath.address.txt");
        final backupFile = File(backupPath);

        if (await walletFile.exists()) await walletFile.delete();
        if (await keysFile.exists()) await keysFile.delete();
        if (await addressFile.exists()) await addressFile.delete();
        if (await backupFile.exists()) await backupFile.delete();

        Logging.instance.log(Level.info, "Cleaned up test files for ${expectedWordCount}-word Monero backup test");
      } catch (e) {
        Logging.instance.log(Level.warning, "Cleanup error for ${expectedWordCount}-word test: $e");
      }
    }
  }

  void _updateStatus(TestSuiteStatus newStatus) {
    _status = newStatus;
    _statusController.add(newStatus);
  }

  @override
  Future<void> cleanup() async {
    await _statusController.close();
  }
}