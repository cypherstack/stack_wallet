/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-08-14
 *
 */

import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import 'package:cs_salvium/cs_salvium.dart' as lib_salvium;
import '../../../utilities/logger.dart';
import '../../../utilities/stack_file_system.dart';
import '../test_suite_interface.dart';
import '../testing_models.dart';

class SalviumIntegrationTestSuite implements TestSuiteInterface {
  final StreamController<TestSuiteStatus> _statusController = 
      StreamController<TestSuiteStatus>.broadcast();
  TestSuiteStatus _status = TestSuiteStatus.waiting;

  @override
  String get displayName => "Salvium Integration";

  @override
  Widget get icon => const Icon(Icons.currency_exchange, size: 32);

  @override
  TestSuiteStatus get status => _status;

  @override
  Stream<TestSuiteStatus> get statusStream => _statusController.stream;

  @override
  Future<TestResult> runTests() async {
    final stopwatch = Stopwatch()..start();
    
    try {
      _updateStatus(TestSuiteStatus.running);
      
      Logging.instance.log(Level.info, "Starting Salvium integration test suite...");

      await _testSalviumMnemonicGeneration();
      
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.passed);
      
      return TestResult(
        success: true,
        message: "üëçüëç All Salvium integration tests passed successfully",
        executionTime: stopwatch.elapsed,
      );
      
    } catch (e, stackTrace) {
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.failed);
      
      Logging.instance.log(Level.error, 
        "Salvium integration test suite failed: $e\n$stackTrace"
      );
      
      return TestResult(
        success: false,
        message: "Salvium integration tests failed: $e",
        executionTime: stopwatch.elapsed,
      );
    }
  }

  Future<void> _testSalviumMnemonicGeneration() async {
    Logging.instance.log(Level.info, "Testing Salvium mnemonic generation and wallet creation...");
    
    final tempDir = await StackFileSystem.applicationRootDirectory();
    final walletName = "test_salvium_wallet_${Random().nextInt(10000)}";
    final walletPath = "${tempDir.path}/$walletName";
    const walletPassword = "1";
    
    try {
      // Test 25-word mnemonic generation for Salvium.
      await _testSalviumWalletCreation(
        walletPath: "${walletPath}_25",
        password: walletPassword,
        seedType: lib_salvium.SalviumSeedType.twentyFive,
        expectedWordCount: 25,
      );
      
      Logging.instance.log(Level.info, "üëç Salvium mnemonic generation tests passed");
      
    } finally {
      // Cleanup test wallet files.
      await _cleanupTestWallets([
        "${walletPath}_25",
      ]);
    }
  }

  /// Tests Salvium wallet creation with different seed types.
  ///
  /// Attempts to ensure validity of the Salvium FFI integration.
  Future<void> _testSalviumWalletCreation({
    required String walletPath,
    required String password,
    required lib_salvium.SalviumSeedType seedType,
    required int expectedWordCount,
  }) async {
    lib_salvium.Wallet? wallet;
    
    try {
      // Create new Salvium wallet with specified seed type.
      wallet = await lib_salvium.SalviumWallet.create(
        path: walletPath,
        password: password,
        seedType: seedType,
        seedOffset: "",
      );
      
      // Validate mnemonic word count.
      final mnemonic = wallet.getSeed();
      final words = mnemonic.split(' ');
      
      if (words.length != expectedWordCount) {
        throw Exception(
          "Expected $expectedWordCount words, got ${words.length}: $mnemonic"
        );
      }
      
      // Validate wallet address generation.
      final address = wallet.getAddress();
      if (address.value.isEmpty) {
        throw Exception("Generated Salvium wallet has empty address");
      }
      
      // Validate that this is a Salvium address (starts with 'S' for mainnet).
      if (!address.value.startsWith('S')) {
        throw Exception("Generated address does not appear to be a valid Salvium address: ${address.value}");
      }
      
      // Validate key derivation.
      final secretSpendKey = wallet.getPrivateSpendKey();
      final secretViewKey = wallet.getPrivateViewKey();
      
      if (secretSpendKey.isEmpty || secretViewKey.isEmpty) {
        throw Exception("Generated Salvium wallet has empty keys");
      }
      
      Logging.instance.log(Level.info, 
        "Successfully created $expectedWordCount-word Salvium wallet: $address"
      );
      
    } finally {
      await wallet?.close();
    }
  }

  /// Cleans up test wallet files and dir created during the tests.
  Future<void> _cleanupTestWallets(List<String> walletPaths) async {
    for (final walletPath in walletPaths) {
      try {
        final walletFile = File(walletPath);
        final keysFile = File("$walletPath.keys");
        final addressFile = File("$walletPath.address.txt");
        
        if (await walletFile.exists()) {
          await walletFile.delete();
        }
        if (await keysFile.exists()) {
          await keysFile.delete();
        }
        if (await addressFile.exists()) {
          await addressFile.delete();
        }

        // Clean the directory if it's empty.
        final dir = Directory(walletPath);
        if (await dir.exists() && (await dir.list().isEmpty)) {
          await dir.delete();
        }
        
        Logging.instance.log(Level.info, "Cleaned up test Salvium wallet: $walletPath");
      } catch (e) {
        Logging.instance.log(Level.warning, "Failed to cleanup Salvium wallet $walletPath: $e");
      }
    }
  }

  void _updateStatus(TestSuiteStatus newStatus) {
    _status = newStatus;
    _statusController.add(newStatus);
  }

  @override
  Future<void> cleanup() async {
    await _statusController.close();
  }
}