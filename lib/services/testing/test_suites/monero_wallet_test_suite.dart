/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-08-14
 *
 */

import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'package:compat/old_cw_core/path_for_wallet.dart' as lib_monero_compat;
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import 'package:cs_monero/cs_monero.dart' as lib_monero;
import '../../../utilities/logger.dart';
import '../../../utilities/stack_file_system.dart';
import '../test_suite_interface.dart';
import '../testing_models.dart';
import 'test_data/polyseed_vectors.dart';

class MoneroWalletTestSuite implements TestSuiteInterface {
  final StreamController<TestSuiteStatus> _statusController = 
      StreamController<TestSuiteStatus>.broadcast();
  TestSuiteStatus _status = TestSuiteStatus.waiting;

  @override
  String get displayName => "Monero Wallet FFI";

  @override
  Widget get icon => const Icon(Icons.account_balance_wallet, size: 32);

  @override
  TestSuiteStatus get status => _status;

  @override
  Stream<TestSuiteStatus> get statusStream => _statusController.stream;

  @override
  Future<TestResult> runTests() async {
    final stopwatch = Stopwatch()..start();
    
    try {
      _updateStatus(TestSuiteStatus.running);
      
      Logging.instance.log(Level.info, "Starting Monero wallet test suite...");

      await _testMnemonicGeneration();

      // TODO: FIXME.
      // await _testPolyseedRestoration();
      
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.passed);
      
      return TestResult(
        success: true,
        message: "üëçüëç All Monero wallet FFI tests passed successfully",
        executionTime: stopwatch.elapsed,
      );
      
    } catch (e, stackTrace) {
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.failed);
      
      Logging.instance.log(Level.error, 
        "Monero wallet test suite failed: $e\n$stackTrace"
      );
      
      return TestResult(
        success: false,
        message: "Monero wallet FFI tests failed: $e",
        executionTime: stopwatch.elapsed,
      );
    }
  }

  Future<void> _testMnemonicGeneration() async {
    Logging.instance.log(Level.info, "Testing mnemonic generation and wallet creation...");
    
    final tempDir = await StackFileSystem.applicationRootDirectory();
    final walletName = "test_wallet_${Random().nextInt(10000)}";
    final walletPath = "${tempDir.path}/$walletName";
    const walletPassword = "1";
    
    try {
      // Test 16-word mnemonic generation.
      await _testWalletCreation(
        walletPath: "${walletPath}_16", 
        password: walletPassword,
        seedType: lib_monero.MoneroSeedType.sixteen,
        expectedWordCount: 16,
      );
      
      // Test 25-word mnemonic generation.
      await _testWalletCreation(
        walletPath: "${walletPath}_25",
        password: walletPassword,
        seedType: lib_monero.MoneroSeedType.twentyFive,
        expectedWordCount: 25,
      );
      
      Logging.instance.log(Level.info, "üëç Mnemonic generation tests passed");
      
    } finally {
      // Cleanup test wallet files
      await _cleanupTestWallets([
        "${walletPath}_16",
        "${walletPath}_25",
      ]);
    }
  }

  /// Tests wallet creation with different seed types.
  ///
  /// Attempts to ensure validity of the Monero FFI integration.
  Future<void> _testWalletCreation({
    required String walletPath,
    required String password,
    required lib_monero.MoneroSeedType seedType,
    required int expectedWordCount,
  }) async {
    lib_monero.Wallet? wallet;
    
    try {
      // Create new wallet with specified seed type.
      wallet = await lib_monero.MoneroWallet.create(
        path: walletPath,
        password: password,
        seedType: seedType,
        seedOffset: "",
      );
      
      // Validate mnemonic word count
      final mnemonic = await wallet.getSeed();
      final words = mnemonic.split(' ');
      
      if (words.length != expectedWordCount) {
        throw Exception(
          "Expected $expectedWordCount words, got ${words.length}: $mnemonic"
        );
      }
      
      // Validate wallet address generation.
      final address = await wallet.getAddress();
      if (address.value.isEmpty) {
        throw Exception("Generated wallet has empty address");
      }
      
      // Validate key derivation
      final secretSpendKey = wallet.getPrivateSpendKey();
      final secretViewKey = wallet.getPrivateViewKey();
      
      if (secretSpendKey.isEmpty || secretViewKey.isEmpty) {
        throw Exception("Generated wallet has empty keys");
      }
      
      Logging.instance.log(Level.info, 
        "Successfully created $expectedWordCount-word wallet: $address"
      );
      
    } finally {
      await wallet?.close();
    }
  }

  /// Tests restoration of a wallet from a polyseed vector.
  ///
  /// Attempts to ensure soundness of the Monero FFI integration.
  Future<void> _testPolyseedRestoration() async {
    Logging.instance.log(Level.info, "Testing polyseed vector restoration...");

    final walletName = "polyseed_restore_${Random().nextInt(10000)}";
    const walletPassword = "1";

    final Directory root = await StackFileSystem.applicationRootDirectory();
    final walletPath = await lib_monero_compat.pathForWalletDir(
      name: walletName,
      type: "monero",
      appRoot: root,
    );
    
    lib_monero.Wallet? wallet;
    
    try {
      const testVector = MoneroTestVectors.polyseedVector;
      
      // Restore wallet from polyseed mnemonic.
      wallet = await lib_monero.MoneroWallet.restoreWalletFromSeed(
        path: walletPath,
        password: walletPassword,
        seed: testVector.mnemonic,
        restoreHeight: 0, // Polyseed vectors don't require a restore height.
        seedOffset: "",
      );
      
      // Validate restored mnemonic matches vector.
      final restoredMnemonic = wallet.getSeed();
      if (restoredMnemonic != testVector.mnemonic) {
        throw Exception(
          "Restored mnemonic doesn't match: expected '${testVector.mnemonic}', got '$restoredMnemonic'"
        );
      }

      final address = wallet.getAddress().value;
      if (address != testVector.expectedMainAddress.toString()) {
        throw Exception(
          "Address mismatch: expected '${testVector.expectedMainAddress}', got '$address'"
        );
      }

      final secretSpendKey = wallet.getPrivateSpendKey();
      if (secretSpendKey != testVector.expectedSecretSpendKey) {
        throw Exception(
          "Secret spend key mismatch: expected '${testVector.expectedSecretSpendKey}', got '$secretSpendKey'"
        );
      }

      final secretViewKey = wallet.getPrivateViewKey();
      if (secretViewKey != testVector.expectedSecretViewKey) {
        throw Exception(
          "Secret view key mismatch: expected '${testVector.expectedSecretViewKey}', got '$secretViewKey'"
        );
      }

      final publicSpendKey = wallet.getPublicSpendKey();
      if (publicSpendKey != testVector.expectedPublicSpendKey) {
        throw Exception(
          "Public spend key mismatch: expected '${testVector.expectedPublicSpendKey}', got '$publicSpendKey'"
        );
      }
      
      final publicViewKey = wallet.getPublicViewKey();
      if (publicViewKey != testVector.expectedPublicViewKey) {
        throw Exception(
          "Public view key mismatch: expected '${testVector.expectedPublicViewKey}', got '$publicViewKey'"
        );
      }
      
      Logging.instance.log(Level.info, "üëç Polyseed restoration test passed successfully");
      
    } finally {
      await wallet?.close();
      await _cleanupTestWallets([walletPath]);
    }
  }

  /// Cleans up test wallet files and dir created during the tests.
  Future<void> _cleanupTestWallets(List<String> walletPaths) async {
    for (final walletPath in walletPaths) {
      try {
        final walletFile = File(walletPath);
        final keysFile = File("$walletPath.keys");
        final addressFile = File("$walletPath.address.txt");
        
        if (await walletFile.exists()) {
          await walletFile.delete();
        }
        if (await keysFile.exists()) {
          await keysFile.delete();
        }
        if (await addressFile.exists()) {
          await addressFile.delete();
        }

        // Clean the directory if it's empty.
        final dir = Directory(walletPath);
        if (await dir.exists() && (await dir.list().isEmpty)) {
          await dir.delete();
        }
        
        Logging.instance.log(Level.info, "Cleaned up test wallet: $walletPath");
      } catch (e) {
        Logging.instance.log(Level.warning, "Failed to cleanup wallet $walletPath: $e");
      }
    }
  }

  void _updateStatus(TestSuiteStatus newStatus) {
    _status = newStatus;
    _statusController.add(newStatus);
  }

  @override
  Future<void> cleanup() async {
    await _statusController.close();
  }
}