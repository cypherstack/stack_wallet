/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-08-14
 *
 */

import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import 'package:flutter_mwebd/flutter_mwebd.dart';
import 'package:mweb_client/mweb_client.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/stack_file_system.dart';
import '../test_suite_interface.dart';
import '../testing_models.dart';

class LitecoinMwebIntegrationTestSuite implements TestSuiteInterface {
  final StreamController<TestSuiteStatus> _statusController = 
      StreamController<TestSuiteStatus>.broadcast();
  TestSuiteStatus _status = TestSuiteStatus.waiting;

  @override
  String get displayName => "Litecoin MWEB Integration";

  @override
  Widget get icon => const Icon(Icons.currency_bitcoin, size: 32);

  @override
  TestSuiteStatus get status => _status;

  @override
  Stream<TestSuiteStatus> get statusStream => _statusController.stream;

  @override
  Future<TestResult> runTests() async {
    final stopwatch = Stopwatch()..start();
    
    try {
      _updateStatus(TestSuiteStatus.running);
      
      Logging.instance.log(Level.info, "Starting Litecoin MWEB integration test suite...");

      await _testMwebdServerCreation();
      // await _testMwebdServerStatus();
      // await _testMwebClientConnection();
      
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.passed);
      
      return TestResult(
        success: true,
        message: "üëçüëç All Litecoin MWEB integration tests passed successfully",
        executionTime: stopwatch.elapsed,
      );
      
    } catch (e, stackTrace) {
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.failed);
      
      Logging.instance.log(Level.error, 
        "Litecoin MWEB integration test suite failed: $e\n$stackTrace"
      );
      
      return TestResult(
        success: false,
        message: "Litecoin MWEB integration tests failed: $e",
        executionTime: stopwatch.elapsed,
      );
    }
  }

  Future<void> _testMwebdServerCreation() async {
    Logging.instance.log(Level.info, "Testing MWEB server creation...");
    
    MwebdServer? server;
    try {
      // Get a random unused port for testing.
      final port = await _getRandomUnusedPort();
      if (port == null) {
        throw Exception("Could not find an unused port for mwebd test");
      }
      
      // Get test data directory.
      final dir = await StackFileSystem.applicationMwebdDirectory("testnet");
      
      // Create MwebdServer instance - this tests FFI integration.
      server = MwebdServer(
        chain: "testnet",
        dataDir: dir.path,
        peer: "litecoin.stackwallet.com:19335", // testnet peer
        proxy: "", // no proxy for test
        serverPort: port,
      );
      
      // Test server creation - this exercises the FFI bindings.
      await server.createServer();
      await server.stopServer();
      
      Logging.instance.log(Level.info, 
        "üëç MWEB server creation test passed"
      );
      
    } catch (e) {
      throw Exception("MWEB server creation test failed: $e");
    } finally {
      // Cleanup: stop server if it was created.
      if (server != null) {
        try {
          await server.stopServer();
        } catch (e) {
          Logging.instance.log(Level.warning, "Failed to stop test server: $e");
        }
      }
    }
  }

  Future<void> _testMwebdServerStatus() async {
    Logging.instance.log(Level.info, "Testing MWEB server status...");
    
    MwebdServer? server;
    try {
      // Get a random unused port for testing.
      final port = await _getRandomUnusedPort();
      if (port == null) {
        throw Exception("Could not find an unused port for mwebd test");
      }
      
      // Get test data directory.
      final dir = await StackFileSystem.applicationMwebdDirectory("testnet");
      
      // Create and start MwebdServer.
      server = MwebdServer(
        chain: "testnet",
        dataDir: dir.path,
        peer: "litecoin.stackwallet.com:19335", // Testnet peer.
        proxy: "", // No proxy for test.
        serverPort: port,
      );
      
      await server.createServer();
      await server.startServer();
      
      // Test getting server status - this tests FFI status calls.
      final status = await server.getStatus();
      
      // Verify we got a status response.
      if (status.blockHeaderHeight < 0) {
        throw Exception("Invalid block header height in status: ${status.blockHeaderHeight}");
      }
      
      // Status should have reasonable values (not necessarily synced for test).
      if (status.mwebHeaderHeight < 0) {
        throw Exception("Invalid MWEB header height in status: ${status.mwebHeaderHeight}");
      }
      
      Logging.instance.log(Level.info, 
        "üëç MWEB server status test passed (blockHeight: ${status.blockHeaderHeight}, mwebHeight: ${status.mwebHeaderHeight})"
      );
      
    } catch (e) {
      throw Exception("MWEB server status test failed: $e");
    } finally {
      // Cleanup: stop server if it was created.
      if (server != null) {
        try {
          await server.stopServer();
        } catch (e) {
          Logging.instance.log(Level.warning, "Failed to stop test server: $e");
        }
      }
    }
  }

  Future<void> _testMwebClientConnection() async {
    Logging.instance.log(Level.info, "Testing MWEB client connection...");
    
    MwebdServer? server;
    MwebClient? client;
    try {
      // Get a random unused port for testing.
      final port = await _getRandomUnusedPort();
      if (port == null) {
        throw Exception("Could not find an unused port for mwebd test");
      }
      
      // Get test data directory.
      final dir = await StackFileSystem.applicationMwebdDirectory("testnet");
      
      // Create and start MwebdServer.
      server = MwebdServer(
        chain: "testnet",
        dataDir: dir.path,
        peer: "litecoin.stackwallet.com:19335", // testnet peer.
        proxy: "", // no proxy for test.
        serverPort: port,
      );
      
      await server.createServer();
      await server.startServer();
      
      // Create MwebClient to connect to the server.
      client = MwebClient.fromHost("127.0.0.1", port);
      
      // Test basic client operations.
      // Generate dummy scan and spend secrets for testing.
      final testScanSecret = Uint8List.fromList(
        List.generate(32, (index) => index + 1)
      );
      final testSpendPub = Uint8List.fromList(
        List.generate(33, (index) => index + 1)
      );
      
      // Test address generation - this tests the client FFI integration.
      final mwebAddress = await client.address(
        testScanSecret,
        testSpendPub,
        0, // index
      );
      
      // Verify we got a valid MWEB address.
      if (mwebAddress.isEmpty) {
        throw Exception("Generated MWEB address is empty");
      }
      
      // MWEB addresses should start with "ltcmweb" for testnet.
      if (!mwebAddress.startsWith("ltcmweb")) {
        throw Exception("Generated MWEB address does not have expected prefix: $mwebAddress");
      }
      
      Logging.instance.log(Level.info, 
        "üëç MWEB client connection test passed: $mwebAddress"
      );
      
    } catch (e) {
      throw Exception("MWEB client connection test failed: $e");
    } finally {
      // Cleanup.
      if (client != null) {
        try {
          await client.cleanup();
        } catch (e) {
          Logging.instance.log(Level.warning, "Failed to cleanup test client: $e");
        }
      }
      if (server != null) {
        try {
          await server.stopServer();
        } catch (e) {
          Logging.instance.log(Level.warning, "Failed to stop test server: $e");
        }
      }
    }
  }

  void _updateStatus(TestSuiteStatus newStatus) {
    _status = newStatus;
    _statusController.add(newStatus);
  }

  @override
  Future<void> cleanup() async {
    await _statusController.close();
  }
}

// Helper function to get a random unused port.
Future<int?> _getRandomUnusedPort({Set<int> excluded = const {}}) async {
  const int minPort = 1024;
  const int maxPort = 65535;
  const int maxAttempts = 100;

  final random = Random.secure();

  for (int i = 0; i < maxAttempts; i++) {
    final int potentialPort = minPort + random.nextInt(maxPort - minPort + 1);

    if (excluded.contains(potentialPort)) {
      continue;
    }

    try {
      final serverSocket = await ServerSocket.bind(
        InternetAddress.anyIPv4,
        potentialPort,
      );
      await serverSocket.close();
      return potentialPort;
    } catch (_) {
      excluded.add(potentialPort);
      continue;
    }
  }

  return null;
}