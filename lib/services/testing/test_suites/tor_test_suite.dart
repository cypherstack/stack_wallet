/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2025 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2025-08-14
 *
 */

import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:logger/logger.dart';
import '../../../utilities/stack_file_system.dart';
import '../test_suite_interface.dart';
import '../testing_models.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/prefs.dart';
import '../../tor_service.dart';
import '../../../networking/http.dart';
import '../../event_bus/events/global/tor_connection_status_changed_event.dart';
import '../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../electrumx_rpc/electrumx_client.dart';
import '../../../utilities/tor_plain_net_option_enum.dart';

class TorTestSuite implements TestSuiteInterface {
  final StreamController<TestSuiteStatus> _statusController = StreamController<TestSuiteStatus>.broadcast();
  TestSuiteStatus _status = TestSuiteStatus.waiting;

  @override
  String get displayName => "Tor Service";

  @override
  Widget get icon => const Icon(Icons.security, size: 32);

  @override
  TestSuiteStatus get status => _status;

  @override
  Stream<TestSuiteStatus> get statusStream => _statusController.stream;

  @override
  Future<TestResult> runTests() async {
    final stopwatch = Stopwatch()..start();
    
    try {
      _updateStatus(TestSuiteStatus.running);
      
      Logging.instance.log(Level.info, ("Starting Tor service test suite..."));

      await _testTorConnection();

      await _testProxyFunctionality();

      await _testNodeAccessThroughTor();
      
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.passed);
      
      Logging.instance.log(Level.info, ("üëçüëçüëç All Tor service tests completed successfully!"));
      
      return TestResult(
        success: true,
        message: "All Tor service tests passed",
        executionTime: stopwatch.elapsed,
      );
      
    } catch (e) {
      stopwatch.stop();
      _updateStatus(TestSuiteStatus.failed);
      
      Logging.instance.log(Level.info, ("‚úó Test failed: ${e.toString()}"));
      
      return TestResult(
        success: false,
        message: "Tor service test failed: ${e.toString()}",
        executionTime: stopwatch.elapsed,
      );
    }
  }

  /// Tests the Tor connection by initializing, starting the service, and verifying proxy info.
  ///
  /// Mostly inits Tor if it wasn't already.
  Future<void> _testTorConnection() async {
    Logging.instance.log(Level.info, ("Testing Tor connection establishment..."));
    final torService = TorService.sharedInstance;
    
    // Check current Tor connection status.
    final currentStatus = torService.status;
    Logging.instance.log(Level.info, ("Current Tor status: $currentStatus"));
    
    if (currentStatus != TorConnectionStatus.connected) {
      // If not connected, attempt to initialize and start Tor for testing.
      Logging.instance.log(Level.info, ("Tor is not connected. Attempting to initialize and connect..."));
      
      try {
        // TODO: Use a temporary directory for testing purposes.
        // Start Tor service.
        final torDataPath = (await StackFileSystem.applicationTorDirectory()).path;
        Logging.instance.log(Level.info, ("Tor init..."));
        torService.init(torDataDirPath: torDataPath);
        Logging.instance.log(Level.info, ("Starting Tor service..."));
        await torService.start().timeout(
          const Duration(seconds: 30),
          onTimeout: () => throw Exception("Tor startup timed out after 30 seconds"),
        );
        
        // Verify the connection was established.
        final newStatus = torService.status;
        if (newStatus != TorConnectionStatus.connected) {
          throw Exception("Tor failed to connect. Final status: $newStatus");
        }
        
        Logging.instance.log(Level.info, ("‚úì Tor service reportedly started"));
      } catch (e) {
        throw Exception("Failed to start Tor service: $e");
      }
    } else {
      Logging.instance.log(Level.info, ("‚úì Tor service is already connected"));
      // TODO: Stop tor and do all of the above thereafter.
    }

    // Test that we can get proxy info.
    //
    // Very very basic sanity checks: port should be a valid small number and host should be loopback.
    try {
      final proxyInfo = torService.getProxyInfo();
      Logging.instance.log(Level.info, ("‚úì Proxy info retrieved: ${proxyInfo.host.address}:${proxyInfo.port}"));

      // Validate proxy info.
      if (proxyInfo.port <= 0 || proxyInfo.port > 65535) {
        throw Exception("Invalid proxy port: ${proxyInfo.port}");
      }
      if (proxyInfo.host != InternetAddress.loopbackIPv4) {
        throw Exception("Expected loopback address, got: ${proxyInfo.host.address}");
      }
    } catch (e) {
      throw Exception("Failed to get valid proxy info: $e");
    }

    Logging.instance.log(Level.info, ("‚úì Tor service looks connected and ready... host and port are valid"));
    Logging.instance.log(Level.info, ("üëç Tor connection test passed"));
  }

  /// Tests the Tor proxy functionality by making a request through it.
  ///
  /// Connects to torproject.org.
  Future<void> _testProxyFunctionality() async {
    Logging.instance.log(Level.info, ("Testing proxy functionality verification..."));
    final torService = TorService.sharedInstance;
    
    try {
      // Get Tor proxy info.
      final proxyInfo = torService.getProxyInfo();
      Logging.instance.log(Level.info, ("Tor proxy info: ${proxyInfo.host}:${proxyInfo.port}"));
      
      // Test if we can get proxy info without throwing.
      if (proxyInfo.port <= 0 || proxyInfo.port > 65535) {
        throw Exception("Invalid proxy port: ${proxyInfo.port}");
      }
      
      Logging.instance.log(Level.info, ("‚úì Proxy info retrieved successfully"));
      
      // Test actual proxy functionality by making a request through it.
      final http = HTTP();
      final testUrl = Uri.parse("https://check.torproject.org/api/ip");
      
      Logging.instance.log(Level.info, ("Testing proxy by making request to: $testUrl"));
      
      try {
        final response = await http.get(
          url: testUrl,
          proxyInfo: proxyInfo,
        ).timeout(const Duration(seconds: 10));
        
        if (response.code == 200) {
          Logging.instance.log(Level.info, ("‚úì Successfully made HTTP request through Tor proxy"));
          Logging.instance.log(Level.info, ("Response code: ${response.code}"));
          
          // Parse response to check if we're using Tor.
          if (response.body.contains('"IsTor":true')) {
            Logging.instance.log(Level.info, ("‚úì Confirmed traffic is routed through Tor network"));
            // TODO: Replace test with a more reliable check.
          } else {
            Logging.instance.log(Level.info, ("‚ö† Warning: Response doesn't confirm Tor usage"));
          }
        } else {
          throw Exception("HTTP request failed with code: ${response.code}");
        }
      } catch (e) {
        throw Exception("Failed to make HTTP request through proxy: $e");
      }
      
    } catch (e) {
      throw Exception("Proxy functionality test failed: $e");
    }

    Logging.instance.log(Level.info, ("üëç Proxy functionality test passed"));
  }

  /// Tests access to the default Bitcoin node through Tor.
  ///
  /// Validates we can ping the node, get server features, and retrieve block headers.
  Future<void> _testNodeAccessThroughTor() async {
    Logging.instance.log(Level.info, ("Testing node access through Tor..."));
    final torService = TorService.sharedInstance;
    
    try {
      // Ensure we can get proxy info (validates Tor is working).
      torService.getProxyInfo();
      
      // Test accessing Stack Wallet's default Bitcoin node through Tor.
      final bitcoin = Bitcoin(CryptoCurrencyNetwork.main);
      final defaultNode = bitcoin.defaultNode(isPrimary: true);

      Logging.instance.log(Level.info, ("Testing Bitcoin node access through Tor: ${defaultNode.host}:${defaultNode.port}"));
      
      // Create an ElectrumX client connected through Tor to test actual node access.
      final electrumClient = ElectrumXClient(
        host: defaultNode.host,
        port: defaultNode.port,
        useSSL: defaultNode.useSSL,
        prefs: Prefs.instance,
        netType: TorPlainNetworkOption.tor,
        failovers: [],
        cryptoCurrency: bitcoin,
      );
      
      try {
        // Test basic connectivity with a ping.
        Logging.instance.log(Level.info, ("Sending ping to Bitcoin node through Tor..."));
        final pingResult = await electrumClient.ping(retryCount: 1).timeout(
          const Duration(seconds: 30),
        );
        
        if (pingResult) {
          Logging.instance.log(Level.info, ("‚úì Successfully pinged Bitcoin node through Tor"));
        } else {
          throw Exception("Ping failed or returned false");
        }
        
        // Test a basic ElectrumX command (getting server features).
        Logging.instance.log(Level.info, ("Getting server features from Bitcoin node..."));
        final serverFeatures = await electrumClient.getServerFeatures().timeout(
          const Duration(seconds: 15),
        );
        
        if (serverFeatures.isNotEmpty) {
          Logging.instance.log(Level.info, ("‚úì Successfully retrieved server features"));
          
          // Verify this is actually a Bitcoin node by checking genesis hash.
          final genesisHash = serverFeatures['genesis_hash'] as String?;
          if (genesisHash == bitcoin.genesisHash) {
            Logging.instance.log(Level.info, ("‚úì Confirmed connection to valid Bitcoin mainnet node"));
            Logging.instance.log(Level.info, ("Server version: ${serverFeatures['server_version'] ?? 'Unknown'}"));
          } else {
            Logging.instance.log(Level.info, ("‚ö† Warning: Genesis hash mismatch. Expected: ${bitcoin.genesisHash}, Got: $genesisHash"));
          }
        } else {
          throw Exception("Empty server features response");
        }
        
        // Test getting block header.
        Logging.instance.log(Level.info, ("Getting latest block header..."));
        final blockHeader = await electrumClient.getBlockHeadTip().timeout(
          const Duration(seconds: 15),
        );
        
        if (blockHeader.containsKey('height') && blockHeader.containsKey('hex')) {
          final height = blockHeader['height'] as int;
          Logging.instance.log(Level.info, ("‚úì Successfully retrieved block header"));
          Logging.instance.log(Level.info, ("Current block height: $height"));
        } else {
          throw Exception("Invalid block header response format");
        }
        
      } catch (e) {
        throw Exception("Failed to communicate with Bitcoin node through Tor: $e");
      } finally {
        // Clean up the client connection.
        try {
          await electrumClient.closeAdapter();
        } catch (e) {
          Logging.instance.log(Level.info, ("Note: Error closing ElectrumX client: $e"));
        }
      }
      
    } catch (e) {
      throw Exception("Bitcoin node access test failed: $e");
    }

    Logging.instance.log(Level.info, ("üëç Node access through Tor test passed"));
  }

  void _updateStatus(TestSuiteStatus newStatus) {
    _status = newStatus;
    _statusController.add(_status);
  }

  @override
  Future<void> cleanup() async {
    Logging.instance.log(Level.info, "Cleaning up Tor test suite");
    
    try {
      // Note: We don't disable TorService here as it might be used by the main app.
      // The TorService will remain in whatever state the tests left it in.
      Logging.instance.log(Level.warning, "TorService cleanup is not performed in tests, it should be handled by the app lifecycle.");
    } catch (e) {
      Logging.instance.log(Level.warning, "Error during Tor test cleanup: $e");
    }
    
    await _statusController.close();
  }
}