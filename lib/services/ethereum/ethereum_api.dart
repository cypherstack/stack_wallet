/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import '../../app_config.dart';
import '../../dto/ethereum/eth_token_tx_dto.dart';
import '../../dto/ethereum/eth_tx_dto.dart';
import '../../models/isar/models/ethereum/eth_contract.dart';
import '../../models/paymint/fee_object_model.dart';
import '../../networking/http.dart';
import '../../utilities/amount/amount.dart';
import '../../utilities/eth_commons.dart';
import '../../utilities/logger.dart';
import '../../utilities/prefs.dart';
import '../../wallets/crypto_currency/crypto_currency.dart';
import '../tor_service.dart';

class EthApiException implements Exception {
  EthApiException(this.message);

  final String message;

  @override
  String toString() => "$runtimeType: $message";
}

class EthereumResponse<T> {
  EthereumResponse(this.value, this.exception);

  final T? value;
  final EthApiException? exception;

  @override
  toString() => "EthereumResponse: { value: $value, exception: $exception }";
}

abstract class EthereumAPI {
  static String get stackBaseServer =>
      Ethereum(CryptoCurrencyNetwork.main).defaultNode(isPrimary: true).host;

  static HTTP client = HTTP();

  static Future<EthereumResponse<List<EthTxDTO>>> getEthTransactions({
    required String address,
    int firstBlock = 0,
    bool includeTokens = false,
  }) async {
    try {
      final response = await client.get(
        url: Uri.parse(
          "$stackBaseServer/export?addrs=$address&firstBlock=$firstBlock&unripe=true",
        ),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      if (response.code == 200) {
        if (response.body.isNotEmpty) {
          final json = jsonDecode(response.body) as Map;
          final list = json["data"] as List?;

          final List<EthTxDTO> txns = [];
          for (final map in list!) {
            final txn = EthTxDTO.fromMap(Map<String, dynamic>.from(map as Map));

            if (!txn.hasToken || includeTokens) {
              txns.add(txn);
            }
          }
          return EthereumResponse(txns, null);
        } else {
          // nice that the api returns an empty body instead of being
          // consistent and returning a json object with no transactions
          return EthereumResponse([], null);
        }
      } else {
        throw EthApiException(
          "getEthTransactions($address) failed with status code: "
          "${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e("getEthTransactions()", error: e);
      Logging.instance.d(
        "getEthTransactions($address)",
        error: e,
        stackTrace: s,
      );
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }

  static Future<EthereumResponse<List<EthTokenTxDto>>> getTokenTransactions({
    required String address,
    required String tokenContractAddress,
  }) async {
    try {
      final response = await client.get(
        url: Uri.parse(
          "$stackBaseServer/export?addrs=$address&emitter=$tokenContractAddress&logs=true",
        ),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      if (response.code == 200) {
        if (response.body.isNotEmpty) {
          final json = jsonDecode(response.body) as Map;
          final list = json["data"] as List?;

          final List<EthTokenTxDto> txns = [];
          for (final map in list!) {
            final txn = EthTokenTxDto.fromMap(
              Map<String, dynamic>.from(map as Map),
            );

            txns.add(txn);
          }
          return EthereumResponse(txns, null);
        } else {
          // nice that the api returns an empty body instead of being
          // consistent and returning a json object with no transactions
          return EthereumResponse([], null);
        }
      } else {
        throw EthApiException(
          "getTokenTransactions($address, $tokenContractAddress) failed with status code: "
          "${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e("getTokenTransactions()", error: e);
      Logging.instance.d(
        "getTokenTransactions($address, $tokenContractAddress)",
        error: e,
        stackTrace: s,
      );
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }

  static Future<EthereumResponse<Amount>> getWalletTokenBalance({
    required String address,
    required String contractAddress,
  }) async {
    try {
      final uri = Uri.parse(
        "$stackBaseServer/tokens?addrs=$contractAddress $address",
      );
      final response = await client.get(
        url: uri,
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      if (response.code == 200) {
        final json = jsonDecode(response.body);
        if (json["data"] is List) {
          final map = json["data"].first as Map;

          final balance =
              BigInt.tryParse(map["balance"].toString()) ?? BigInt.zero;

          return EthereumResponse(
            Amount(rawValue: balance, fractionDigits: map["decimals"] as int),
            null,
          );
        } else {
          throw EthApiException(json["message"] as String);
        }
      } else {
        throw EthApiException(
          "getWalletTokenBalance($address) failed with status code: "
          "${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e("getWalletTokenBalance()", error: e, stackTrace: s);
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }

  static Future<EthereumResponse<GasTracker>> getGasOracle() async {
    try {
      final response = await client.get(
        url: Uri.parse("$stackBaseServer/gas-prices"),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      if (response.code == 200) {
        final json = jsonDecode(response.body) as Map;
        if (json["success"] == true) {
          try {
            return EthereumResponse(
              GasTracker.fromJson(
                Map<String, dynamic>.from(json["result"]["result"] as Map),
              ),
              null,
            );
          } catch (_) {
            throw EthApiException(
              "getGasOracle() failed with response: "
              "${response.body}",
            );
          }
        } else {
          throw EthApiException(
            "getGasOracle() failed with response: "
            "${response.body}",
          );
        }
      } else {
        throw EthApiException(
          "getGasOracle() failed with status code: "
          "${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e("getGasOracle()", error: e, stackTrace: s);
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }

  static Future<EthFeeObject> getFees() async {
    final response = await getGasOracle();
    if (response.exception != null) {
      throw response.exception!;
    }

    return EthFeeObject(
      suggestBaseFee: response.value!.suggestBaseFee.shift(9).toBigInt(),
      numberOfBlocksFast: response.value!.numberOfBlocksFast,
      numberOfBlocksAverage: response.value!.numberOfBlocksAverage,
      numberOfBlocksSlow: response.value!.numberOfBlocksSlow,
      fast: response.value!.high.shift(9).toBigInt(),
      medium: response.value!.average.shift(9).toBigInt(),
      slow: response.value!.low.shift(9).toBigInt(),
    );
  }

  static Future<void> _addContractInfoToServer(String contractAddress) async {
    await client.get(
      url: Uri.parse(
        "$stackBaseServer/names?terms=$contractAddress&autoname=$contractAddress&all",
      ),
      proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
          ? null
          : Prefs.instance.useTor
          ? TorService.sharedInstance.getProxyInfo()
          : null,
    );
  }

  static Future<EthereumResponse<EthContract>> getTokenContractInfoByAddress(
    String contractAddress, {
    bool autoNameOnEmpty = true,
  }) async {
    try {
      final response = await client.get(
        url: Uri.parse(
          // "$stackBaseServer/tokens?addrs=$contractAddress&parts=all",
          "$stackBaseServer/names?terms=$contractAddress&all",
        ),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      if (response.code == 200) {
        final json = jsonDecode(response.body) as Map;
        if (json["data"] is List) {
          if ((json["data"] as List).isEmpty) {
            if (autoNameOnEmpty) {
              Logging.instance.d(
                "getTokenByContractAddress(): Adding token data to server",
              );
              // this will add the missing data to server
              await _addContractInfoToServer(contractAddress);

              Logging.instance.d(
                "getTokenByContractAddress(): Adding to server threw so now"
                "we try a normal fetch again",
              );

              // now try again
              return await getTokenContractInfoByAddress(
                contractAddress,
                autoNameOnEmpty: false, // prevent possible infinite loop
              );
            } else {
              throw EthApiException("Unknown token");
            }
          }

          final map = Map<String, dynamic>.from(json["data"].first as Map);
          EthContract? token;
          if (map["isErc20"] == true) {
            token = EthContract(
              address: map["address"] as String,
              decimals: map["decimals"] as int,
              name: map["name"] as String,
              symbol: map["symbol"] as String,
              type: EthContractType.erc20,
            );
          } else if (map["isErc721"] == true) {
            token = EthContract(
              address: map["address"] as String,
              decimals: map["decimals"] as int,
              name: map["name"] as String,
              symbol: map["symbol"] as String,
              type: EthContractType.erc721,
            );
          } else {
            throw EthApiException(
              "Unsupported token type found: ${map["type"]} in $map",
            );
          }

          return EthereumResponse(token, null);
        } else {
          throw EthApiException(response.body);
        }
      } else {
        throw EthApiException(
          "getTokenByContractAddress($contractAddress) failed with status code: "
          "${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e(
        "getTokenByContractAddress()",
        error: e,
        stackTrace: s,
      );
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }

  static Future<EthereumResponse<String>> getTokenAbi({
    required String name,
    required String contractAddress,
  }) async {
    try {
      final response = await client.get(
        url: Uri.parse(
          "$stackBaseServer/abis?addrs=$contractAddress&verbose=true",
        ),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );

      if (response.code == 200) {
        final json = jsonDecode(response.body)["data"] as List;

        return EthereumResponse(jsonEncode(json), null);
      } else {
        throw EthApiException(
          "getTokenAbi($name, $contractAddress) failed with status code: "
          "${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e(
        "getTokenAbi($name, $contractAddress)",
        error: e,
        stackTrace: s,
      );
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }

  /// Fetch the underlying contract address that a proxy contract points to
  static Future<EthereumResponse<String>> getProxyTokenImplementationAddress(
    String contractAddress,
  ) async {
    try {
      final response = await client.get(
        url: Uri.parse(
          "$stackBaseServer/state?addrs=$contractAddress&parts=proxy",
        ),
        proxyInfo: !AppConfig.hasFeature(AppFeature.tor)
            ? null
            : Prefs.instance.useTor
            ? TorService.sharedInstance.getProxyInfo()
            : null,
      );
      if (response.code == 200) {
        final json = jsonDecode(response.body);
        final list = json["data"] as List;
        final map = Map<String, dynamic>.from(list.first as Map);

        return EthereumResponse(map["proxy"] as String, null);
      } else {
        throw EthApiException(
          "getProxyTokenImplementationAddress($contractAddress) failed with"
          " status code: ${response.code}",
        );
      }
    } on EthApiException catch (e) {
      return EthereumResponse(null, e);
    } catch (e, s) {
      Logging.instance.e(
        "getProxyTokenImplementationAddress($contractAddress)",
        error: e,
        stackTrace: s,
      );
      return EthereumResponse(null, EthApiException(e.toString()));
    }
  }
}
