/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:http/http.dart';

import '../app_config.dart';
import '../db/hive/db.dart';
import '../models/node_model.dart';
import '../utilities/default_nodes.dart';
import '../utilities/flutter_secure_storage_interface.dart';
import '../utilities/logger.dart';
import '../wallets/crypto_currency/crypto_currency.dart';

const kStackCommunityNodesEndpoint = "https://extras.stackwallet.com";

class NodeService extends ChangeNotifier {
  final SecureStorageInterface secureStorageInterface;

  /// Exposed [secureStorageInterface] in order to inject mock for tests
  NodeService({required this.secureStorageInterface});

  Future<void> updateDefaults() async {
    // hack
    if (AppConfig.coins.where((e) => e.identifier == "firo").isNotEmpty) {
      final others = [
        "electrumx01.firo.org",
        "electrumx02.firo.org",
        "electrumx03.firo.org",
        "electrumx.firo.org",
      ];
      const port = 50002;
      const idPrefix = "not_a_real_default_but_temp";

      for (final host in others) {
        final _id = "${idPrefix}_$host";

        NodeModel? node = DB.instance.get<NodeModel>(
          boxName: DB.boxNameNodeModels,
          key: _id,
        );

        if (node == null) {
          node = NodeModel(
            host: host,
            port: port,
            name: host,
            id: _id,
            useSSL: true,
            enabled: true,
            coinName: "firo",
            isFailover: true,
            isDown: false,
            torEnabled: true,
            clearnetEnabled: true,
            isPrimary: false,
          );

          await DB.instance.put<NodeModel>(
            boxName: DB.boxNameNodeModels,
            key: _id,
            value: node,
          );
        }
      }
    }

    for (final defaultNode in AppConfig.coins.map((e) => e.defaultNode)) {
      final savedNode = DB.instance.get<NodeModel>(
        boxName: DB.boxNameNodeModels,
        key: defaultNode.id,
      );
      if (savedNode == null) {
        // save the default node to hive only if no other nodes for the specific coin exist
        if (getNodesFor(
          AppConfig.getCryptoCurrencyByPrettyName(defaultNode.coinName),
        ).isEmpty) {
          await DB.instance.put<NodeModel>(
            boxName: DB.boxNameNodeModels,
            key: defaultNode.id,
            value: defaultNode,
          );
        }
      } else {
        // update all fields but copy over previously set enabled and trusted states
        await DB.instance.put<NodeModel>(
          boxName: DB.boxNameNodeModels,
          key: savedNode.id,
          value: defaultNode.copyWith(
            enabled: savedNode.enabled,
            isFailover: savedNode.isFailover,
            trusted: savedNode.trusted,
            torEnabled: savedNode.torEnabled,
            clearnetEnabled: savedNode.clearnetEnabled,
            loginName: savedNode.loginName,
          ),
        );
      }

      // check if a default node is the primary node for the crypto currency
      // and update it if needed
      final coin = AppConfig.getCryptoCurrencyByPrettyName(
        defaultNode.coinName,
      );
      final primaryNode = getPrimaryNodeFor(currency: coin);
      if (primaryNode != null && primaryNode.id == defaultNode.id) {
        await setPrimaryNodeFor(
          coin: coin,
          node: defaultNode.copyWith(
            enabled: primaryNode.enabled,
            isFailover: primaryNode.isFailover,
            trusted: primaryNode.trusted,
            torEnabled: primaryNode.torEnabled,
            clearnetEnabled: primaryNode.clearnetEnabled,
            loginName: primaryNode.loginName,
          ),
        );
      }
    }
  }

  Future<void> setPrimaryNodeFor({
    required CryptoCurrency coin,
    required NodeModel node,
    bool shouldNotifyListeners = false,
  }) async {
    // current
    final currentPrimaries = primaryNodes.where(
      (e) => e.coinName == coin.identifier && e.id != node.id,
    );
    final List<NodeModel> toStore = [];
    for (final node in currentPrimaries) {
      final updated = node.copyWith(
        loginName: node.loginName,
        trusted: node.trusted,
        isPrimary: false,
      );
      toStore.add(updated);
    }
    toStore.add(
      node.copyWith(
        loginName: node.loginName,
        trusted: node.trusted,
        isPrimary: true,
      ),
    );

    for (final node in toStore) {
      await DB.instance.put<NodeModel>(
        boxName: DB.boxNameNodeModels,
        key: node.id,
        value: node,
      );
    }

    if (shouldNotifyListeners) {
      notifyListeners();
    }
  }

  NodeModel? getPrimaryNodeFor({required CryptoCurrency currency}) {
    return primaryNodes
        .where((e) => e.coinName == currency.identifier)
        .firstOrNull;
  }

  List<NodeModel> get primaryNodes {
    return nodes.where((e) => e.isPrimary).toList();
  }

  List<NodeModel> get nodes {
    return DB.instance.values<NodeModel>(boxName: DB.boxNameNodeModels);
  }

  List<NodeModel> getNodesFor(CryptoCurrency coin) {
    final list =
        DB.instance
            .values<NodeModel>(boxName: DB.boxNameNodeModels)
            .where(
              (e) =>
                  e.coinName == coin.identifier &&
                  !e.id.startsWith(DefaultNodes.defaultNodeIdPrefix),
            )
            .toList();

    // add default to end of list
    list.addAll(
      DB.instance
          .values<NodeModel>(boxName: DB.boxNameNodeModels)
          .where(
            (e) =>
                e.coinName == coin.identifier &&
                e.id.startsWith(DefaultNodes.defaultNodeIdPrefix),
          )
          .toList(),
    );

    // return reversed list so default node appears at beginning
    return list.reversed.toList();
  }

  NodeModel? getNodeById({required String id}) {
    return DB.instance.get<NodeModel>(boxName: DB.boxNameNodeModels, key: id);
  }

  List<NodeModel> failoverNodesFor({required CryptoCurrency currency}) {
    return getNodesFor(
      currency,
    ).where((e) => e.isFailover && !e.isDown).toList();
  }

  /// Adds a new node to the database.
  ///
  /// If a node with the same ID already exists, it will be overwritten.
  Future<void> save(
    NodeModel node,
    String? password,
    bool shouldNotifyListeners,
  ) async {
    // Handle primary node updates (logic from edit())
    final coin = AppConfig.getCryptoCurrencyByPrettyName(node.coinName);
    final primaryNode = getPrimaryNodeFor(currency: coin);
    if (primaryNode?.id == node.id) {
      await setPrimaryNodeFor(
        coin: coin,
        node: node,
        shouldNotifyListeners: true,
      );
    }

    // Save to database (logic from add()).
    await DB.instance.put<NodeModel>(
      boxName: DB.boxNameNodeModels,
      key: node.id,
      value: node,
    );

    // Save password to secure storage.
    if (password != null) {
      await secureStorageInterface.write(
        key: "${node.id}_nodePW",
        value: password,
      );
    } else {
      await secureStorageInterface.delete(key: "${node.id}_nodePW");
    }
    if (shouldNotifyListeners) {
      notifyListeners();
    }
  }

  Future<void> delete(String id, bool shouldNotifyListeners) async {
    final nodeToDelete = getNodeById(id: id);

    if (nodeToDelete == null) {
      // doesn't exist
      Logging.instance.w(
        "Attempted delete of a node model that does not exist",
      );
      return;
    }

    final coin = AppConfig.getCryptoCurrencyByPrettyName(nodeToDelete.coinName);
    final remaining = getNodesFor(coin);

    if (remaining.length - 1 < 1) {
      // doesn't exist
      Logging.instance.w("Attempted delete the last remaining node for $coin");
      return;
    }

    remaining.retainWhere((e) => e.id != nodeToDelete.id);

    await DB.instance.delete<NodeModel>(boxName: DB.boxNameNodeModels, key: id);
    await secureStorageInterface.delete(key: "${id}_nodePW");

    if (nodeToDelete.isPrimary) {
      await setPrimaryNodeFor(coin: coin, node: remaining.first);
    }

    if (shouldNotifyListeners) {
      notifyListeners();
    }
  }

  Future<void> setEnabledState(
    String id,
    bool enabled,
    bool shouldNotifyListeners,
  ) async {
    final model =
        DB.instance.get<NodeModel>(boxName: DB.boxNameNodeModels, key: id)!;
    await DB.instance.put<NodeModel>(
      boxName: DB.boxNameNodeModels,
      key: model.id,
      value: model.copyWith(
        enabled: enabled,
        loginName: model.loginName,
        trusted: model.trusted,
      ),
    );
    if (shouldNotifyListeners) {
      notifyListeners();
    }
  }

  //============================================================================

  Future<void> updateCommunityNodes() async {
    final Client client = Client();
    try {
      final uri = Uri.parse("$kStackCommunityNodesEndpoint/getNodes");
      final response = await client.post(
        uri,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({"jsonrpc": "2.0", "id": "0"}),
      );

      final json = jsonDecode(response.body) as Map;
      final result = jsonDecode(json['result'] as String);
      final map = jsonDecode(result as String);
      Logging.instance.d(map);

      for (final coin in AppConfig.coins) {
        final nodeList = List<Map<String, dynamic>>.from(
          map["nodes"][coin.identifier] as List? ?? [],
        );
        for (final nodeMap in nodeList) {
          NodeModel node = NodeModel(
            host: nodeMap["host"] as String,
            port: nodeMap["port"] as int,
            name: nodeMap["name"] as String,
            id: nodeMap["id"] as String,
            useSSL: nodeMap["useSSL"] == "true",
            enabled: true,
            coinName: coin.identifier,
            isFailover: true,
            torEnabled: nodeMap["torEnabled"] == "true",
            isDown: nodeMap["isDown"] == "true",
            clearnetEnabled: nodeMap["plainEnabled"] == "true",
            isPrimary: nodeMap["plainEnabled"] == "true",
          );
          final currentNode = getNodeById(id: nodeMap["id"] as String);
          if (currentNode != null) {
            node = currentNode.copyWith(
              host: node.host,
              port: node.port,
              name: node.name,
              useSSL: node.useSSL,
              coinName: node.coinName,
              isDown: node.isDown,
              loginName: node.loginName,
              trusted: node.trusted,
            );
          }
          await save(node, null, false);
        }
      }
    } catch (e, s) {
      Logging.instance.e(
        "updateCommunityNodes() failed",
        error: e,
        stackTrace: s,
      );
    }
  }
}
