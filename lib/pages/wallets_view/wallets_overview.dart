/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/svg.dart';
import 'package:isar_community/isar.dart';

import '../../app_config.dart';
import '../../models/add_wallet_list_entity/sub_classes/coin_entity.dart';
import '../../models/isar/models/ethereum/eth_contract.dart';
import '../../pages_desktop_specific/my_stack_view/dialogs/desktop_expanding_wallet_card.dart';
import '../../providers/providers.dart';
import '../../services/event_bus/events/wallet_added_event.dart';
import '../../services/event_bus/global_event_bus.dart';
import '../../themes/stack_colors.dart';
import '../../utilities/assets.dart';
import '../../utilities/constants.dart';
import '../../utilities/text_styles.dart';
import '../../utilities/util.dart';
import '../../wallets/crypto_currency/crypto_currency.dart';
import '../../wallets/isar/models/wallet_info.dart';
import '../../wallets/isar/providers/all_wallets_info_provider.dart';
import '../../wallets/isar/providers/wallet_info_provider.dart';
import '../../wallets/wallet/wallet.dart';
import '../../widgets/background.dart';
import '../../widgets/conditional_parent.dart';
import '../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../widgets/icon_widgets/x_icon.dart';
import '../../widgets/master_wallet_card.dart';
import '../../widgets/rounded_white_container.dart';
import '../../widgets/stack_text_field.dart';
import '../../widgets/textfield_icon_button.dart';
import '../../widgets/wallet_card.dart';
import '../add_wallet_views/create_or_restore_wallet_view/create_or_restore_wallet_view.dart';

class WalletsOverview extends ConsumerStatefulWidget {
  const WalletsOverview({
    super.key,
    required this.coin,
    this.navigatorState,
    this.overrideSimpleWalletCardPopPreviousValueWith,
  });

  final CryptoCurrency coin;
  final NavigatorState? navigatorState;
  final bool? overrideSimpleWalletCardPopPreviousValueWith;

  static const routeName = "/walletsOverview";

  @override
  ConsumerState<WalletsOverview> createState() => _EthWalletsOverviewState();
}

typedef WalletListItemData = ({Wallet wallet, List<EthContract> contracts});

class _EthWalletsOverviewState extends ConsumerState<WalletsOverview> {
  final isDesktop = Util.isDesktop;

  late final TextEditingController _searchController;
  late final FocusNode searchFieldFocusNode;

  String _searchString = "";

  final Map<String, WalletListItemData> wallets = {};

  List<WalletListItemData> _filter(String searchTerm) {
    // clean out deleted wallets
    final existingWalletIds =
        ref
            .read(mainDBProvider)
            .isar
            .walletInfo
            .where()
            .walletIdProperty()
            .findAllSync();
    wallets.removeWhere((k, v) => !existingWalletIds.contains(k));

    if (searchTerm.isEmpty) {
      return wallets.values.toList()
        ..sort((a, b) => a.wallet.info.name.compareTo(b.wallet.info.name));
    }

    final Map<String, WalletListItemData> results = {};
    final term = searchTerm.toLowerCase();

    for (final entry in wallets.entries) {
      bool includeManager = false;
      // search wallet name and total balance
      includeManager |= _elementContains(entry.value.wallet.info.name, term);
      includeManager |= _elementContains(
        entry.value.wallet.info.cachedBalance.total.decimal.toString(),
        term,
      );

      final List<EthContract> contracts = [];

      for (final contract in entry.value.contracts) {
        if (_elementContains(contract.name, term)) {
          contracts.add(contract);
        } else if (_elementContains(contract.symbol, term)) {
          contracts.add(contract);
        } else if (_elementContains(contract.type.name, term)) {
          contracts.add(contract);
        } else if (_elementContains(contract.address, term)) {
          contracts.add(contract);
        }
      }

      if (includeManager || contracts.isNotEmpty) {
        results.addEntries([entry]);
      }
    }

    return results.values.toList()
      ..sort((a, b) => a.wallet.info.name.compareTo(b.wallet.info.name));
  }

  bool _elementContains(String element, String term) {
    return element.toLowerCase().contains(term);
  }

  void updateWallets() {
    final walletsData = ref.read(pAllWalletsInfo);

    walletsData.removeWhere((e) => e.coin != widget.coin);

    if (widget.coin is Ethereum) {
      for (final data in walletsData) {
        final List<EthContract> contracts = [];
        final contractAddresses = ref.read(
          pWalletTokenAddresses(data.walletId),
        );

        // fetch each contract
        for (final contractAddress in contractAddresses) {
          final contract = ref
              .read(mainDBProvider)
              .getEthContractSync(contractAddress);

          // add it to list if it exists in DB
          if (contract != null) {
            contracts.add(contract);
          }
        }

        // add tuple to list
        wallets[data.walletId] = (
          wallet: ref.read(pWallets).getWallet(data.walletId),
          contracts: contracts,
        );
      }
    } else {
      // add non token wallet tuple to list
      for (final data in walletsData) {
        // desktop single coin apps may cause issues so lets just ignore the error and move on
        try {
          wallets[data.walletId] = (
            wallet: ref.read(pWallets).getWallet(data.walletId),
            contracts: [],
          );
        } catch (_) {
          // lol bandaid for single coin based apps
        }
      }
    }
  }

  @override
  void initState() {
    _searchController = TextEditingController();
    searchFieldFocusNode = FocusNode();

    updateWallets();

    if (AppConfig.isSingleCoinApp) {
      GlobalEventBus.instance.on<WalletsChangedEvent>().listen((_) {
        updateWallets();
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            setState(() {});
          }
        });
      });
    }

    super.initState();
  }

  @override
  void dispose() {
    _searchController.dispose();
    searchFieldFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return ConditionalParent(
      condition: !isDesktop && !AppConfig.isSingleCoinApp,
      builder:
          (child) => Background(
            child: Scaffold(
              backgroundColor:
                  Theme.of(context).extension<StackColors>()!.background,
              appBar: AppBar(
                leading: const AppBarBackButton(),
                title: Text(
                  "${widget.coin.prettyName} (${widget.coin.ticker}) wallets",
                  style: STextStyles.navBarTitle(context),
                ),
                actions: [
                  AspectRatio(
                    aspectRatio: 1,
                    child: AppBarIconButton(
                      icon: SvgPicture.asset(
                        Assets.svg.plus,
                        width: 18,
                        height: 18,
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.topNavIconPrimary,
                      ),
                      onPressed: () {
                        Navigator.of(context).pushNamed(
                          CreateOrRestoreWalletView.routeName,
                          arguments: CoinEntity(widget.coin),
                        );
                      },
                    ),
                  ),
                ],
              ),
              body: SafeArea(
                child: Padding(padding: const EdgeInsets.all(16), child: child),
              ),
            ),
          ),
      child: Column(
        children: [
          ClipRRect(
            borderRadius: BorderRadius.circular(
              Constants.size.circularBorderRadius,
            ),
            child: TextField(
              autocorrect: !isDesktop,
              enableSuggestions: !isDesktop,
              controller: _searchController,
              focusNode: searchFieldFocusNode,
              onChanged: (value) {
                setState(() {
                  _searchString = value;
                });
              },
              style:
                  isDesktop
                      ? STextStyles.desktopTextExtraSmall(context).copyWith(
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.textFieldActiveText,
                        height: 1.8,
                      )
                      : STextStyles.field(context),
              decoration: standardInputDecoration(
                "Search...",
                searchFieldFocusNode,
                context,
                desktopMed: isDesktop,
              ).copyWith(
                prefixIcon: Padding(
                  padding: EdgeInsets.symmetric(
                    horizontal: isDesktop ? 12 : 10,
                    vertical: isDesktop ? 18 : 16,
                  ),
                  child: SvgPicture.asset(
                    Assets.svg.search,
                    width: isDesktop ? 20 : 16,
                    height: isDesktop ? 20 : 16,
                  ),
                ),
                suffixIcon:
                    _searchController.text.isNotEmpty
                        ? Padding(
                          padding: const EdgeInsets.only(right: 0),
                          child: UnconstrainedBox(
                            child: Row(
                              children: [
                                TextFieldIconButton(
                                  child: const XIcon(),
                                  onTap: () async {
                                    setState(() {
                                      _searchController.text = "";
                                      _searchString = "";
                                    });
                                  },
                                ),
                              ],
                            ),
                          ),
                        )
                        : null,
              ),
            ),
          ),
          const SizedBox(height: 16),
          Expanded(
            child: Builder(
              builder: (context) {
                final data = _filter(_searchString);
                return ListView.separated(
                  itemBuilder: (_, index) {
                    final entry = data[index];
                    final wallet = entry.wallet;

                    if (wallet.cryptoCurrency.hasTokenSupport) {
                      if (isDesktop) {
                        return DesktopExpandingWalletCard(
                          key: Key(
                            "${wallet.walletId}_${entry.contracts.map((e) => e.address).join()}",
                          ),
                          data: entry,
                          navigatorState: widget.navigatorState!,
                        );
                      } else {
                        return MasterWalletCard(
                          key: Key(wallet.walletId),
                          walletId: wallet.walletId,
                        );
                      }
                    } else {
                      return ConditionalParent(
                        key: Key(wallet.walletId),
                        condition: isDesktop,
                        builder:
                            (child) => RoundedWhiteContainer(
                              padding: const EdgeInsets.symmetric(
                                vertical: 14,
                                horizontal: 20,
                              ),
                              borderColor:
                                  Theme.of(
                                    context,
                                  ).extension<StackColors>()!.backgroundAppBar,
                              child: child,
                            ),
                        child: SimpleWalletCard(
                          walletId: wallet.walletId,
                          popPrevious:
                              widget.overrideSimpleWalletCardPopPreviousValueWith ==
                                      null
                                  ? isDesktop
                                  : widget
                                      .overrideSimpleWalletCardPopPreviousValueWith!,
                          desktopNavigatorState:
                              isDesktop ? widget.navigatorState : null,
                        ),
                      );
                    }
                  },
                  separatorBuilder:
                      (_, __) => SizedBox(height: isDesktop ? 10 : 8),
                  itemCount: data.length,
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
