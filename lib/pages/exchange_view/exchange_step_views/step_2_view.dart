/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../app_config.dart';
import '../../../models/exchange/incomplete_exchange.dart';
import '../../../providers/providers.dart';
import '../../../themes/stack_colors.dart';
import '../../../utilities/address_utils.dart';
import '../../../utilities/barcode_scanner_interface.dart';
import '../../../utilities/clipboard_interface.dart';
import '../../../utilities/constants.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/text_styles.dart';
import '../../../widgets/background.dart';
import '../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../widgets/custom_buttons/blue_text_button.dart';
import '../../../widgets/desktop/primary_button.dart';
import '../../../widgets/icon_widgets/addressbook_icon.dart';
import '../../../widgets/icon_widgets/clipboard_icon.dart';
import '../../../widgets/icon_widgets/qrcode_icon.dart';
import '../../../widgets/icon_widgets/x_icon.dart';
import '../../../widgets/rounded_white_container.dart';
import '../../../widgets/stack_text_field.dart';
import '../../../widgets/textfield_icon_button.dart';
import '../../address_book_views/address_book_view.dart';
import '../../address_book_views/subviews/contact_popup.dart';
import '../choose_from_stack_view.dart';
import '../sub_widgets/step_row.dart';
import 'step_3_view.dart';

class Step2View extends ConsumerStatefulWidget {
  const Step2View({
    super.key,
    required this.model,
    this.clipboard = const ClipboardWrapper(),
    this.barcodeScanner = const BarcodeScannerWrapper(),
  });

  static const String routeName = "/exchangeStep2";

  final IncompleteExchangeModel model;
  final ClipboardInterface clipboard;
  final BarcodeScannerInterface barcodeScanner;

  @override
  ConsumerState<Step2View> createState() => _Step2ViewState();
}

class _Step2ViewState extends ConsumerState<Step2View> {
  late final IncompleteExchangeModel model;
  late final ClipboardInterface clipboard;
  late final BarcodeScannerInterface scanner;

  late final TextEditingController _toController;
  late final TextEditingController _refundController;

  late final FocusNode _toFocusNode;
  late final FocusNode _refundFocusNode;

  bool enableNext = false;

  void _onRefundQrTapped() async {
    try {
      final qrResult = await scanner.scan();

      final paymentData = AddressUtils.parsePaymentUri(
        qrResult.rawContent,
        logging: Logging.instance,
      );

      if (paymentData != null) {
        // auto fill address
        _refundController.text = paymentData.address;
        model.refundAddress = _refundController.text;

        setState(() {
          enableNext = _toController.text.isNotEmpty &&
              _refundController.text.isNotEmpty;
        });
      } else {
        _refundController.text = qrResult.rawContent;
        model.refundAddress = _refundController.text;

        setState(() {
          enableNext = _toController.text.isNotEmpty &&
              _refundController.text.isNotEmpty;
        });
      }
    } on PlatformException catch (e, s) {
      Logging.instance.log(
        "Failed to get camera permissions while trying to scan qr code in SendView: $e\n$s",
        level: LogLevel.Warning,
      );
    }
  }

  void _onToQrTapped() async {
    try {
      final qrResult = await scanner.scan();

      final paymentData = AddressUtils.parsePaymentUri(
        qrResult.rawContent,
        logging: Logging.instance,
      );

      if (paymentData != null) {
        // auto fill address
        _toController.text = paymentData.address;
        model.recipientAddress = _toController.text;

        setState(() {
          enableNext = _toController.text.isNotEmpty &&
              (_refundController.text.isNotEmpty ||
                  !ref.read(efExchangeProvider).supportsRefundAddress);
        });
      } else {
        _toController.text = qrResult.rawContent;
        model.recipientAddress = _toController.text;

        setState(() {
          enableNext = _toController.text.isNotEmpty &&
              (_refundController.text.isNotEmpty ||
                  !!ref.read(efExchangeProvider).supportsRefundAddress);
        });
      }
    } on PlatformException catch (e, s) {
      Logging.instance.log(
        "Failed to get camera permissions while trying to scan qr code in SendView: $e\n$s",
        level: LogLevel.Warning,
      );
    }
  }

  @override
  void initState() {
    model = widget.model;
    clipboard = widget.clipboard;
    scanner = widget.barcodeScanner;

    _toController = TextEditingController();
    _refundController = TextEditingController();

    _toFocusNode = FocusNode();
    _refundFocusNode = FocusNode();

    final tuple = ref.read(exchangeSendFromWalletIdStateProvider.state).state;
    if (tuple != null) {
      if (model.receiveTicker.toLowerCase() ==
          tuple.item2.ticker.toLowerCase()) {
        ref
            .read(pWallets)
            .getWallet(tuple.item1)
            .getCurrentReceivingAddress()
            .then((value) {
          _toController.text = value!.value;
          model.recipientAddress = _toController.text;
        });
      } else {
        if (model.sendTicker.toUpperCase() ==
            tuple.item2.ticker.toUpperCase()) {
          ref
              .read(pWallets)
              .getWallet(tuple.item1)
              .getCurrentReceivingAddress()
              .then((value) {
            _refundController.text = value!.value;
            model.refundAddress = _refundController.text;
          });
        }
      }
    }

    super.initState();
  }

  @override
  void dispose() {
    _toController.dispose();
    _refundController.dispose();

    _toFocusNode.dispose();
    _refundFocusNode.dispose();

    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final supportsRefund = ref.watch(efExchangeProvider).supportsRefundAddress;

    return Background(
      child: Scaffold(
        backgroundColor: Theme.of(context).extension<StackColors>()!.background,
        appBar: AppBar(
          leading: AppBarBackButton(
            onPressed: () async {
              if (FocusScope.of(context).hasFocus) {
                FocusScope.of(context).unfocus();
                await Future<void>.delayed(const Duration(milliseconds: 75));
              }
              if (context.mounted) {
                Navigator.of(context).pop();
              }
            },
          ),
          title: Text(
            "Swap",
            style: STextStyles.navBarTitle(context),
          ),
        ),
        body: LayoutBuilder(
          builder: (context, constraints) {
            final width = MediaQuery.of(context).size.width - 32;
            return Padding(
              padding: const EdgeInsets.all(12),
              child: SingleChildScrollView(
                child: ConstrainedBox(
                  constraints: BoxConstraints(
                    minHeight: constraints.maxHeight - 24,
                  ),
                  child: IntrinsicHeight(
                    child: Padding(
                      padding: const EdgeInsets.all(4),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.stretch,
                        children: [
                          StepRow(
                            count: 4,
                            current: 1,
                            width: width,
                          ),
                          const SizedBox(
                            height: 14,
                          ),
                          Text(
                            "Exchange details",
                            style: STextStyles.pageTitleH1(context),
                          ),
                          const SizedBox(
                            height: 8,
                          ),
                          Text(
                            "Enter your recipient and refund addresses",
                            style: STextStyles.itemSubtitle(context),
                          ),
                          const SizedBox(
                            height: 24,
                          ),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text(
                                "Recipient Wallet",
                                style: STextStyles.smallMed12(context),
                              ),
                              if (AppConfig.isStackCoin(model.receiveTicker))
                                CustomTextButton(
                                  text: "Choose from ${AppConfig.prefix}",
                                  onTap: () {
                                    try {
                                      final coin = AppConfig.coins.firstWhere(
                                        (e) =>
                                            e.ticker.toLowerCase() ==
                                            model.receiveTicker.toLowerCase(),
                                      );

                                      Navigator.of(context)
                                          .pushNamed(
                                        ChooseFromStackView.routeName,
                                        arguments: coin,
                                      )
                                          .then((value) async {
                                        if (value is String) {
                                          final wallet = ref
                                              .read(pWallets)
                                              .getWallet(value);

                                          _toController.text = wallet.info.name;
                                          model.recipientAddress = (await wallet
                                                      .getCurrentReceivingAddress())
                                                  ?.value ??
                                              wallet
                                                  .info.cachedReceivingAddress;

                                          setState(() {
                                            enableNext =
                                                _toController.text.isNotEmpty &&
                                                    (_refundController
                                                            .text.isNotEmpty ||
                                                        !supportsRefund);
                                          });
                                        }
                                      });
                                    } catch (e, s) {
                                      Logging.instance
                                          .log("$e\n$s", level: LogLevel.Info);
                                    }
                                  },
                                ),
                            ],
                          ),
                          const SizedBox(
                            height: 4,
                          ),
                          ClipRRect(
                            borderRadius: BorderRadius.circular(
                              Constants.size.circularBorderRadius,
                            ),
                            child: TextField(
                              onTap: () {},
                              key: const Key(
                                "recipientExchangeStep2ViewAddressFieldKey",
                              ),
                              controller: _toController,
                              readOnly: false,
                              autocorrect: false,
                              enableSuggestions: false,
                              // inputFormatters: <TextInputFormatter>[
                              //   FilteringTextInputFormatter.allow(RegExp("[a-zA-Z0-9]{34}")),
                              // ],
                              toolbarOptions: const ToolbarOptions(
                                copy: false,
                                cut: false,
                                paste: true,
                                selectAll: false,
                              ),
                              focusNode: _toFocusNode,
                              style: STextStyles.field(context),
                              onChanged: (value) {
                                model.recipientAddress = _toController.text;
                                setState(() {
                                  enableNext = _toController.text.isNotEmpty &&
                                      (_refundController.text.isNotEmpty ||
                                          !supportsRefund);
                                });
                              },
                              decoration: standardInputDecoration(
                                "Enter the ${model.receiveTicker.toUpperCase()} payout address",
                                _toFocusNode,
                                context,
                              ).copyWith(
                                contentPadding: const EdgeInsets.only(
                                  left: 16,
                                  top: 6,
                                  bottom: 8,
                                  right: 5,
                                ),
                                suffixIcon: Padding(
                                  padding: _toController.text.isEmpty
                                      ? const EdgeInsets.only(right: 8)
                                      : const EdgeInsets.only(right: 0),
                                  child: UnconstrainedBox(
                                    child: Row(
                                      mainAxisAlignment:
                                          MainAxisAlignment.spaceAround,
                                      children: [
                                        _toController.text.isNotEmpty
                                            ? TextFieldIconButton(
                                                key: const Key(
                                                  "sendViewClearAddressFieldButtonKey",
                                                ),
                                                onTap: () {
                                                  _toController.text = "";
                                                  model.recipientAddress =
                                                      _toController.text;

                                                  setState(() {
                                                    enableNext = _toController
                                                            .text.isNotEmpty &&
                                                        (_refundController.text
                                                                .isNotEmpty ||
                                                            !supportsRefund);
                                                  });
                                                },
                                                child: const XIcon(),
                                              )
                                            : TextFieldIconButton(
                                                key: const Key(
                                                  "sendViewPasteAddressFieldButtonKey",
                                                ),
                                                onTap: () async {
                                                  final ClipboardData? data =
                                                      await clipboard.getData(
                                                    Clipboard.kTextPlain,
                                                  );
                                                  if (data?.text != null &&
                                                      data!.text!.isNotEmpty) {
                                                    final content =
                                                        data.text!.trim();

                                                    _toController.text =
                                                        content;
                                                    model.recipientAddress =
                                                        _toController.text;

                                                    setState(() {
                                                      enableNext = _toController
                                                              .text
                                                              .isNotEmpty &&
                                                          (_refundController
                                                                  .text
                                                                  .isNotEmpty ||
                                                              !supportsRefund);
                                                    });
                                                  }
                                                },
                                                child:
                                                    _toController.text.isEmpty
                                                        ? const ClipboardIcon()
                                                        : const XIcon(),
                                              ),
                                        if (_toController.text.isEmpty)
                                          TextFieldIconButton(
                                            key: const Key(
                                              "sendViewAddressBookButtonKey",
                                            ),
                                            onTap: () {
                                              ref
                                                  .read(
                                                    exchangeFlowIsActiveStateProvider
                                                        .state,
                                                  )
                                                  .state = true;
                                              Navigator.of(context)
                                                  .pushNamed(
                                                AddressBookView.routeName,
                                              )
                                                  .then((_) {
                                                ref
                                                    .read(
                                                      exchangeFlowIsActiveStateProvider
                                                          .state,
                                                    )
                                                    .state = false;

                                                final address = ref
                                                    .read(
                                                      exchangeFromAddressBookAddressStateProvider
                                                          .state,
                                                    )
                                                    .state;
                                                if (address.isNotEmpty) {
                                                  _toController.text = address;
                                                  model.recipientAddress =
                                                      _toController.text;
                                                  ref
                                                      .read(
                                                        exchangeFromAddressBookAddressStateProvider
                                                            .state,
                                                      )
                                                      .state = "";
                                                }
                                                setState(() {
                                                  enableNext = _toController
                                                          .text.isNotEmpty &&
                                                      (_refundController.text
                                                              .isNotEmpty ||
                                                          !supportsRefund);
                                                });
                                              });
                                            },
                                            child: const AddressBookIcon(),
                                          ),
                                        if (_toController.text.isEmpty)
                                          TextFieldIconButton(
                                            key: const Key(
                                              "sendViewScanQrButtonKey",
                                            ),
                                            onTap: _onToQrTapped,
                                            child: const QrCodeIcon(),
                                          ),
                                      ],
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(
                            height: 6,
                          ),
                          RoundedWhiteContainer(
                            child: Text(
                              "This is the wallet where your ${model.receiveTicker.toUpperCase()} will be sent to.",
                              style: STextStyles.label(context),
                            ),
                          ),
                          const SizedBox(
                            height: 24,
                          ),
                          if (supportsRefund)
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text(
                                  "Refund Wallet (required)",
                                  style: STextStyles.smallMed12(context),
                                ),
                                if (AppConfig.isStackCoin(model.sendTicker))
                                  CustomTextButton(
                                    text: "Choose from ${AppConfig.prefix}",
                                    onTap: () {
                                      try {
                                        final coin = AppConfig.coins.firstWhere(
                                          (e) =>
                                              e.ticker.toLowerCase() ==
                                              model.sendTicker.toLowerCase(),
                                        );

                                        Navigator.of(context)
                                            .pushNamed(
                                          ChooseFromStackView.routeName,
                                          arguments: coin,
                                        )
                                            .then((value) async {
                                          if (value is String) {
                                            final wallet = ref
                                                .read(pWallets)
                                                .getWallet(value);

                                            _refundController.text =
                                                wallet.info.name;
                                            model.refundAddress = (await wallet
                                                    .getCurrentReceivingAddress())!
                                                .value;
                                          }
                                          setState(() {
                                            enableNext =
                                                _toController.text.isNotEmpty &&
                                                    _refundController
                                                        .text.isNotEmpty;
                                          });
                                        });
                                      } catch (e, s) {
                                        Logging.instance.log(
                                          "$e\n$s",
                                          level: LogLevel.Info,
                                        );
                                      }
                                    },
                                  ),
                              ],
                            ),
                          if (supportsRefund)
                            const SizedBox(
                              height: 4,
                            ),
                          if (supportsRefund)
                            ClipRRect(
                              borderRadius: BorderRadius.circular(
                                Constants.size.circularBorderRadius,
                              ),
                              child: TextField(
                                key: const Key(
                                  "refundExchangeStep2ViewAddressFieldKey",
                                ),
                                controller: _refundController,
                                readOnly: false,
                                autocorrect: false,
                                enableSuggestions: false,
                                // inputFormatters: <TextInputFormatter>[
                                //   FilteringTextInputFormatter.allow(RegExp("[a-zA-Z0-9]{34}")),
                                // ],
                                toolbarOptions: const ToolbarOptions(
                                  copy: false,
                                  cut: false,
                                  paste: true,
                                  selectAll: false,
                                ),
                                focusNode: _refundFocusNode,
                                style: STextStyles.field(context),
                                onChanged: (value) {
                                  model.refundAddress = _refundController.text;
                                  setState(() {
                                    enableNext =
                                        _toController.text.isNotEmpty &&
                                            _refundController.text.isNotEmpty;
                                  });
                                },
                                decoration: standardInputDecoration(
                                  "Enter ${model.sendTicker.toUpperCase()} refund address",
                                  _refundFocusNode,
                                  context,
                                ).copyWith(
                                  contentPadding: const EdgeInsets.only(
                                    left: 16,
                                    top: 6,
                                    bottom: 8,
                                    right: 5,
                                  ),
                                  suffixIcon: Padding(
                                    padding: _refundController.text.isEmpty
                                        ? const EdgeInsets.only(right: 16)
                                        : const EdgeInsets.only(right: 0),
                                    child: UnconstrainedBox(
                                      child: Row(
                                        mainAxisAlignment:
                                            MainAxisAlignment.spaceAround,
                                        children: [
                                          _refundController.text.isNotEmpty
                                              ? TextFieldIconButton(
                                                  key: const Key(
                                                    "sendViewClearAddressFieldButtonKey",
                                                  ),
                                                  onTap: () {
                                                    _refundController.text = "";
                                                    model.refundAddress =
                                                        _refundController.text;

                                                    setState(() {
                                                      enableNext = _toController
                                                              .text
                                                              .isNotEmpty &&
                                                          _refundController
                                                              .text.isNotEmpty;
                                                    });
                                                  },
                                                  child: const XIcon(),
                                                )
                                              : TextFieldIconButton(
                                                  key: const Key(
                                                    "sendViewPasteAddressFieldButtonKey",
                                                  ),
                                                  onTap: () async {
                                                    final ClipboardData? data =
                                                        await clipboard.getData(
                                                      Clipboard.kTextPlain,
                                                    );
                                                    if (data?.text != null &&
                                                        data!
                                                            .text!.isNotEmpty) {
                                                      final content =
                                                          data.text!.trim();

                                                      _refundController.text =
                                                          content;
                                                      model.refundAddress =
                                                          _refundController
                                                              .text;

                                                      setState(() {
                                                        enableNext = _toController
                                                                .text
                                                                .isNotEmpty &&
                                                            _refundController
                                                                .text
                                                                .isNotEmpty;
                                                      });
                                                    }
                                                  },
                                                  child: _refundController
                                                          .text.isEmpty
                                                      ? const ClipboardIcon()
                                                      : const XIcon(),
                                                ),
                                          if (_refundController.text.isEmpty)
                                            TextFieldIconButton(
                                              key: const Key(
                                                "sendViewAddressBookButtonKey",
                                              ),
                                              onTap: () {
                                                ref
                                                    .read(
                                                      exchangeFlowIsActiveStateProvider
                                                          .state,
                                                    )
                                                    .state = true;
                                                Navigator.of(context)
                                                    .pushNamed(
                                                  AddressBookView.routeName,
                                                )
                                                    .then((_) {
                                                  ref
                                                      .read(
                                                        exchangeFlowIsActiveStateProvider
                                                            .state,
                                                      )
                                                      .state = false;
                                                  final address = ref
                                                      .read(
                                                        exchangeFromAddressBookAddressStateProvider
                                                            .state,
                                                      )
                                                      .state;
                                                  if (address.isNotEmpty) {
                                                    _refundController.text =
                                                        address;
                                                    model.refundAddress =
                                                        _refundController.text;
                                                  }
                                                  setState(() {
                                                    enableNext = _toController
                                                            .text.isNotEmpty &&
                                                        _refundController
                                                            .text.isNotEmpty;
                                                  });
                                                });
                                              },
                                              child: const AddressBookIcon(),
                                            ),
                                          if (_refundController.text.isEmpty)
                                            TextFieldIconButton(
                                              key: const Key(
                                                "sendViewScanQrButtonKey",
                                              ),
                                              onTap: _onRefundQrTapped,
                                              child: const QrCodeIcon(),
                                            ),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          if (supportsRefund)
                            const SizedBox(
                              height: 6,
                            ),
                          if (supportsRefund)
                            RoundedWhiteContainer(
                              child: Text(
                                "In case something goes wrong during the exchange, we might need a refund address so we can return your coins back to you.",
                                style: STextStyles.label(context),
                              ),
                            ),
                          const SizedBox(
                            height: 16,
                          ),
                          const Spacer(),
                          Row(
                            children: [
                              Expanded(
                                child: TextButton(
                                  onPressed: () {
                                    Navigator.of(context).pop();
                                  },
                                  style: Theme.of(context)
                                      .extension<StackColors>()!
                                      .getSecondaryEnabledButtonStyle(context),
                                  child: Text(
                                    "Back",
                                    style: STextStyles.button(context).copyWith(
                                      color: Theme.of(context)
                                          .extension<StackColors>()!
                                          .buttonTextSecondary,
                                    ),
                                  ),
                                ),
                              ),
                              const SizedBox(
                                width: 16,
                              ),
                              Expanded(
                                child: PrimaryButton(
                                  label: "Next",
                                  enabled: enableNext,
                                  onPressed: () {
                                    Navigator.of(context).pushNamed(
                                      Step3View.routeName,
                                      arguments: model,
                                    );
                                  },
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}
