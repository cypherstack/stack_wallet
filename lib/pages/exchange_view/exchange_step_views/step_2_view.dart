/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../app_config.dart';
import '../../../models/exchange/incomplete_exchange.dart';
import '../../../providers/providers.dart';
import '../../../themes/stack_colors.dart';
import '../../../utilities/address_utils.dart';
import '../../../utilities/barcode_scanner_interface.dart';
import '../../../utilities/clipboard_interface.dart';
import '../../../utilities/constants.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/text_styles.dart';
import '../../../widgets/background.dart';
import '../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../widgets/custom_buttons/blue_text_button.dart';
import '../../../widgets/desktop/primary_button.dart';
import '../../../widgets/icon_widgets/addressbook_icon.dart';
import '../../../widgets/icon_widgets/clipboard_icon.dart';
import '../../../widgets/icon_widgets/qrcode_icon.dart';
import '../../../widgets/icon_widgets/x_icon.dart';
import '../../../widgets/rounded_white_container.dart';
import '../../../widgets/stack_text_field.dart';
import '../../../widgets/textfield_icon_button.dart';
import '../../address_book_views/address_book_view.dart';
import '../../address_book_views/subviews/contact_popup.dart';
import '../choose_from_stack_view.dart';
import '../sub_widgets/step_row.dart';
import 'step_3_view.dart';

class Step2View extends ConsumerStatefulWidget {
  const Step2View({
    super.key,
    required this.model,
    this.clipboard = const ClipboardWrapper(),
  });

  static const String routeName = "/exchangeStep2";

  final IncompleteExchangeModel model;
  final ClipboardInterface clipboard;

  @override
  ConsumerState<Step2View> createState() => _Step2ViewState();
}

class _Step2ViewState extends ConsumerState<Step2View> {
  late final IncompleteExchangeModel model;
  late final ClipboardInterface clipboard;

  late final TextEditingController _toController;
  late final TextEditingController _refundController;

  late final FocusNode _toFocusNode;
  late final FocusNode _refundFocusNode;

  bool enableNext = false;

  void _onRefundQrTapped() async {
    try {
      final qrResult = await ref.read(pBarcodeScanner).scan(context: context);

      final paymentData = AddressUtils.parsePaymentUri(
        qrResult.rawContent,
        logging: Logging.instance,
      );

      if (paymentData != null) {
        // auto fill address
        _refundController.text = paymentData.address;
        model.refundAddress = _refundController.text;

        setState(() {
          enableNext =
              _toController.text.isNotEmpty &&
              _refundController.text.isNotEmpty;
        });
      } else {
        _refundController.text = qrResult.rawContent;
        model.refundAddress = _refundController.text;

        setState(() {
          enableNext =
              _toController.text.isNotEmpty &&
              _refundController.text.isNotEmpty;
        });
      }
    } on PlatformException catch (e, s) {
      if (mounted) {
        try {
          await checkCamPermDeniedMobileAndOpenAppSettings(
            context,
            logging: Logging.instance,
          );
        } catch (e, s) {
          Logging.instance.e(
            "Failed to check cam permissions",
            error: e,
            stackTrace: s,
          );
        }
      } else {
        Logging.instance.w(
          "Failed to get camera permissions while trying to scan qr code in $runtimeType: ",
          error: e,
          stackTrace: s,
        );
      }
    }
  }

  void _onToQrTapped() async {
    try {
      final qrResult = await ref.read(pBarcodeScanner).scan(context: context);

      final paymentData = AddressUtils.parsePaymentUri(
        qrResult.rawContent,
        logging: Logging.instance,
      );

      if (paymentData != null) {
        // auto fill address
        _toController.text = paymentData.address;
        model.recipientAddress = _toController.text;

        setState(() {
          enableNext =
              _toController.text.isNotEmpty &&
              (_refundController.text.isNotEmpty ||
                  !ref.read(efExchangeProvider).supportsRefundAddress);
        });
      } else {
        _toController.text = qrResult.rawContent;
        model.recipientAddress = _toController.text;

        setState(() {
          enableNext =
              _toController.text.isNotEmpty &&
              (_refundController.text.isNotEmpty ||
                  !!ref.read(efExchangeProvider).supportsRefundAddress);
        });
      }
    } on PlatformException catch (e, s) {
      if (mounted) {
        try {
          await checkCamPermDeniedMobileAndOpenAppSettings(
            context,
            logging: Logging.instance,
          );
        } catch (e, s) {
          Logging.instance.e(
            "Failed to check cam permissions",
            error: e,
            stackTrace: s,
          );
        }
      } else {
        Logging.instance.w(
          "Failed to get camera permissions while trying to scan qr code in $runtimeType: ",
          error: e,
          stackTrace: s,
        );
      }
    }
  }

  @override
  void initState() {
    model = widget.model;
    clipboard = widget.clipboard;

    _toController = TextEditingController();
    _refundController = TextEditingController();

    _toFocusNode = FocusNode();
    _refundFocusNode = FocusNode();

    final tuple = ref.read(exchangeSendFromWalletIdStateProvider.state).state;
    if (tuple != null) {
      if (model.receiveTicker.toLowerCase() ==
          tuple.item2.ticker.toLowerCase()) {
        ref
            .read(pWallets)
            .getWallet(tuple.item1)
            .getCurrentReceivingAddress()
            .then((value) {
              _toController.text = value!.value;
              model.recipientAddress = _toController.text;
            });
      } else {
        if (model.sendTicker.toUpperCase() ==
            tuple.item2.ticker.toUpperCase()) {
          ref
              .read(pWallets)
              .getWallet(tuple.item1)
              .getCurrentReceivingAddress()
              .then((value) {
                _refundController.text = value!.value;
                model.refundAddress = _refundController.text;
              });
        }
      }
    }

    super.initState();
  }

  @override
  void dispose() {
    _toController.dispose();
    _refundController.dispose();

    _toFocusNode.dispose();
    _refundFocusNode.dispose();

    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final supportsRefund = ref.watch(efExchangeProvider).supportsRefundAddress;

    return Background(
      child: Scaffold(
        backgroundColor: Theme.of(context).extension<StackColors>()!.background,
        appBar: AppBar(
          leading: AppBarBackButton(
            onPressed: () async {
              if (FocusScope.of(context).hasFocus) {
                FocusScope.of(context).unfocus();
                await Future<void>.delayed(const Duration(milliseconds: 75));
              }
              if (context.mounted) {
                Navigator.of(context).pop();
              }
            },
          ),
          title: Text("Swap", style: STextStyles.navBarTitle(context)),
        ),
        body: SafeArea(
          child: LayoutBuilder(
            builder: (context, constraints) {
              final width = MediaQuery.of(context).size.width - 32;
              return Padding(
                padding: const EdgeInsets.all(12),
                child: SingleChildScrollView(
                  child: ConstrainedBox(
                    constraints: BoxConstraints(
                      minHeight: constraints.maxHeight - 24,
                    ),
                    child: IntrinsicHeight(
                      child: Padding(
                        padding: const EdgeInsets.all(4),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            StepRow(count: 4, current: 1, width: width),
                            const SizedBox(height: 14),
                            Text(
                              "Exchange details",
                              style: STextStyles.pageTitleH1(context),
                            ),
                            const SizedBox(height: 8),
                            Text(
                              "Enter your recipient and refund addresses",
                              style: STextStyles.itemSubtitle(context),
                            ),
                            const SizedBox(height: 24),
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text(
                                  "Recipient Wallet",
                                  style: STextStyles.smallMed12(context),
                                ),
                                if (AppConfig.isStackCoin(model.receiveTicker))
                                  CustomTextButton(
                                    text: "Choose from ${AppConfig.prefix}",
                                    onTap: () {
                                      try {
                                        final coin = AppConfig.coins.firstWhere(
                                          (e) =>
                                              e.ticker.toLowerCase() ==
                                              model.receiveTicker.toLowerCase(),
                                        );

                                        Navigator.of(context)
                                            .pushNamed(
                                              ChooseFromStackView.routeName,
                                              arguments: coin,
                                            )
                                            .then((value) async {
                                              if (value is String) {
                                                final wallet = ref
                                                    .read(pWallets)
                                                    .getWallet(value);

                                                _toController.text =
                                                    wallet.info.name;
                                                model.recipientAddress =
                                                    (await wallet
                                                            .getCurrentReceivingAddress())
                                                        ?.value ??
                                                    wallet
                                                        .info
                                                        .cachedReceivingAddress;

                                                setState(() {
                                                  enableNext =
                                                      _toController
                                                          .text
                                                          .isNotEmpty &&
                                                      (_refundController
                                                              .text
                                                              .isNotEmpty ||
                                                          !supportsRefund);
                                                });
                                              }
                                            });
                                      } catch (e, s) {
                                        Logging.instance.e(
                                          "",
                                          error: e,
                                          stackTrace: s,
                                        );
                                      }
                                    },
                                  ),
                              ],
                            ),
                            const SizedBox(height: 4),
                            ClipRRect(
                              borderRadius: BorderRadius.circular(
                                Constants.size.circularBorderRadius,
                              ),
                              child: TextField(
                                onTap: () {},
                                key: const Key(
                                  "recipientExchangeStep2ViewAddressFieldKey",
                                ),
                                controller: _toController,
                                readOnly: false,
                                autocorrect: false,
                                enableSuggestions: false,
                                // inputFormatters: <TextInputFormatter>[
                                //   FilteringTextInputFormatter.allow(RegExp("[a-zA-Z0-9]{34}")),
                                // ],
                                toolbarOptions: const ToolbarOptions(
                                  copy: false,
                                  cut: false,
                                  paste: true,
                                  selectAll: false,
                                ),
                                focusNode: _toFocusNode,
                                style: STextStyles.field(context),
                                onChanged: (value) {
                                  model.recipientAddress = _toController.text;
                                  setState(() {
                                    enableNext =
                                        _toController.text.isNotEmpty &&
                                        (_refundController.text.isNotEmpty ||
                                            !supportsRefund);
                                  });
                                },
                                decoration: standardInputDecoration(
                                  "Enter the ${model.receiveTicker.toUpperCase()} payout address",
                                  _toFocusNode,
                                  context,
                                ).copyWith(
                                  contentPadding: const EdgeInsets.only(
                                    left: 16,
                                    top: 6,
                                    bottom: 8,
                                    right: 5,
                                  ),
                                  suffixIcon: Padding(
                                    padding:
                                        _toController.text.isEmpty
                                            ? const EdgeInsets.only(right: 8)
                                            : const EdgeInsets.only(right: 0),
                                    child: UnconstrainedBox(
                                      child: Row(
                                        mainAxisAlignment:
                                            MainAxisAlignment.spaceAround,
                                        children: [
                                          _toController.text.isNotEmpty
                                              ? TextFieldIconButton(
                                                key: const Key(
                                                  "sendViewClearAddressFieldButtonKey",
                                                ),
                                                onTap: () {
                                                  _toController.text = "";
                                                  model.recipientAddress =
                                                      _toController.text;

                                                  setState(() {
                                                    enableNext =
                                                        _toController
                                                            .text
                                                            .isNotEmpty &&
                                                        (_refundController
                                                                .text
                                                                .isNotEmpty ||
                                                            !supportsRefund);
                                                  });
                                                },
                                                child: const XIcon(),
                                              )
                                              : TextFieldIconButton(
                                                key: const Key(
                                                  "sendViewPasteAddressFieldButtonKey",
                                                ),
                                                onTap: () async {
                                                  final ClipboardData? data =
                                                      await clipboard.getData(
                                                        Clipboard.kTextPlain,
                                                      );
                                                  if (data?.text != null &&
                                                      data!.text!.isNotEmpty) {
                                                    final content =
                                                        data.text!.trim();

                                                    _toController.text =
                                                        content;
                                                    model.recipientAddress =
                                                        _toController.text;

                                                    setState(() {
                                                      enableNext =
                                                          _toController
                                                              .text
                                                              .isNotEmpty &&
                                                          (_refundController
                                                                  .text
                                                                  .isNotEmpty ||
                                                              !supportsRefund);
                                                    });
                                                  }
                                                },
                                                child:
                                                    _toController.text.isEmpty
                                                        ? const ClipboardIcon()
                                                        : const XIcon(),
                                              ),
                                          if (_toController.text.isEmpty)
                                            TextFieldIconButton(
                                              key: const Key(
                                                "sendViewAddressBookButtonKey",
                                              ),
                                              onTap: () {
                                                ref
                                                    .read(
                                                      exchangeFlowIsActiveStateProvider
                                                          .state,
                                                    )
                                                    .state = true;
                                                Navigator.of(
                                                  context,
                                                ).pushNamed(AddressBookView.routeName).then((
                                                  _,
                                                ) {
                                                  ref
                                                      .read(
                                                        exchangeFlowIsActiveStateProvider
                                                            .state,
                                                      )
                                                      .state = false;

                                                  final address =
                                                      ref
                                                          .read(
                                                            exchangeFromAddressBookAddressStateProvider
                                                                .state,
                                                          )
                                                          .state;
                                                  if (address.isNotEmpty) {
                                                    _toController.text =
                                                        address;
                                                    model.recipientAddress =
                                                        _toController.text;
                                                    ref
                                                        .read(
                                                          exchangeFromAddressBookAddressStateProvider
                                                              .state,
                                                        )
                                                        .state = "";
                                                  }
                                                  setState(() {
                                                    enableNext =
                                                        _toController
                                                            .text
                                                            .isNotEmpty &&
                                                        (_refundController
                                                                .text
                                                                .isNotEmpty ||
                                                            !supportsRefund);
                                                  });
                                                });
                                              },
                                              child: const AddressBookIcon(),
                                            ),
                                          if (_toController.text.isEmpty)
                                            TextFieldIconButton(
                                              key: const Key(
                                                "sendViewScanQrButtonKey",
                                              ),
                                              onTap: _onToQrTapped,
                                              child: const QrCodeIcon(),
                                            ),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(height: 6),
                            RoundedWhiteContainer(
                              child: Text(
                                "This is the wallet where your ${model.receiveTicker.toUpperCase()} will be sent to.",
                                style: STextStyles.label(context),
                              ),
                            ),
                            const SizedBox(height: 24),
                            if (supportsRefund)
                              Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                children: [
                                  Text(
                                    "Refund Wallet (required)",
                                    style: STextStyles.smallMed12(context),
                                  ),
                                  if (AppConfig.isStackCoin(model.sendTicker))
                                    CustomTextButton(
                                      text: "Choose from ${AppConfig.prefix}",
                                      onTap: () {
                                        try {
                                          final coin = AppConfig.coins
                                              .firstWhere(
                                                (e) =>
                                                    e.ticker.toLowerCase() ==
                                                    model.sendTicker
                                                        .toLowerCase(),
                                              );

                                          Navigator.of(context)
                                              .pushNamed(
                                                ChooseFromStackView.routeName,
                                                arguments: coin,
                                              )
                                              .then((value) async {
                                                if (value is String) {
                                                  final wallet = ref
                                                      .read(pWallets)
                                                      .getWallet(value);

                                                  _refundController.text =
                                                      wallet.info.name;
                                                  model.refundAddress =
                                                      (await wallet
                                                              .getCurrentReceivingAddress())!
                                                          .value;
                                                }
                                                setState(() {
                                                  enableNext =
                                                      _toController
                                                          .text
                                                          .isNotEmpty &&
                                                      _refundController
                                                          .text
                                                          .isNotEmpty;
                                                });
                                              });
                                        } catch (e, s) {
                                          Logging.instance.i(
                                            "$e\n$s",
                                            error: e,
                                            stackTrace: s,
                                          );
                                        }
                                      },
                                    ),
                                ],
                              ),
                            if (supportsRefund) const SizedBox(height: 4),
                            if (supportsRefund)
                              ClipRRect(
                                borderRadius: BorderRadius.circular(
                                  Constants.size.circularBorderRadius,
                                ),
                                child: TextField(
                                  key: const Key(
                                    "refundExchangeStep2ViewAddressFieldKey",
                                  ),
                                  controller: _refundController,
                                  readOnly: false,
                                  autocorrect: false,
                                  enableSuggestions: false,
                                  // inputFormatters: <TextInputFormatter>[
                                  //   FilteringTextInputFormatter.allow(RegExp("[a-zA-Z0-9]{34}")),
                                  // ],
                                  toolbarOptions: const ToolbarOptions(
                                    copy: false,
                                    cut: false,
                                    paste: true,
                                    selectAll: false,
                                  ),
                                  focusNode: _refundFocusNode,
                                  style: STextStyles.field(context),
                                  onChanged: (value) {
                                    model.refundAddress =
                                        _refundController.text;
                                    setState(() {
                                      enableNext =
                                          _toController.text.isNotEmpty &&
                                          _refundController.text.isNotEmpty;
                                    });
                                  },
                                  decoration: standardInputDecoration(
                                    "Enter ${model.sendTicker.toUpperCase()} refund address",
                                    _refundFocusNode,
                                    context,
                                  ).copyWith(
                                    contentPadding: const EdgeInsets.only(
                                      left: 16,
                                      top: 6,
                                      bottom: 8,
                                      right: 5,
                                    ),
                                    suffixIcon: Padding(
                                      padding:
                                          _refundController.text.isEmpty
                                              ? const EdgeInsets.only(right: 16)
                                              : const EdgeInsets.only(right: 0),
                                      child: UnconstrainedBox(
                                        child: Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.spaceAround,
                                          children: [
                                            _refundController.text.isNotEmpty
                                                ? TextFieldIconButton(
                                                  key: const Key(
                                                    "sendViewClearAddressFieldButtonKey",
                                                  ),
                                                  onTap: () {
                                                    _refundController.text = "";
                                                    model.refundAddress =
                                                        _refundController.text;

                                                    setState(() {
                                                      enableNext =
                                                          _toController
                                                              .text
                                                              .isNotEmpty &&
                                                          _refundController
                                                              .text
                                                              .isNotEmpty;
                                                    });
                                                  },
                                                  child: const XIcon(),
                                                )
                                                : TextFieldIconButton(
                                                  key: const Key(
                                                    "sendViewPasteAddressFieldButtonKey",
                                                  ),
                                                  onTap: () async {
                                                    final ClipboardData? data =
                                                        await clipboard.getData(
                                                          Clipboard.kTextPlain,
                                                        );
                                                    if (data?.text != null &&
                                                        data!
                                                            .text!
                                                            .isNotEmpty) {
                                                      final content =
                                                          data.text!.trim();

                                                      _refundController.text =
                                                          content;
                                                      model.refundAddress =
                                                          _refundController
                                                              .text;

                                                      setState(() {
                                                        enableNext =
                                                            _toController
                                                                .text
                                                                .isNotEmpty &&
                                                            _refundController
                                                                .text
                                                                .isNotEmpty;
                                                      });
                                                    }
                                                  },
                                                  child:
                                                      _refundController
                                                              .text
                                                              .isEmpty
                                                          ? const ClipboardIcon()
                                                          : const XIcon(),
                                                ),
                                            if (_refundController.text.isEmpty)
                                              TextFieldIconButton(
                                                key: const Key(
                                                  "sendViewAddressBookButtonKey",
                                                ),
                                                onTap: () {
                                                  ref
                                                      .read(
                                                        exchangeFlowIsActiveStateProvider
                                                            .state,
                                                      )
                                                      .state = true;
                                                  Navigator.of(context)
                                                      .pushNamed(
                                                        AddressBookView
                                                            .routeName,
                                                      )
                                                      .then((_) {
                                                        ref
                                                            .read(
                                                              exchangeFlowIsActiveStateProvider
                                                                  .state,
                                                            )
                                                            .state = false;
                                                        final address =
                                                            ref
                                                                .read(
                                                                  exchangeFromAddressBookAddressStateProvider
                                                                      .state,
                                                                )
                                                                .state;
                                                        if (address
                                                            .isNotEmpty) {
                                                          _refundController
                                                              .text = address;
                                                          model.refundAddress =
                                                              _refundController
                                                                  .text;
                                                        }
                                                        setState(() {
                                                          enableNext =
                                                              _toController
                                                                  .text
                                                                  .isNotEmpty &&
                                                              _refundController
                                                                  .text
                                                                  .isNotEmpty;
                                                        });
                                                      });
                                                },
                                                child: const AddressBookIcon(),
                                              ),
                                            if (_refundController.text.isEmpty)
                                              TextFieldIconButton(
                                                key: const Key(
                                                  "sendViewScanQrButtonKey",
                                                ),
                                                onTap: _onRefundQrTapped,
                                                child: const QrCodeIcon(),
                                              ),
                                          ],
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            if (supportsRefund) const SizedBox(height: 6),
                            if (supportsRefund)
                              RoundedWhiteContainer(
                                child: Text(
                                  "In case something goes wrong during the exchange, we might need a refund address so we can return your coins back to you.",
                                  style: STextStyles.label(context),
                                ),
                              ),
                            const SizedBox(height: 16),
                            const Spacer(),
                            Row(
                              children: [
                                Expanded(
                                  child: TextButton(
                                    onPressed: () {
                                      Navigator.of(context).pop();
                                    },
                                    style: Theme.of(context)
                                        .extension<StackColors>()!
                                        .getSecondaryEnabledButtonStyle(
                                          context,
                                        ),
                                    child: Text(
                                      "Back",
                                      style: STextStyles.button(
                                        context,
                                      ).copyWith(
                                        color:
                                            Theme.of(context)
                                                .extension<StackColors>()!
                                                .buttonTextSecondary,
                                      ),
                                    ),
                                  ),
                                ),
                                const SizedBox(width: 16),
                                Expanded(
                                  child: PrimaryButton(
                                    label: "Next",
                                    enabled: enableNext,
                                    onPressed: () {
                                      Navigator.of(context).pushNamed(
                                        Step3View.routeName,
                                        arguments: model,
                                      );
                                    },
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}
