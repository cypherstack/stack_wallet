/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:isar/isar.dart';
import 'package:tuple/tuple.dart';

import '../../../app_config.dart';
import '../../../models/exchange/aggregate_currency.dart';
import '../../../models/isar/exchange_cache/currency.dart';
import '../../../models/isar/exchange_cache/pair.dart';
import '../../../services/exchange/exchange.dart';
import '../../../services/exchange/exchange_data_loading_service.dart';
import '../../../themes/stack_colors.dart';
import '../../../utilities/assets.dart';
import '../../../utilities/constants.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/prefs.dart';
import '../../../utilities/text_styles.dart';
import '../../../utilities/util.dart';
import '../../../widgets/background.dart';
import '../../../widgets/coin_ticker_tag.dart';
import '../../../widgets/conditional_parent.dart';
import '../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../widgets/custom_loading_overlay.dart';
import '../../../widgets/icon_widgets/x_icon.dart';
import '../../../widgets/loading_indicator.dart';
import '../../../widgets/rounded_white_container.dart';
import '../../../widgets/stack_text_field.dart';
import '../../../widgets/textfield_icon_button.dart';
import '../../buy_view/sub_widgets/crypto_selection_view.dart';

class ExchangeCurrencySelectionView extends StatefulWidget {
  const ExchangeCurrencySelectionView({
    super.key,
    required this.pairedCurrency,
    required this.isFixedRate,
    required this.willChangeIsSend,
  });

  final AggregateCurrency? pairedCurrency;
  final bool isFixedRate;
  final bool willChangeIsSend;

  @override
  State<ExchangeCurrencySelectionView> createState() =>
      _ExchangeCurrencySelectionViewState();
}

class _ExchangeCurrencySelectionViewState
    extends State<ExchangeCurrencySelectionView> {
  late TextEditingController _searchController;
  final _searchFocusNode = FocusNode();
  final isDesktop = Util.isDesktop;

  List<AggregateCurrency> _currencies = [];

  bool _loaded = false;
  String _searchString = "";

  Future<T> _showUpdatingCurrencies<T>({required Future<T> whileFuture}) async {
    unawaited(
      showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder:
            (_) => WillPopScope(
              onWillPop: () async => false,
              child: Container(
                color: Theme.of(
                  context,
                ).extension<StackColors>()!.overlay.withOpacity(0.6),
                child: const CustomLoadingOverlay(
                  message: "Loading currencies",
                  eventBus: null,
                ),
              ),
            ),
      ),
    );

    final result = await whileFuture;

    if (mounted) {
      Navigator.of(context, rootNavigator: isDesktop).pop();
    }

    return result;
  }

  Future<List<AggregateCurrency>> _loadCurrencies() async {
    await ExchangeDataLoadingService.instance.initDB();
    final currencies =
        await ExchangeDataLoadingService.instance.isar.currencies
            .where()
            .filter()
            .isFiatEqualTo(false)
            .and()
            .group(
              (q) =>
                  widget.isFixedRate
                      ? q
                          .rateTypeEqualTo(SupportedRateType.both)
                          .or()
                          .rateTypeEqualTo(SupportedRateType.fixed)
                      : q
                          .rateTypeEqualTo(SupportedRateType.both)
                          .or()
                          .rateTypeEqualTo(SupportedRateType.estimated),
            )
            .sortByIsStackCoin()
            .thenByName()
            .findAll();

    // If using Tor, filter exchanges which do not support Tor.
    if (Prefs.instance.useTor) {
      if (Exchange.exchangeNamesWithTorSupport.isNotEmpty) {
        currencies.removeWhere(
          (element) =>
              !Exchange.exchangeNamesWithTorSupport.contains(
                element.exchangeName,
              ),
        );
      }
    }

    return await _getDistinctCurrenciesFrom(currencies);
  }

  Future<List<AggregateCurrency>> _getDistinctCurrenciesFrom(
    List<Currency> currencies,
  ) async {
    final Map<String, List<Currency>> groups = {};

    for (final currency in currencies) {
      final key = '${currency.ticker.toLowerCase()}|${currency.getFuzzyNet()}';

      groups.putIfAbsent(key, () => []).add(currency);
    }

    final Set<AggregateCurrency> results = {};

    for (final group in groups.values) {
      final items = group
          .map((e) => Tuple2(e.exchangeName, e))
          .toList(growable: false);

      results.add(AggregateCurrency(exchangeCurrencyPairs: items));
    }

    if (widget.pairedCurrency != null) {
      results.remove(widget.pairedCurrency);
    }

    final walletCoins =
        results
            .where(
              (currency) =>
                  AppConfig.coins
                      .where(
                        (coin) =>
                            coin.ticker.toLowerCase() ==
                                currency.ticker.toLowerCase() &&
                            currency.fuzzyNet == coin.ticker.toLowerCase(),
                      )
                      .isNotEmpty,
            )
            .toList();

    final list = results.toList();

    // sort alphabetically by name
    list.sort((a, b) => a.name.compareTo(b.name));

    // reverse sort walletCoins to prepare for next step
    walletCoins.sort((a, b) => b.name.compareTo(a.name));

    // insert wallet coins at beginning
    for (final c in walletCoins) {
      list.remove(c);
      list.insert(0, c);
    }

    return list;
  }

  List<AggregateCurrency> filter(String text) {
    if (text.isEmpty) {
      return _currencies.toList();
    }

    return _currencies
        .where(
          (e) =>
              e.name.toLowerCase().contains(text.toLowerCase()) ||
              e.ticker.toLowerCase().contains(text.toLowerCase()),
        )
        .toList();
  }

  @override
  void initState() {
    _searchController = TextEditingController();

    super.initState();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!_loaded) {
      _loaded = true;
      WidgetsBinding.instance.addPostFrameCallback((timeStamp) async {
        _currencies = await _showUpdatingCurrencies(
          whileFuture: _loadCurrencies(),
        );
        setState(() {});
      });
    }

    return ConditionalParent(
      condition: !isDesktop,
      builder: (child) {
        return Background(
          child: Scaffold(
            backgroundColor:
                Theme.of(context).extension<StackColors>()!.background,
            appBar: AppBar(
              leading: AppBarBackButton(
                onPressed: () async {
                  if (FocusScope.of(context).hasFocus) {
                    FocusScope.of(context).unfocus();
                    await Future<void>.delayed(
                      const Duration(milliseconds: 50),
                    );
                  }
                  if (context.mounted) {
                    Navigator.of(context).pop();
                  }
                },
              ),
              title: Text(
                "Choose a coin to exchange",
                style: STextStyles.pageTitleH2(context),
              ),
            ),
            body: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: child,
            ),
          ),
        );
      },
      child: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: isDesktop ? MainAxisSize.min : MainAxisSize.max,
          children: [
            if (!isDesktop) const SizedBox(height: 16),
            ClipRRect(
              borderRadius: BorderRadius.circular(
                Constants.size.circularBorderRadius,
              ),
              child: TextField(
                autofocus: isDesktop,
                autocorrect: !isDesktop,
                enableSuggestions: !isDesktop,
                controller: _searchController,
                focusNode: _searchFocusNode,
                onChanged: (value) => setState(() => _searchString = value),
                style: STextStyles.field(context),
                decoration: standardInputDecoration(
                  "Search",
                  _searchFocusNode,
                  context,
                  desktopMed: isDesktop,
                ).copyWith(
                  prefixIcon: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 10,
                      vertical: 16,
                    ),
                    child: SvgPicture.asset(
                      Assets.svg.search,
                      width: 16,
                      height: 16,
                    ),
                  ),
                  suffixIcon:
                      _searchController.text.isNotEmpty
                          ? Padding(
                            padding: const EdgeInsets.only(right: 0),
                            child: UnconstrainedBox(
                              child: Row(
                                children: [
                                  TextFieldIconButton(
                                    child: const XIcon(),
                                    onTap: () async {
                                      setState(() {
                                        _searchController.text = "";
                                        _searchString = "";
                                      });
                                    },
                                  ),
                                ],
                              ),
                            ),
                          )
                          : null,
                ),
              ),
            ),
            const SizedBox(height: 20),
            Flexible(
              child: Builder(
                builder: (context) {
                  final items = filter(_searchString);

                  return RoundedWhiteContainer(
                    padding: const EdgeInsets.all(0),
                    child: ListView.builder(
                      shrinkWrap: true,
                      primary: isDesktop ? false : null,
                      itemCount: items.length,
                      itemBuilder: (builderContext, index) {
                        final image = items[index].image;
                        final hasImageUrl = image.startsWith("http");
                        return Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: GestureDetector(
                            onTap: () {
                              final selected = items[index];
                              Logging.instance.d("swap selected: $selected");
                              Navigator.of(context).pop(selected);
                            },
                            child: RoundedWhiteContainer(
                              child: Row(
                                children: [
                                  SizedBox(
                                    width: 24,
                                    height: 24,
                                    child:
                                        AppConfig.isStackCoin(
                                              items[index].ticker,
                                            )
                                            ? CoinIconForTicker(
                                              ticker: items[index].ticker,
                                              size: 24,
                                            )
                                            : hasImageUrl
                                            ? _NetImage(
                                              url: image,
                                              key: ValueKey(
                                                image + items[index].fuzzyNet,
                                              ),
                                            )
                                            : const SizedBox(
                                              width: 24,
                                              height: 24,
                                            ),
                                  ),
                                  const SizedBox(width: 10),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Row(
                                          children: [
                                            Text(
                                              items[index].name,
                                              style: STextStyles.largeMedium14(
                                                context,
                                              ),
                                            ),
                                            if (items[index].ticker
                                                    .toLowerCase() !=
                                                items[index].fuzzyNet
                                                    .toLowerCase())
                                              Padding(
                                                padding: const EdgeInsets.only(
                                                  left: 12,
                                                ),
                                                child: CoinTickerTag(
                                                  ticker:
                                                      items[index].fuzzyNet
                                                          .toUpperCase(),
                                                ),
                                              ),
                                          ],
                                        ),
                                        const SizedBox(height: 2),
                                        Text(
                                          items[index].ticker.toUpperCase(),
                                          style: STextStyles.smallMed12(
                                            context,
                                          ).copyWith(
                                            color:
                                                Theme.of(context)
                                                    .extension<StackColors>()!
                                                    .textSubtitle1,
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _NetImage extends StatelessWidget {
  const _NetImage({super.key, required this.url});

  final String url;

  @override
  Widget build(BuildContext context) {
    if (url.endsWith(".svg")) {
      return SvgPicture.network(
        key: key,
        url,
        width: 24,
        height: 24,
        placeholderBuilder: (_) => const LoadingIndicator(),
      );
    } else {
      return Image.network(url, width: 24, height: 24, key: key);
    }
  }
}
