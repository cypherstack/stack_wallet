/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:decimal/decimal.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/svg.dart';

import '../../../app_config.dart';
import '../../../models/exchange/aggregate_currency.dart';
import '../../../models/exchange/response_objects/estimate.dart';
import '../../../providers/exchange/exchange_form_state_provider.dart';
import '../../../providers/global/locale_provider.dart';
import '../../../services/exchange/exchange.dart';
import '../../../services/exchange/trocador/trocador_exchange.dart';
import '../../../themes/stack_colors.dart';
import '../../../utilities/amount/amount.dart';
import '../../../utilities/amount/amount_formatter.dart';
import '../../../utilities/amount/amount_unit.dart';
import '../../../utilities/assets.dart';
import '../../../utilities/enums/exchange_rate_type_enum.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/text_styles.dart';
import '../../../utilities/util.dart';
import '../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../widgets/animated_text.dart';
import '../../../widgets/conditional_parent.dart';
import '../../../widgets/custom_buttons/blue_text_button.dart';
import '../../../widgets/desktop/primary_button.dart';
import '../../../widgets/dialogs/basic_dialog.dart';
import '../../../widgets/exchange/trocador/trocador_kyc_info_button.dart';
import '../../../widgets/exchange/trocador/trocador_rating_type_enum.dart';

class ExchangeOption extends ConsumerStatefulWidget {
  const ExchangeOption({
    super.key,
    required this.exchange,
    required this.fixedRate,
    required this.reversed,
  });

  final Exchange exchange;
  final bool fixedRate;
  final bool reversed;

  @override
  ConsumerState<ExchangeOption> createState() => _ExchangeOptionState();
}

class _ExchangeOptionState extends ConsumerState<ExchangeOption> {
  final isDesktop = Util.isDesktop;

  @override
  Widget build(BuildContext context) {
    final sendCurrency = ref.watch(
      efCurrencyPairProvider.select((value) => value.send),
    );
    final receivingCurrency = ref.watch(
      efCurrencyPairProvider.select((value) => value.receive),
    );
    final reversed = ref.watch(efReversedProvider);
    final amount =
        reversed
            ? ref.watch(efReceiveAmountProvider)
            : ref.watch(efSendAmountProvider);

    final data = ref.watch(efEstimatesListProvider(widget.exchange.name));
    final estimates = data?.item1.value;

    final pair =
        sendCurrency != null && receivingCurrency != null
            ? (from: sendCurrency, to: receivingCurrency)
            : null;

    return AnimatedSize(
      duration: const Duration(milliseconds: 500),
      curve: Curves.easeInOutCubicEmphasized,
      child: Builder(
        builder: (_) {
          if (ref.watch(efRefreshingProvider)) {
            // show loading
            return _ProviderOption(
              exchange: widget.exchange,
              estimate: null,
              pair: pair,
              rateString: "",
              loadingString: true,
            );
          } else if (sendCurrency != null &&
              receivingCurrency != null &&
              amount != null &&
              amount > Decimal.zero) {
            if (estimates != null && estimates.isNotEmpty) {
              return Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  for (int i = 0; i < estimates.length; i++)
                    Builder(
                      builder: (context) {
                        final e = estimates[i];

                        int decimals;
                        try {
                          decimals =
                              AppConfig.getCryptoCurrencyForTicker(
                                receivingCurrency.ticker,
                              )!.fractionDigits;
                        } catch (_) {
                          decimals = 8; // some reasonable alternative
                        }
                        Amount rate;
                        if (e.reversed) {
                          rate = (amount / e.estimatedAmount)
                              .toDecimal(scaleOnInfinitePrecision: 18)
                              .toAmount(fractionDigits: decimals);
                        } else {
                          rate = (e.estimatedAmount / amount)
                              .toDecimal(scaleOnInfinitePrecision: 18)
                              .toAmount(fractionDigits: decimals);
                        }

                        CryptoCurrency? coin;
                        try {
                          coin = AppConfig.getCryptoCurrencyForTicker(
                            receivingCurrency.ticker,
                          );
                        } catch (_) {
                          coin = null;
                        }

                        final String rateString;
                        if (coin != null) {
                          rateString =
                              "1 ${sendCurrency.ticker.toUpperCase()} "
                              "~ ${ref.watch(pAmountFormatter(coin)).format(rate)}";
                        } else {
                          final formatter = AmountFormatter(
                            unit: AmountUnit.normal,
                            locale: ref.watch(
                              localeServiceChangeNotifierProvider.select(
                                (value) => value.locale,
                              ),
                            ),
                            coin: Bitcoin(
                              CryptoCurrencyNetwork.main,
                            ), // some sane default
                            maxDecimals: 8, // some sane default
                          );
                          rateString =
                              "1 ${sendCurrency.ticker.toUpperCase()} "
                              "~ ${formatter.format(rate, withUnitName: false)}"
                              " ${receivingCurrency.ticker.toUpperCase()}";
                        }

                        return ConditionalParent(
                          condition: i > 0,
                          builder:
                              (child) => Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  isDesktop
                                      ? Container(
                                        height: 1,
                                        color:
                                            Theme.of(context)
                                                .extension<StackColors>()!
                                                .background,
                                      )
                                      : const SizedBox(height: 16),
                                  child,
                                ],
                              ),
                          child: _ProviderOption(
                            key: Key(widget.exchange.name + e.exchangeProvider),
                            exchange: widget.exchange,
                            pair: pair,
                            estimate: e,
                            rateString: rateString,
                            kycRating: e.kycRating,
                          ),
                        );
                      },
                    ),
                ],
              );
            } else {
              Logging.instance.w(
                "$runtimeType rate unavailable for ${widget.exchange.name}: $data",
              );

              return Consumer(
                builder: (_, ref, __) {
                  String? message;

                  final range = data?.item2;
                  if (range != null) {
                    if (range.min != null && amount < range.min!) {
                      message ??= "Amount too small";
                    } else if (range.max != null && amount > range.max!) {
                      message ??= "Amount too large";
                    }
                  } else if (data?.item1.value == null) {
                    final rateType =
                        ref.watch(efRateTypeProvider) ==
                                ExchangeRateType.estimated
                            ? "estimated"
                            : "fixed";
                    message ??= "Pair unavailable on $rateType rate flow";
                  }

                  return _ProviderOption(
                    exchange: widget.exchange,
                    estimate: null,
                    pair: pair,
                    rateString: message ?? "Failed to fetch rate",
                    rateColor:
                        Theme.of(context).extension<StackColors>()!.textError,
                  );
                },
              );
            }
          } else {
            // show n/a
            return _ProviderOption(
              exchange: widget.exchange,
              estimate: null,
              pair: pair,
              rateString: "n/a",
            );
          }
        },
      ),
    );
  }
}

class _ProviderOption extends ConsumerStatefulWidget {
  const _ProviderOption({
    super.key,
    required this.exchange,
    required this.estimate,
    required this.pair,
    required this.rateString,
    this.kycRating,
    this.loadingString = false,
    this.rateColor,
  });

  final Exchange exchange;
  final Estimate? estimate;
  final ({AggregateCurrency from, AggregateCurrency to})? pair;
  final String rateString;
  final String? kycRating;
  final bool loadingString;
  final Color? rateColor;

  @override
  ConsumerState<_ProviderOption> createState() => _ProviderOptionState();
}

class _ProviderOptionState extends ConsumerState<_ProviderOption> {
  final isDesktop = Util.isDesktop;

  late final String _id;
  final Set<ProviderWarning> _warnings = {};

  bool _warningLock = false;
  void _showNoSparkWarning() async {
    if (_warningLock) return;
    _warningLock = true;
    try {
      await showDialog<void>(
        context: context,
        builder: (context) {
          return BasicDialog(
            title: _warnings.map((e) => e.message).join(" and "),
            message: _warnings.map((e) => e.messageDetail).join(" "),
            canPopWithBackButton: true,
            flex: true,
            desktopHeight: 400,
            rightButton: PrimaryButton(
              label: "OK",
              buttonHeight: isDesktop ? ButtonHeight.l : null,
              onPressed: Navigator.of(context).pop,
            ),
          );
        },
      );
    } finally {
      _warningLock = false;
    }
  }

  @override
  void initState() {
    super.initState();
    _id =
        "${widget.exchange.name} (${widget.estimate?.exchangeProvider ?? widget.exchange.name})";

    if (widget.exchange.name == TrocadorExchange.exchangeName &&
        widget.pair != null) {
      final from = widget.pair!.from.forExchange(widget.exchange.name);
      final to = widget.pair!.to.forExchange(widget.exchange.name);

      if (from != null) {
        final firoWarning = TrocadorExchange.checkFiro(from);
        if (firoWarning != null) _warnings.add(firoWarning);
        final ltcWarning = TrocadorExchange.checkLtc(from);
        if (ltcWarning != null) _warnings.add(ltcWarning);
      }
      if (to != null) {
        final firoWarning = TrocadorExchange.checkFiro(to);
        if (firoWarning != null) _warnings.add(firoWarning);
        final ltcWarning = TrocadorExchange.checkLtc(to);
        if (ltcWarning != null) _warnings.add(ltcWarning);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    String groupValue = ref.watch(currentCombinedExchangeIdProvider);

    if (ref.watch(efExchangeProvider).name ==
        (widget.estimate?.exchangeProvider ?? widget.exchange.name)) {
      groupValue = _id;
    }

    return ConditionalParent(
      condition: isDesktop,
      builder:
          (child) =>
              MouseRegion(cursor: SystemMouseCursors.click, child: child),
      child: GestureDetector(
        onTap: () {
          ref.read(efExchangeProvider.notifier).state = widget.exchange;
          ref.read(efExchangeProviderNameProvider.notifier).state =
              widget.estimate?.exchangeProvider ?? widget.exchange.name;
        },
        child: Container(
          color: Colors.transparent,
          child: Padding(
            padding:
                isDesktop ? const EdgeInsets.all(16) : const EdgeInsets.all(0),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(
                  width: 20,
                  height: 20,
                  child: Padding(
                    padding: EdgeInsets.only(top: isDesktop ? 20.0 : 15.0),
                    child: Radio(
                      activeColor:
                          Theme.of(
                            context,
                          ).extension<StackColors>()!.radioButtonIconEnabled,
                      value: _id,
                      groupValue: groupValue,
                      onChanged: (_) {
                        ref.read(efExchangeProvider.notifier).state =
                            widget.exchange;
                        ref
                            .read(efExchangeProviderNameProvider.notifier)
                            .state = widget.estimate?.exchangeProvider ??
                            widget.exchange.name;
                      },
                    ),
                  ),
                ),
                const SizedBox(width: 14),
                Padding(
                  padding: const EdgeInsets.only(top: 5.0),
                  child: SizedBox(
                    width: isDesktop ? 32 : 24,
                    height: isDesktop ? 32 : 24,
                    child:
                        widget.estimate?.exchangeProviderLogo != null &&
                                widget
                                    .estimate!
                                    .exchangeProviderLogo!
                                    .isNotEmpty
                            ? ClipRRect(
                              borderRadius: BorderRadius.circular(5),
                              child: Image.network(
                                widget.estimate!.exchangeProviderLogo!,
                                loadingBuilder: (
                                  context,
                                  child,
                                  loadingProgress,
                                ) {
                                  if (loadingProgress == null) {
                                    return child;
                                  } else {
                                    return const Center(
                                      child: CircularProgressIndicator(),
                                    );
                                  }
                                },
                                errorBuilder: (context, error, stackTrace) {
                                  return SvgPicture.asset(
                                    Assets.exchange.getIconFor(
                                      exchangeName: widget.exchange.name,
                                    ),
                                    width: isDesktop ? 32 : 24,
                                    height: isDesktop ? 32 : 24,
                                  );
                                },
                                width: isDesktop ? 32 : 24,
                                height: isDesktop ? 32 : 24,
                              ),
                            )
                            : SvgPicture.asset(
                              Assets.exchange.getIconFor(
                                exchangeName: widget.exchange.name,
                              ),
                              width: isDesktop ? 32 : 24,
                              height: isDesktop ? 32 : 24,
                            ),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      ConditionalParent(
                        condition: _warnings.isNotEmpty,
                        builder:
                            (child) => Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                child,
                                CustomTextButton(
                                  text: _warnings.first.value,
                                  onTap: () {
                                    _showNoSparkWarning();
                                  },
                                ),
                              ],
                            ),
                        child: Text(
                          widget.estimate?.exchangeProvider ??
                              widget.exchange.name,
                          style: STextStyles.titleBold12(context).copyWith(
                            color:
                                Theme.of(
                                  context,
                                ).extension<StackColors>()!.textDark2,
                          ),
                        ),
                      ),
                      widget.loadingString
                          ? AnimatedText(
                            stringsToLoopThrough: const [
                              "Loading",
                              "Loading.",
                              "Loading..",
                              "Loading...",
                            ],
                            style: STextStyles.itemSubtitle12(context).copyWith(
                              color:
                                  Theme.of(
                                    context,
                                  ).extension<StackColors>()!.textSubtitle1,
                            ),
                          )
                          : Text(
                            widget.rateString,
                            style: STextStyles.itemSubtitle12(context).copyWith(
                              color:
                                  widget.rateColor ??
                                  Theme.of(
                                    context,
                                  ).extension<StackColors>()!.textSubtitle1,
                            ),
                          ),
                    ],
                  ),
                ),
                if (widget.kycRating != null)
                  TrocadorKYCInfoButton(
                    kycType: TrocadorKYCType.fromString(widget.kycRating!),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
