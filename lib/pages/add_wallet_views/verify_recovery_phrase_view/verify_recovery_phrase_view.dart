/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:convert';
import 'dart:math';

import 'package:cs_monero/src/deprecated/get_height_by_date.dart'
    as cs_monero_deprecated;
import 'package:cs_salvium/src/deprecated/get_height_by_date.dart'
    as cs_salvium_deprecated;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:tuple/tuple.dart';

import '../../../models/keys/view_only_wallet_data.dart';
import '../../../notifications/show_flush_bar.dart';
import '../../../pages_desktop_specific/desktop_home_view.dart';
import '../../../pages_desktop_specific/my_stack_view/exit_to_my_stack_button.dart';
import '../../../providers/global/secure_store_provider.dart';
import '../../../providers/providers.dart';
import '../../../themes/stack_colors.dart';
import '../../../utilities/assets.dart';
import '../../../utilities/constants.dart';
import '../../../utilities/logger.dart';
import '../../../utilities/show_loading.dart';
import '../../../utilities/text_styles.dart';
import '../../../utilities/util.dart';
import '../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../wallets/crypto_currency/intermediate/bip39_hd_currency.dart';
import '../../../wallets/isar/models/wallet_info.dart';
import '../../../wallets/wallet/impl/epiccash_wallet.dart';
import '../../../wallets/wallet/impl/monero_wallet.dart';
import '../../../wallets/wallet/impl/wownero_wallet.dart';
import '../../../wallets/wallet/impl/xelis_wallet.dart';
import '../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../wallets/wallet/intermediate/lib_salvium_wallet.dart';
import '../../../wallets/wallet/wallet.dart';
import '../../../wallets/wallet/wallet_mixin_interfaces/extended_keys_interface.dart';
import '../../../wallets/wallet/wallet_mixin_interfaces/view_only_option_interface.dart';
import '../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../widgets/desktop/desktop_app_bar.dart';
import '../../../widgets/desktop/desktop_scaffold.dart';
import '../../../widgets/stack_dialog.dart';
import '../../home_view/home_view.dart';
import '../add_token_view/edit_wallet_tokens_view.dart';
import '../new_wallet_options/new_wallet_options_view.dart';
import '../new_wallet_recovery_phrase_view/new_wallet_recovery_phrase_view.dart';
import '../select_wallet_for_token_view.dart';
import 'sub_widgets/word_table.dart';
import 'verify_mnemonic_passphrase_dialog.dart';

final createSpecialEthWalletRoutingFlag = StateProvider((ref) => false);

class VerifyRecoveryPhraseView extends ConsumerStatefulWidget {
  const VerifyRecoveryPhraseView({
    super.key,
    required this.wallet,
    required this.mnemonic,
  });

  static const routeName = "/verifyRecoveryPhrase";

  final Wallet wallet;
  final List<String> mnemonic;

  @override
  ConsumerState<VerifyRecoveryPhraseView> createState() =>
      _VerifyRecoveryPhraseViewState();
}

class _VerifyRecoveryPhraseViewState
    extends ConsumerState<VerifyRecoveryPhraseView>
// with WidgetsBindingObserver
{
  late String _walletId;
  late CryptoCurrency _coin;
  late List<String> _mnemonic;
  late final bool isDesktop;

  @override
  void initState() {
    _walletId = widget.wallet.walletId;
    _coin = widget.wallet.cryptoCurrency;
    _mnemonic = widget.mnemonic;
    isDesktop = Util.isDesktop;
    super.initState();
  }

  @override
  dispose() {
    super.dispose();
  }

  Future<bool> _verifyMnemonicPassphrase() async {
    final result = await showDialog<String?>(
      context: context,
      builder: (_) => const VerifyMnemonicPassphraseDialog(),
    );

    return result == "verified";
  }

  Future<void> _convertToViewOnly() async {
    int height = 0;
    final Map<String, dynamic> otherDataJson = {
      WalletInfoKeys.isViewOnlyKey: true,
    };

    final ViewOnlyWalletType viewOnlyWalletType;
    if (widget.wallet is ExtendedKeysInterface) {
      if (widget.wallet.cryptoCurrency is Firo) {
        otherDataJson.addAll({
          WalletInfoKeys.lelantusCoinIsarRescanRequired: false,
          WalletInfoKeys.enableLelantusScanning: false,
        });
      }
      viewOnlyWalletType = ViewOnlyWalletType.xPub;
    } else if (widget.wallet is LibMoneroWallet ||
        widget.wallet is LibSalviumWallet) {
      if (widget.wallet.cryptoCurrency is Monero) {
        height = cs_monero_deprecated.getMoneroHeightByDate(
          date: DateTime.now().subtract(const Duration(days: 7)),
        );
      }
      if (widget.wallet.cryptoCurrency is Wownero) {
        height = cs_monero_deprecated.getWowneroHeightByDate(
          date: DateTime.now().subtract(const Duration(days: 7)),
        );
      }
      if (widget.wallet.cryptoCurrency is Salvium) {
        height = cs_salvium_deprecated.getSalviumHeightByDate(
          date: DateTime.now().subtract(const Duration(days: 7)),
        );
      }
      if (height < 0) height = 0;

      viewOnlyWalletType = ViewOnlyWalletType.cryptonote;
    } else {
      throw Exception(
        "Unsupported view only wallet type found: ${widget.wallet.runtimeType}",
      );
    }

    otherDataJson[WalletInfoKeys.viewOnlyTypeIndexKey] =
        viewOnlyWalletType.index;

    final voInfo = WalletInfo.createNew(
      coin: _coin,
      name: widget.wallet.info.name,
      restoreHeight: height,
      otherDataJsonString: jsonEncode(otherDataJson),
    );

    final ViewOnlyWalletData viewOnlyData;
    if (widget.wallet is ExtendedKeysInterface) {
      final extendedKeyInfo =
          await (widget.wallet as ExtendedKeysInterface).getXPubs();
      final testPath = (_coin as Bip39HDCurrency).constructDerivePath(
        derivePathType: (_coin as Bip39HDCurrency).defaultDerivePathType,
        chain: 0,
        index: 0,
      );

      XPub? xPub;
      for (final pub in extendedKeyInfo.xpubs) {
        if (testPath.startsWith(pub.path)) {
          xPub = pub;
          break;
        }
      }

      if (xPub == null) {
        throw Exception("Default derivation path not matched in xPubs");
      }

      viewOnlyData = ExtendedKeysViewOnlyWalletData(
        walletId: voInfo.walletId,
        xPubs: [xPub],
      );
    } else if (widget.wallet is LibMoneroWallet) {
      final w = widget.wallet as LibMoneroWallet;

      final info =
          await w
              .hackToCreateNewViewOnlyWalletDataFromNewlyCreatedWalletThisFunctionShouldNotBeCalledUnlessYouKnowWhatYouAreDoing();
      final address = info.$1;
      final privateViewKey = info.$2;

      await w.exit();

      viewOnlyData = CryptonoteViewOnlyWalletData(
        walletId: voInfo.walletId,
        address: address,
        privateViewKey: privateViewKey,
      );
    } else if (widget.wallet is LibSalviumWallet) {
      final w = widget.wallet as LibSalviumWallet;

      final info =
          await w
              .hackToCreateNewViewOnlyWalletDataFromNewlyCreatedWalletThisFunctionShouldNotBeCalledUnlessYouKnowWhatYouAreDoing();
      final address = info.$1;
      final privateViewKey = info.$2;

      await w.exit();

      viewOnlyData = CryptonoteViewOnlyWalletData(
        walletId: voInfo.walletId,
        address: address,
        privateViewKey: privateViewKey,
      );
    } else {
      throw Exception(
        "Unsupported view only wallet type found: ${widget.wallet.runtimeType}",
      );
    }

    final voWallet = await Wallet.create(
      walletInfo: voInfo,
      mainDB: ref.read(mainDBProvider),
      secureStorageInterface: ref.read(secureStoreProvider),
      nodeService: ref.read(nodeServiceChangeNotifierProvider),
      prefs: ref.read(prefsChangeNotifierProvider),
      viewOnlyData: viewOnlyData,
    );

    try {
      // TODO: extract interface with isRestore param
      switch (voWallet.runtimeType) {
        case const (EpiccashWallet):
          await (voWallet as EpiccashWallet).init(isRestore: true);
          break;

        case const (MoneroWallet):
          await (voWallet as MoneroWallet).init(isRestore: true);
          break;

        case const (WowneroWallet):
          await (voWallet as WowneroWallet).init(isRestore: true);
          break;

        case const (XelisWallet):
          await (voWallet as XelisWallet).init(isRestore: true);
          break;

        default:
          await voWallet.init();
      }

      await voWallet.recover(isRescan: false);

      // don't remove this setMnemonicVerified thing
      await voWallet.info.setMnemonicVerified(
        isar: ref.read(mainDBProvider).isar,
      );

      if (ref.read(pDuress)) {
        await voWallet.info.updateDuressVisibilityStatus(
          isDuressVisible: true,
          isar: ref.read(mainDBProvider).isar,
        );
      }

      ref.read(pWallets).addWallet(voWallet);

      await voWallet.exit();

      await ref
          .read(pWallets)
          .deleteWallet(widget.wallet.info, ref.read(secureStoreProvider));
    } catch (e) {
      await ref
          .read(pWallets)
          .deleteWallet(widget.wallet.info, ref.read(secureStoreProvider));
      await ref
          .read(pWallets)
          .deleteWallet(voWallet.info, ref.read(secureStoreProvider));

      rethrow;
    }
  }

  Future<void> _continue(bool isMatch) async {
    if (isMatch) {
      if (ref.read(pNewWalletOptions) != null &&
          ref.read(pNewWalletOptions)!.mnemonicPassphrase.isNotEmpty) {
        final passphraseVerified = await _verifyMnemonicPassphrase();

        if (!passphraseVerified) {
          return;
        }
      }

      await widget.wallet.info.setMnemonicVerified(
        isar: ref.read(mainDBProvider).isar,
      );

      if (ref.read(pDuress)) {
        await widget.wallet.info.updateDuressVisibilityStatus(
          isDuressVisible: true,
          isar: ref.read(mainDBProvider).isar,
        );
      }

      ref.read(pWallets).addWallet(widget.wallet);

      final isCreateSpecialEthWallet = ref.read(
        createSpecialEthWalletRoutingFlag,
      );
      if (isCreateSpecialEthWallet) {
        ref.read(createSpecialEthWalletRoutingFlag.notifier).state = false;
        ref
            .read(newEthWalletTriggerTempUntilHiveCompletelyDeleted.state)
            .state = !ref
                .read(newEthWalletTriggerTempUntilHiveCompletelyDeleted.state)
                .state;
      }

      if (mounted &&
          ref.read(pNewWalletOptions)?.convertToViewOnly == true &&
          widget.wallet is ViewOnlyOptionInterface) {
        try {
          Exception? ex;
          await showLoading(
            whileFuture: _convertToViewOnly(),
            context: context,
            message: "Converting to view only wallet",
            rootNavigator: Util.isDesktop,
            onException: (e) {
              ex = e;
            },
          );

          if (ex != null) {
            throw ex!;
          }
        } catch (e, s) {
          Logging.instance.f("$e\n$s", error: e, stackTrace: s);

          if (mounted) {
            await showDialog<void>(
              context: context,
              builder:
                  (_) => StackOkDialog(
                    title: e.toString(),
                    desktopPopRootNavigator: Util.isDesktop,
                  ),
            );
          }

          if (mounted) {
            Navigator.of(context).popUntil(
              ModalRoute.withName(NewWalletRecoveryPhraseView.routeName),
            );
          }
          return;
        }
      }

      if (mounted) {
        if (isDesktop) {
          if (isCreateSpecialEthWallet) {
            Navigator.of(
              context,
            ).popUntil(ModalRoute.withName(SelectWalletForTokenView.routeName));
          } else {
            Navigator.of(
              context,
            ).popUntil(ModalRoute.withName(DesktopHomeView.routeName));
            if (_coin is Ethereum) {
              unawaited(
                Navigator.of(context).pushNamed(
                  EditWalletTokensView.routeName,
                  arguments: widget.wallet.walletId,
                ),
              );
            }
          }
        } else {
          if (isCreateSpecialEthWallet) {
            Navigator.of(
              context,
            ).popUntil(ModalRoute.withName(SelectWalletForTokenView.routeName));
          } else {
            unawaited(
              Navigator.of(
                context,
              ).pushNamedAndRemoveUntil(HomeView.routeName, (route) => false),
            );
            if (_coin is Ethereum) {
              unawaited(
                Navigator.of(context).pushNamed(
                  EditWalletTokensView.routeName,
                  arguments: widget.wallet.walletId,
                ),
              );
            }
          }
        }

        unawaited(
          showFloatingFlushBar(
            type: FlushBarType.success,
            message: "Correct! Your wallet is set up.",
            iconAsset: Assets.svg.check,
            context: context,
          ),
        );
      }
    } else {
      unawaited(
        showFloatingFlushBar(
          type: FlushBarType.warning,
          message: "Incorrect. Please try again.",
          iconAsset: Assets.svg.circleX,
          context: context,
        ),
      );

      final int next = Random().nextInt(_mnemonic.length);
      ref
          .read(verifyMnemonicWordIndexStateProvider.state)
          .update((state) => next);

      ref
          .read(verifyMnemonicCorrectWordStateProvider.state)
          .update((state) => _mnemonic[next]);

      ref
          .read(verifyMnemonicSelectedWordStateProvider.state)
          .update((state) => "");
    }
  }

  Tuple2<List<String>, String> randomize(
    List<String> mnemonic,
    int chosenIndex,
    int wordsToShow,
  ) {
    final List<String> remaining = [];
    final String chosenWord = mnemonic[chosenIndex];

    for (int i = 0; i < mnemonic.length; i++) {
      if (chosenWord != mnemonic[i]) {
        remaining.add(mnemonic[i]);
      }
    }

    final random = Random();

    final List<String> result = [];

    for (int i = 0; i < wordsToShow - 1; i++) {
      final randomIndex = random.nextInt(remaining.length);
      result.add(remaining.removeAt(randomIndex));
    }

    result.insert(random.nextInt(wordsToShow), chosenWord);

    if (kDebugMode) {
      print("Mnemonic game correct word: $chosenWord");
    }

    return Tuple2(result, chosenWord);
  }

  Future<bool> onWillPop() async {
    // await delete();
    Navigator.of(context).popUntil(
      ModalRoute.withName(
        // NewWalletRecoveryPhraseWarningView.routeName,
        NewWalletRecoveryPhraseView.routeName,
      ),
    );
    return false;
  }

  Future<void> delete() async {
    await ref
        .read(pWallets)
        .deleteWallet(widget.wallet.info, ref.read(secureStoreProvider));
  }

  @override
  Widget build(BuildContext context) {
    debugPrint("BUILD: $runtimeType");
    final correctIndex =
        ref.watch(verifyMnemonicWordIndexStateProvider.state).state;

    return WillPopScope(
      onWillPop: onWillPop,
      child: MasterScaffold(
        isDesktop: isDesktop,
        appBar:
            isDesktop
                ? DesktopAppBar(
                  isCompactHeight: false,
                  leading: AppBarBackButton(
                    onPressed: () async {
                      Navigator.of(context).popUntil(
                        ModalRoute.withName(
                          NewWalletRecoveryPhraseView.routeName,
                        ),
                      );
                    },
                  ),
                  trailing: ExitToMyStackButton(
                    onPressed: () async {
                      await delete();
                      if (context.mounted) {
                        Navigator.of(context).popUntil(
                          ModalRoute.withName(DesktopHomeView.routeName),
                        );
                      }
                    },
                  ),
                )
                : AppBar(
                  leading: AppBarBackButton(
                    onPressed: () async {
                      Navigator.of(context).popUntil(
                        ModalRoute.withName(
                          NewWalletRecoveryPhraseView.routeName,
                        ),
                      );
                    },
                  ),
                ),
        body: SizedBox(
          width: isDesktop ? 410 : null,
          child: Padding(
            padding:
                isDesktop ? const EdgeInsets.all(0) : const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                if (isDesktop) const Spacer(flex: 10),
                SizedBox(height: isDesktop ? 24 : 4),
                Text(
                  "Verify recovery phrase",
                  textAlign: TextAlign.center,
                  style:
                      isDesktop
                          ? STextStyles.desktopH2(context)
                          : STextStyles.label(context).copyWith(fontSize: 12),
                ),
                SizedBox(height: isDesktop ? 16 : 4),
                Text(
                  isDesktop ? "Select word number" : "Tap word number ",
                  textAlign: TextAlign.center,
                  style:
                      isDesktop
                          ? STextStyles.desktopSubtitleH1(context)
                          : STextStyles.pageTitleH1(context),
                ),
                SizedBox(height: isDesktop ? 16 : 12),
                Container(
                  decoration: BoxDecoration(
                    color:
                        Theme.of(
                          context,
                        ).extension<StackColors>()!.textFieldDefaultBG,
                    borderRadius: BorderRadius.circular(
                      Constants.size.circularBorderRadius,
                    ),
                  ),
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      vertical: 8,
                      horizontal: 12,
                    ),
                    child: Text(
                      "${correctIndex + 1}",
                      textAlign: TextAlign.center,
                      style: STextStyles.subtitle600(
                        context,
                      ).copyWith(fontSize: 32, letterSpacing: 0.25),
                    ),
                  ),
                ),
                if (isDesktop) const SizedBox(height: 40),
                WordTable(
                  words: randomize(_mnemonic, correctIndex, 9).item1,
                  isDesktop: isDesktop,
                ),
                if (!isDesktop) const Spacer(),
                if (isDesktop) const SizedBox(height: 40),
                Row(
                  children: [
                    Expanded(
                      child: Consumer(
                        builder: (_, ref, __) {
                          final selectedWord =
                              ref
                                  .watch(
                                    verifyMnemonicSelectedWordStateProvider
                                        .state,
                                  )
                                  .state;
                          final correctWord =
                              ref
                                  .watch(
                                    verifyMnemonicCorrectWordStateProvider
                                        .state,
                                  )
                                  .state;

                          return ConstrainedBox(
                            constraints: BoxConstraints(
                              minHeight: isDesktop ? 70 : 0,
                            ),
                            child: TextButton(
                              onPressed:
                                  selectedWord.isNotEmpty
                                      ? () async {
                                        await _continue(
                                          correctWord == selectedWord,
                                        );
                                      }
                                      : null,
                              style:
                                  selectedWord.isNotEmpty
                                      ? Theme.of(context)
                                          .extension<StackColors>()!
                                          .getPrimaryEnabledButtonStyle(context)
                                      : Theme.of(context)
                                          .extension<StackColors>()!
                                          .getPrimaryDisabledButtonStyle(
                                            context,
                                          ),
                              child:
                                  isDesktop
                                      ? Text(
                                        "Verify",
                                        style:
                                            selectedWord.isNotEmpty
                                                ? STextStyles.desktopButtonEnabled(
                                                  context,
                                                )
                                                : STextStyles.desktopButtonDisabled(
                                                  context,
                                                ),
                                      )
                                      : Text(
                                        "Continue",
                                        style: STextStyles.button(context),
                                      ),
                            ),
                          );
                        },
                      ),
                    ),
                  ],
                ),
                if (isDesktop) const Spacer(flex: 15),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
