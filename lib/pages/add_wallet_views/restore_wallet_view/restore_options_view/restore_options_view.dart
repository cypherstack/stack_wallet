/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:dropdown_button2/dropdown_button2.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/svg.dart';
import 'package:tuple/tuple.dart';

import '../../../../pages_desktop_specific/my_stack_view/exit_to_my_stack_button.dart';
import '../../../../providers/ui/verify_recovery_phrase/mnemonic_word_count_state_provider.dart';
import '../../../../themes/stack_colors.dart';
import '../../../../utilities/assets.dart';
import '../../../../utilities/constants.dart';
import '../../../../utilities/format.dart';
import '../../../../utilities/text_styles.dart';
import '../../../../utilities/util.dart';
import '../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../wallets/crypto_currency/interfaces/view_only_option_currency_interface.dart';
import '../../../../wallets/crypto_currency/intermediate/cryptonote_currency.dart';
import '../../../../widgets/conditional_parent.dart';
import '../../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../../widgets/custom_buttons/checkbox_text_button.dart';
import '../../../../widgets/date_picker/date_picker.dart';
import '../../../../widgets/desktop/desktop_app_bar.dart';
import '../../../../widgets/desktop/desktop_scaffold.dart';
import '../../../../widgets/expandable.dart';
import '../../../../widgets/rounded_white_container.dart';
import '../../../../widgets/stack_text_field.dart';
import '../../../../widgets/toggle.dart';
import '../../create_or_restore_wallet_view/sub_widgets/coin_image.dart';
import '../restore_view_only_wallet_view.dart';
import '../restore_wallet_view.dart';
import '../sub_widgets/mnemonic_word_count_select_sheet.dart';
import 'sub_widgets/mobile_mnemonic_length_selector.dart';
import 'sub_widgets/restore_from_date_picker.dart';
import 'sub_widgets/restore_options_next_button.dart';
import 'sub_widgets/restore_options_platform_layout.dart';

class RestoreOptionsView extends ConsumerStatefulWidget {
  const RestoreOptionsView({
    super.key,
    required this.walletName,
    required this.coin,
  });

  static const routeName = "/restoreOptions";

  final String walletName;
  final CryptoCurrency coin;

  @override
  ConsumerState<RestoreOptionsView> createState() => _RestoreOptionsViewState();
}

class _RestoreOptionsViewState extends ConsumerState<RestoreOptionsView> {
  late final String walletName;
  late final CryptoCurrency coin;
  late final bool isDesktop;

  late TextEditingController _dateController;
  late FocusNode textFieldFocusNode;
  late final FocusNode passwordFocusNode;
  late final TextEditingController passwordController;

  final bool _nextEnabled = true;
  DateTime? _restoreFromDate;
  bool hidePassword = true;

  bool get supportsMnemonicPassphrase => coin.hasMnemonicPassphraseSupport;

  bool enableLelantusScanning = false;
  bool get supportsLelantus => coin is Firo;

  @override
  void initState() {
    walletName = widget.walletName;
    coin = widget.coin;
    isDesktop = Util.isDesktop;

    _dateController = TextEditingController();
    textFieldFocusNode = FocusNode();
    passwordController = TextEditingController();
    passwordFocusNode = FocusNode();

    super.initState();
  }

  @override
  void dispose() {
    _dateController.dispose();
    textFieldFocusNode.dispose();
    passwordController.dispose();
    passwordFocusNode.dispose();
    super.dispose();
  }

  bool _nextLock = false;
  Future<void> nextPressed() async {
    if (_nextLock) return;
    _nextLock = true;
    try {
      if (!isDesktop) {
        // hide keyboard if has focus
        if (FocusScope.of(context).hasFocus) {
          FocusScope.of(context).unfocus();
          await Future<void>.delayed(const Duration(milliseconds: 75));
        }
      }

      if (mounted) {
        if (!_showViewOnlyOption) {
          await Navigator.of(context).pushNamed(
            RestoreWalletView.routeName,
            arguments: Tuple6(
              walletName,
              coin,
              ref.read(mnemonicWordCountStateProvider.state).state,
              _restoreFromDate,
              passwordController.text,
              enableLelantusScanning,
            ),
          );
        } else {
          await Navigator.of(context).pushNamed(
            RestoreViewOnlyWalletView.routeName,
            arguments: (
              walletName: walletName,
              coin: coin,
              restoreFromDate: _restoreFromDate,
              enableLelantusScanning: enableLelantusScanning,
            ),
          );
        }
      }
    } finally {
      _nextLock = false;
    }
  }

  Future<void> chooseDate() async {
    // check and hide keyboard
    if (FocusScope.of(context).hasFocus) {
      FocusScope.of(context).unfocus();
      await Future<void>.delayed(const Duration(milliseconds: 125));
    }

    if (mounted) {
      final date = await showSWDatePicker(context);
      if (date != null) {
        _restoreFromDate = date;
        _dateController.text = Format.formatDate(date);
      }
    }
  }

  Future<void> chooseDesktopDate() async {
    final date = await showSWDatePicker(context);
    if (date != null) {
      _restoreFromDate = date;
      _dateController.text = Format.formatDate(date);
    }
  }

  Future<void> chooseMnemonicLength() async {
    await showModalBottomSheet<dynamic>(
      backgroundColor: Colors.transparent,
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      builder: (_) {
        return MnemonicWordCountSelectSheet(
          lengthOptions: coin.possibleMnemonicLengths,
        );
      },
    );
  }

  bool _showViewOnlyOption = false;

  @override
  Widget build(BuildContext context) {
    debugPrint("BUILD: $runtimeType with ${coin.identifier} $walletName");

    return MasterScaffold(
      isDesktop: isDesktop,
      appBar: isDesktop
          ? const DesktopAppBar(
              isCompactHeight: false,
              leading: AppBarBackButton(),
              trailing: ExitToMyStackButton(),
            )
          : AppBar(
              leading: AppBarBackButton(
                onPressed: () {
                  if (textFieldFocusNode.hasFocus) {
                    textFieldFocusNode.unfocus();
                    Future<void>.delayed(const Duration(milliseconds: 100))
                        .then((value) => Navigator.of(context).pop());
                  } else {
                    Navigator.of(context).pop();
                  }
                },
              ),
            ),
      body: RestoreOptionsPlatformLayout(
        isDesktop: isDesktop,
        child: ConstrainedBox(
          constraints: BoxConstraints(
            maxWidth: isDesktop ? 480 : double.infinity,
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Spacer(
                flex: isDesktop ? 10 : 1,
              ),
              if (!isDesktop)
                CoinImage(
                  coin: coin,
                  height: 100,
                  width: 100,
                ),
              SizedBox(
                height: isDesktop ? 0 : 16,
              ),
              Text(
                "Restore options",
                textAlign: TextAlign.center,
                style: isDesktop
                    ? STextStyles.desktopH2(context)
                    : STextStyles.pageTitleH1(context),
              ),
              SizedBox(
                height: isDesktop ? 40 : 24,
              ),
              if (coin is ViewOnlyOptionCurrencyInterface)
                SizedBox(
                  height: isDesktop ? 56 : 48,
                  width: isDesktop ? 490 : null,
                  child: Toggle(
                    key: UniqueKey(),
                    onText: "Seed",
                    offText: "View Only",
                    onColor:
                        Theme.of(context).extension<StackColors>()!.popupBG,
                    offColor: Theme.of(context)
                        .extension<StackColors>()!
                        .textFieldDefaultBG,
                    isOn: _showViewOnlyOption,
                    onValueChanged: (value) {
                      setState(() {
                        _showViewOnlyOption = value;
                      });
                    },
                    decoration: BoxDecoration(
                      color: Colors.transparent,
                      borderRadius: BorderRadius.circular(
                        Constants.size.circularBorderRadius,
                      ),
                    ),
                  ),
                ),
              if (coin is ViewOnlyOptionCurrencyInterface)
                SizedBox(
                  height: isDesktop ? 40 : 24,
                ),
              _showViewOnlyOption
                  ? ViewOnlyRestoreOption(
                      coin: coin,
                      dateController: _dateController,
                      dateChooserFunction:
                          isDesktop ? chooseDesktopDate : chooseDate,
                    )
                  : SeedRestoreOption(
                      coin: coin,
                      dateController: _dateController,
                      pwController: passwordController,
                      pwFocusNode: passwordFocusNode,
                      supportsMnemonicPassphrase: supportsMnemonicPassphrase,
                      dateChooserFunction:
                          isDesktop ? chooseDesktopDate : chooseDate,
                      chooseMnemonicLength: chooseMnemonicLength,
                      lelScanChanged: (value) {
                        enableLelantusScanning = value;
                      },
                    ),
              if (!isDesktop)
                const Spacer(
                  flex: 3,
                ),
              if (isDesktop)
                const SizedBox(
                  height: 32,
                ),
              RestoreOptionsNextButton(
                isDesktop: isDesktop,
                onPressed: _nextEnabled ? nextPressed : null,
              ),
              if (isDesktop)
                const Spacer(
                  flex: 15,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class SeedRestoreOption extends ConsumerStatefulWidget {
  const SeedRestoreOption({
    super.key,
    required this.coin,
    required this.dateController,
    required this.pwController,
    required this.pwFocusNode,
    required this.supportsMnemonicPassphrase,
    required this.dateChooserFunction,
    required this.chooseMnemonicLength,
    required this.lelScanChanged,
  });

  final CryptoCurrency coin;
  final TextEditingController dateController;
  final TextEditingController pwController;
  final FocusNode pwFocusNode;
  final bool supportsMnemonicPassphrase;

  final Future<void> Function() dateChooserFunction;
  final Future<void> Function() chooseMnemonicLength;
  final void Function(bool) lelScanChanged;

  @override
  ConsumerState<SeedRestoreOption> createState() => _SeedRestoreOptionState();
}

class _SeedRestoreOptionState extends ConsumerState<SeedRestoreOption> {
  bool _hidePassword = true;
  bool _expandedAdvanced = false;
  bool _enableLelantusScanning = false;

  @override
  Widget build(BuildContext context) {
    final lengths = widget.coin.possibleMnemonicLengths;

    final isMoneroAnd25 = widget.coin is Monero &&
        ref.watch(mnemonicWordCountStateProvider.state).state == 25;
    final isWowneroAnd25 = widget.coin is Wownero &&
        ref.watch(mnemonicWordCountStateProvider.state).state == 25;

    return Column(
      children: [
        if (isMoneroAnd25 || widget.coin is Epiccash || isWowneroAnd25)
          Text(
            "Choose start date",
            style: Util.isDesktop
                ? STextStyles.desktopTextExtraSmall(context).copyWith(
                    color:
                        Theme.of(context).extension<StackColors>()!.textDark3,
                  )
                : STextStyles.smallMed12(context),
            textAlign: TextAlign.left,
          ),
        if (isMoneroAnd25 || widget.coin is Epiccash || isWowneroAnd25)
          SizedBox(
            height: Util.isDesktop ? 16 : 8,
          ),
        if (isMoneroAnd25 || widget.coin is Epiccash || isWowneroAnd25)
          RestoreFromDatePicker(
            onTap: widget.dateChooserFunction,
            controller: widget.dateController,
          ),
        if (isMoneroAnd25 || widget.coin is Epiccash || isWowneroAnd25)
          const SizedBox(
            height: 8,
          ),
        if (isMoneroAnd25 || widget.coin is Epiccash || isWowneroAnd25)
          RoundedWhiteContainer(
            child: Center(
              child: Text(
                "Choose the date you made the wallet (approximate is fine)",
                style: Util.isDesktop
                    ? STextStyles.desktopTextExtraSmall(context).copyWith(
                        color: Theme.of(context)
                            .extension<StackColors>()!
                            .textSubtitle1,
                      )
                    : STextStyles.smallMed12(context).copyWith(
                        fontSize: 10,
                      ),
              ),
            ),
          ),
        if (isMoneroAnd25 || widget.coin is Epiccash || isWowneroAnd25)
          SizedBox(
            height: Util.isDesktop ? 24 : 16,
          ),
        Text(
          "Choose recovery phrase length",
          style: Util.isDesktop
              ? STextStyles.desktopTextExtraSmall(context).copyWith(
                  color: Theme.of(context).extension<StackColors>()!.textDark3,
                )
              : STextStyles.smallMed12(context),
          textAlign: TextAlign.left,
        ),
        SizedBox(
          height: Util.isDesktop ? 16 : 8,
        ),
        if (Util.isDesktop)
          DropdownButtonHideUnderline(
            child: DropdownButton2<int>(
              value: ref.watch(mnemonicWordCountStateProvider.state).state,
              items: [
                ...lengths.map(
                  (e) => DropdownMenuItem(
                    value: e,
                    child: Text(
                      "$e words",
                      style: STextStyles.desktopTextMedium(context),
                    ),
                  ),
                ),
              ],
              onChanged: (value) {
                if (value is int) {
                  ref.read(mnemonicWordCountStateProvider.state).state = value;
                }
              },
              isExpanded: true,
              iconStyleData: IconStyleData(
                icon: SvgPicture.asset(
                  Assets.svg.chevronDown,
                  width: 12,
                  height: 6,
                  color: Theme.of(context)
                      .extension<StackColors>()!
                      .textFieldActiveSearchIconRight,
                ),
              ),
              dropdownStyleData: DropdownStyleData(
                offset: const Offset(0, -10),
                elevation: 0,
                decoration: BoxDecoration(
                  color: Theme.of(context)
                      .extension<StackColors>()!
                      .textFieldDefaultBG,
                  borderRadius: BorderRadius.circular(
                    Constants.size.circularBorderRadius,
                  ),
                ),
              ),
              menuItemStyleData: const MenuItemStyleData(
                padding: EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 8,
                ),
              ),
            ),
          ),
        if (!Util.isDesktop)
          MobileMnemonicLengthSelector(
            chooseMnemonicLength: widget.chooseMnemonicLength,
          ),
        if (widget.supportsMnemonicPassphrase)
          SizedBox(
            height: Util.isDesktop ? 24 : 16,
          ),
        if (widget.supportsMnemonicPassphrase)
          Expandable(
            onExpandChanged: (state) {
              setState(() {
                _expandedAdvanced = state == ExpandableState.expanded;
              });
            },
            header: Container(
              color: Colors.transparent,
              child: Padding(
                padding: const EdgeInsets.only(
                  top: 8.0,
                  bottom: 8.0,
                  right: 10,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      "Advanced",
                      style: Util.isDesktop
                          ? STextStyles.desktopTextExtraExtraSmall(
                              context,
                            ).copyWith(
                              color: Theme.of(context)
                                  .extension<StackColors>()!
                                  .textDark3,
                            )
                          : STextStyles.smallMed12(context),
                      textAlign: TextAlign.left,
                    ),
                    SvgPicture.asset(
                      _expandedAdvanced
                          ? Assets.svg.chevronUp
                          : Assets.svg.chevronDown,
                      width: 12,
                      height: 6,
                      color: Theme.of(context)
                          .extension<StackColors>()!
                          .textFieldActiveSearchIconRight,
                    ),
                  ],
                ),
              ),
            ),
            body: Container(
              color: Colors.transparent,
              child: Column(
                children: [
                  if (widget.coin is Firo)
                    CheckboxTextButton(
                      label: "Scan for Lelantus transactions",
                      onChanged: (newValue) {
                        setState(() {
                          _enableLelantusScanning = newValue ?? true;
                        });

                        widget.lelScanChanged(_enableLelantusScanning);
                      },
                    ),
                  if (widget.coin is Firo)
                    const SizedBox(
                      height: 8,
                    ),
                  ClipRRect(
                    borderRadius: BorderRadius.circular(
                      Constants.size.circularBorderRadius,
                    ),
                    child: TextField(
                      key: const Key("mnemonicPassphraseFieldKey1"),
                      focusNode: widget.pwFocusNode,
                      controller: widget.pwController,
                      style: Util.isDesktop
                          ? STextStyles.desktopTextMedium(context).copyWith(
                              height: 2,
                            )
                          : STextStyles.field(context),
                      obscureText: _hidePassword,
                      enableSuggestions: false,
                      autocorrect: false,
                      decoration: standardInputDecoration(
                        "BIP39 passphrase",
                        widget.pwFocusNode,
                        context,
                      ).copyWith(
                        suffixIcon: UnconstrainedBox(
                          child: ConditionalParent(
                            condition: Util.isDesktop,
                            builder: (child) => SizedBox(
                              height: 70,
                              child: child,
                            ),
                            child: Row(
                              children: [
                                SizedBox(
                                  width: Util.isDesktop ? 24 : 16,
                                ),
                                GestureDetector(
                                  key: const Key(
                                    "mnemonicPassphraseFieldShowPasswordButtonKey",
                                  ),
                                  onTap: () async {
                                    setState(() {
                                      _hidePassword = !_hidePassword;
                                    });
                                  },
                                  child: SvgPicture.asset(
                                    _hidePassword
                                        ? Assets.svg.eye
                                        : Assets.svg.eyeSlash,
                                    color: Theme.of(context)
                                        .extension<StackColors>()!
                                        .textDark3,
                                    width: Util.isDesktop ? 24 : 16,
                                    height: Util.isDesktop ? 24 : 16,
                                  ),
                                ),
                                const SizedBox(
                                  width: 12,
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(
                    height: 8,
                  ),
                  RoundedWhiteContainer(
                    child: Center(
                      child: Text(
                        "If the recovery phrase you are about to restore "
                        "was created with an optional BIP39 passphrase "
                        "you can enter it here.",
                        style: Util.isDesktop
                            ? STextStyles.desktopTextExtraSmall(context)
                                .copyWith(
                                color: Theme.of(context)
                                    .extension<StackColors>()!
                                    .textSubtitle1,
                              )
                            : STextStyles.itemSubtitle(context),
                      ),
                    ),
                  ),
                  const SizedBox(
                    height: 16,
                  ),
                ],
              ),
            ),
          ),
      ],
    );
  }
}

class ViewOnlyRestoreOption extends StatefulWidget {
  const ViewOnlyRestoreOption({
    super.key,
    required this.coin,
    required this.dateController,
    required this.dateChooserFunction,
  });

  final CryptoCurrency coin;
  final TextEditingController dateController;

  final Future<void> Function() dateChooserFunction;

  @override
  State<ViewOnlyRestoreOption> createState() => _ViewOnlyRestoreOptionState();
}

class _ViewOnlyRestoreOptionState extends State<ViewOnlyRestoreOption> {
  @override
  Widget build(BuildContext context) {
    final showDateOption = widget.coin is CryptonoteCurrency;
    return Column(
      children: [
        if (showDateOption)
          Text(
            "Choose start date",
            style: Util.isDesktop
                ? STextStyles.desktopTextExtraSmall(context).copyWith(
                    color:
                        Theme.of(context).extension<StackColors>()!.textDark3,
                  )
                : STextStyles.smallMed12(context),
            textAlign: TextAlign.left,
          ),
        if (showDateOption)
          SizedBox(
            height: Util.isDesktop ? 16 : 8,
          ),
        if (showDateOption)
          RestoreFromDatePicker(
            onTap: widget.dateChooserFunction,
            controller: widget.dateController,
          ),
        if (showDateOption)
          const SizedBox(
            height: 8,
          ),
        if (showDateOption)
          RoundedWhiteContainer(
            child: Center(
              child: Text(
                "Choose the date you made the wallet (approximate is fine)",
                style: Util.isDesktop
                    ? STextStyles.desktopTextExtraSmall(context).copyWith(
                        color: Theme.of(context)
                            .extension<StackColors>()!
                            .textSubtitle1,
                      )
                    : STextStyles.smallMed12(context).copyWith(
                        fontSize: 10,
                      ),
              ),
            ),
          ),
        if (showDateOption)
          SizedBox(
            height: Util.isDesktop ? 24 : 16,
          ),
      ],
    );
  }
}
