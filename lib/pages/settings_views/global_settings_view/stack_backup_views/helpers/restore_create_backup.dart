/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:frostdart/frostdart.dart' as frost;
import 'package:isar/isar.dart';
import 'package:stack_wallet_backup/stack_wallet_backup.dart';
import 'package:tuple/tuple.dart';
import 'package:uuid/uuid.dart';
import 'package:wakelock_plus/wakelock_plus.dart';

import '../../../../../app_config.dart';
import '../../../../../db/hive/db.dart';
import '../../../../../db/isar/main_db.dart';
import '../../../../../models/exchange/change_now/exchange_transaction.dart';
import '../../../../../models/exchange/response_objects/trade.dart';
import '../../../../../models/isar/models/contact_entry.dart';
import '../../../../../models/isar/models/transaction_note.dart';
import '../../../../../models/keys/view_only_wallet_data.dart';
import '../../../../../models/node_model.dart';
import '../../../../../models/stack_restoring_ui_state.dart';
import '../../../../../models/trade_wallet_lookup.dart';
import '../../../../../models/wallet_restore_state.dart';
import '../../../../../services/address_book_service.dart';
import '../../../../../services/frost.dart';
import '../../../../../services/node_service.dart';
import '../../../../../services/trade_notes_service.dart';
import '../../../../../services/trade_sent_from_stack_service.dart';
import '../../../../../services/trade_service.dart';
import '../../../../../services/wallets.dart';
import '../../../../../utilities/enums/backup_frequency_type.dart';
import '../../../../../utilities/enums/stack_restoring_status.dart';
import '../../../../../utilities/enums/sync_type_enum.dart';
import '../../../../../utilities/flutter_secure_storage_interface.dart';
import '../../../../../utilities/format.dart';
import '../../../../../utilities/logger.dart';
import '../../../../../utilities/prefs.dart';
import '../../../../../utilities/util.dart';
import '../../../../../wallets/crypto_currency/intermediate/frost_currency.dart';
import '../../../../../wallets/isar/models/frost_wallet_info.dart';
import '../../../../../wallets/isar/models/wallet_info.dart';
import '../../../../../wallets/wallet/impl/bitcoin_frost_wallet.dart';
import '../../../../../wallets/wallet/impl/epiccash_wallet.dart';
import '../../../../../wallets/wallet/impl/mimblewimblecoin_wallet.dart';
import '../../../../../wallets/wallet/impl/monero_wallet.dart';
import '../../../../../wallets/wallet/impl/wownero_wallet.dart';
import '../../../../../wallets/wallet/impl/xelis_wallet.dart';
import '../../../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../../../wallets/wallet/intermediate/lib_salvium_wallet.dart';
import '../../../../../wallets/wallet/wallet.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/mnemonic_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/private_key_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/view_only_option_interface.dart';

class PreRestoreState {
  final Set<String> walletIds;
  final Map<String, dynamic> validJSON;

  PreRestoreState(this.walletIds, this.validJSON);
}

String getErrorMessageFromSWBException(Exception e) {
  String errorMessage = e.toString();
  if (e is BadDataLength) {
    errorMessage = e.errMsg();
  } else if (e is BadProtocolVersion) {
    errorMessage = e.errMsg();
  } else if (e is FailedDecryption) {
    errorMessage = e.errMsg();
  } else if (e is BadChecksum) {
    errorMessage = e.errMsg();
  } else if (e is BadAadLength) {
    errorMessage = e.errMsg();
  }
  return errorMessage;
}

String createAutoBackupFilename(String dirPath, DateTime date) {
  // this filename structure is important. DO NOT CHANGE
  return "$dirPath/stackautobackup_"
      "${date.year}_${date.month}_${date.day}_${date.hour}"
      "_${date.minute}_${date.second}.swb";
}

abstract class SWB {
  static Completer<void>? _cancelCompleter;

  static Future<void> cancelRestore() async {
    if (!_shouldCancelRestore) {
      _cancelCompleter = null;
      _cancelCompleter = Completer<void>();
      _shouldCancelRestore = true;
      Logging.instance.d("SWB cancel restore requested");
    } else {
      Logging.instance.d(
        "SWB cancel restore requested while a cancellation request is currently in progress",
      );
    }

    // return completer that will complete on SWBRestoreCancelEventType.completed event
    return _cancelCompleter!.future;
  }

  static bool _shouldCancelRestore = false;

  static bool _checkShouldCancel(
    PreRestoreState? revertToState,
    SecureStorageInterface secureStorageInterface,
  ) {
    if (_shouldCancelRestore) {
      if (revertToState != null) {
        _revert(revertToState, secureStorageInterface);
      } else {
        _cancelCompleter!.complete();
        _shouldCancelRestore = false;
      }

      return true;
    } else {
      return false;
    }
  }

  static Future<bool> encryptStackWalletWithPassphrase(
    String fileToSave,
    String passphrase,
    String plaintext,
  ) async {
    try {
      final File backupFile = File(fileToSave);
      if (!backupFile.existsSync()) {
        final String jsonBackup = plaintext;
        final Uint8List content = Uint8List.fromList(utf8.encode(jsonBackup));
        final Uint8List encryptedContent = await encryptWithPassphrase(
          passphrase,
          content,
        );
        backupFile.writeAsStringSync(
          Format.uint8listToString(encryptedContent),
        );
      }
      Logging.instance.d(backupFile.absolute);
      return true;
    } catch (e, s) {
      Logging.instance.e("$e\n$s", error: e, stackTrace: s);
      return false;
    }
  }

  static Future<bool> encryptStackWalletWithADK(
    String fileToSave,
    String adk,
    String plaintext,
    int adkVersion,
  ) async {
    try {
      final File backupFile = File(fileToSave);
      if (!backupFile.existsSync()) {
        final String jsonBackup = plaintext;
        final Uint8List content = Uint8List.fromList(utf8.encode(jsonBackup));
        final Uint8List encryptedContent = await encryptWithAdk(
          Format.stringToUint8List(adk),
          content,
          version: adkVersion,
        );
        backupFile.writeAsStringSync(
          Format.uint8listToString(encryptedContent),
        );
      }
      Logging.instance.d(backupFile.absolute);
      return true;
    } catch (e, s) {
      Logging.instance.e("$e\n$s", error: e, stackTrace: s);
      return false;
    }
  }

  static Future<String?> decryptStackWalletWithPassphrase(
    Tuple2<String, String> data,
  ) async {
    try {
      final String fileToRestore = data.item1;
      final String passphrase = data.item2;
      final File backupFile = File(fileToRestore);
      final String encryptedText = await backupFile.readAsString();
      return await decryptStackWalletStringWithPassphrase(
        Tuple2(encryptedText, passphrase),
      );
    } catch (e, s) {
      Logging.instance.e("$e\n$s", error: e, stackTrace: s);
      return null;
    }
  }

  static Future<String?> decryptStackWalletStringWithPassphrase(
    Tuple2<String, String> data,
  ) async {
    try {
      final encryptedText = data.item1;
      final passphrase = data.item2;

      final encryptedBytes = Format.stringToUint8List(encryptedText);

      final decryptedContent = await decryptWithPassphrase(
        passphrase,
        encryptedBytes,
      );

      final jsonBackup = utf8.decode(decryptedContent);
      return jsonBackup;
    } catch (e, s) {
      Logging.instance.e("$e\n$s", error: e, stackTrace: s);
      return null;
    }
  }

  /// [secureStorage] parameter exposed for testing purposes
  static Future<Map<String, dynamic>> createStackWalletJSON({
    required SecureStorageInterface secureStorage,
  }) async {
    Logging.instance.d("Starting createStackWalletJSON...");
    final _wallets = Wallets.sharedInstance;
    final Map<String, dynamic> backupJson = {};
    final NodeService nodeService = NodeService(
      secureStorageInterface: secureStorage,
    );
    final _secureStore = secureStorage;

    Logging.instance.d("createStackWalletJSON awaiting DB.instance.mutex...");
    // prevent modification of data
    await DB.instance.mutex.protect(() async {
      Logging.instance.i("...createStackWalletJSON DB.instance.mutex acquired");
      Logging.instance.i("SWB backing up nodes");
      try {
        final nodesFuture =
            nodeService.nodes.map((e) async {
              final map = e.toMap();
              map["password"] = await e.getPassword(_secureStore);
              return map;
            }).toList();
        final nodes = await Future.wait(nodesFuture);
        backupJson['nodes'] = nodes;
      } catch (e, s) {
        Logging.instance.e("", error: e, stackTrace: s);
      }

      Logging.instance.d("SWB backing up prefs");

      final Map<String, dynamic> prefs = {};
      final _prefs = Prefs.instance;
      await _prefs.init();
      prefs['currency'] = _prefs.currency;
      prefs['useBiometrics'] = _prefs.useBiometrics;
      prefs['hasPin'] = _prefs.hasPin;
      prefs['language'] = _prefs.language;
      prefs['showFavoriteWallets'] = _prefs.showFavoriteWallets;
      prefs['wifiOnly'] = _prefs.wifiOnly;
      prefs['syncType'] = _prefs.syncType.name;
      prefs['walletIdsSyncOnStartup'] = _prefs.walletIdsSyncOnStartup;
      prefs['showTestNetCoins'] = _prefs.showTestNetCoins;
      prefs['isAutoBackupEnabled'] = _prefs.isAutoBackupEnabled;
      prefs['autoBackupLocation'] = _prefs.autoBackupLocation;
      prefs['backupFrequencyType'] = _prefs.backupFrequencyType.toString();
      prefs['lastAutoBackup'] = _prefs.lastAutoBackup.toString();

      backupJson['prefs'] = prefs;

      Logging.instance.d("SWB backing up addressbook");

      final AddressBookService addressBookService = AddressBookService();
      final addresses = addressBookService.contacts;
      backupJson['addressBookEntries'] =
          addresses.map((e) => e.toMap()).toList();

      Logging.instance.d("SWB backing up wallets");

      final List<dynamic> backupWallets = [];
      for (final wallet in _wallets.wallets) {
        final Map<String, dynamic> backupWallet = {};
        backupWallet['name'] = wallet.info.name;
        backupWallet['id'] = wallet.walletId;
        backupWallet['isFavorite'] = wallet.info.isFavourite;
        backupWallet['otherDataJsonString'] = wallet.info.otherDataJsonString;

        if (wallet is ViewOnlyOptionInterface && wallet.isViewOnly) {
          backupWallet['viewOnlyWalletDataKey'] =
              (await wallet.getViewOnlyWalletData()).toJsonEncodedString();
        } else if (wallet is MnemonicInterface) {
          backupWallet['mnemonic'] = await wallet.getMnemonic();
          backupWallet['mnemonicPassphrase'] =
              await wallet.getMnemonicPassphrase();
        } else if (wallet is PrivateKeyInterface) {
          backupWallet['privateKey'] = await wallet.getPrivateKey();
        } else if (wallet is BitcoinFrostWallet) {
          final String? keys = await wallet.getSerializedKeys();
          final String? config = await wallet.getMultisigConfig();
          if (keys == null || config == null) {
            final String err =
                "${wallet.info.coin.identifier} wallet ${wallet.info.name} "
                "has null keys or config";
            Logging.instance.e(err);
            throw Exception(err);
          }
          //This case should never actually happen in practice unless the whole
          // wallet is somehow corrupt
          // TODO [prio=low]: solve case in which either keys or config is null.

          // Format keys & config as a JSON string and set otherDataJsonString.
          final Map<String, dynamic> frostData = {};
          frostData["keys"] = keys;
          frostData["config"] = config;
          backupWallet['frostWalletData'] = jsonEncode(frostData);
        }
        backupWallet['coinName'] = wallet.info.coin.identifier;
        backupWallet['storedChainHeight'] = wallet.info.cachedChainHeight;

        // backupWallet['txidList'] = DB.instance.get<dynamic>(
        //     boxName: wallet.walletId, key: "cachedTxids") as List?;
        // the following can cause a deadlock
        // (await manager.transactionData).getAllTransactions().keys.toList();

        backupWallet['restoreHeight'] = wallet.info.restoreHeight;

        final isarNotes =
            await MainDB.instance.isar.transactionNotes
                .where()
                .walletIdEqualTo(wallet.walletId)
                .findAll();

        final notes = isarNotes.asMap().map(
          (key, value) => MapEntry(value.txid, value.value),
        );

        backupWallet['notes'] = notes;

        backupWallets.add(backupWallet);
      }
      backupJson['wallets'] = backupWallets;

      Logging.instance.d("SWB backing up trades");

      // back up trade history
      final tradesService = TradesService();
      final trades = tradesService.trades
          .map((e) => e.toMap())
          .toList(growable: false);
      backupJson["tradeHistory"] = trades;

      // back up trade history lookup data for trades send from stack wallet
      final tradeTxidLookupDataService = TradeSentFromStackService();
      final lookupData =
          tradeTxidLookupDataService.all.map((e) => e.toMap()).toList();
      backupJson["tradeTxidLookupData"] = lookupData;

      Logging.instance.d("SWB backing up trade notes");

      // back up trade notes
      final tradeNotesService = TradeNotesService();
      final tradeNotes = tradeNotesService.all;
      backupJson["tradeNotes"] = tradeNotes;
    });
    Logging.instance.d("createStackWalletJSON DB.instance.mutex released");

    // // back up notifications data
    // final notificationsService = NotificationsService();
    // await notificationsService.init(nodeService, tradesService);
    // backupJson["allNotifications"] = notificationsService.notifications
    //     .map((e) => e.toMap())
    //     .toList(growable: false);

    Logging.instance.d("...createStackWalletJSON complete");
    return backupJson;
  }

  static Future<bool> _asyncRestore(
    Tuple2<dynamic, WalletInfo> tuple,
    Prefs prefs,
    NodeService nodeService,
    SecureStorageInterface secureStorageInterface,
    StackRestoringUIState? uiState,
  ) async {
    final info = tuple.item2;
    final walletbackup = tuple.item1;

    String? mnemonic, mnemonicPassphrase, privateKey;

    ViewOnlyWalletData? viewOnlyData;
    if (info.isViewOnly) {
      final viewOnlyDataEncoded =
          walletbackup['viewOnlyWalletDataKey'] as String;

      viewOnlyData = ViewOnlyWalletData.fromJsonEncodedString(
        viewOnlyDataEncoded,
        walletId: info.walletId,
      );
    } else if (walletbackup['mnemonic'] == null) {
      // probably private key based
      if (walletbackup['privateKey'] != null) {
        privateKey = walletbackup['privateKey'] as String;
      }
    } else {
      if (walletbackup['mnemonic'] is List) {
        final List<String> mnemonicList =
            (walletbackup['mnemonic'] as List<dynamic>)
                .map<String>((e) => e as String)
                .toList();
        mnemonic = mnemonicList.join(" ").trim();
      } else {
        mnemonic = walletbackup['mnemonic'] as String;
      }

      mnemonicPassphrase = walletbackup['mnemonicPassphrase'] as String? ?? "";
    }

    uiState?.update(
      walletId: info.walletId,
      restoringStatus: StackRestoringStatus.restoring,
      mnemonic: mnemonic,
      mnemonicPassphrase: mnemonicPassphrase,
    );
    Wallet? wallet;
    try {
      String? serializedKeys;
      String? multisigConfig;
      if (info.coin is FrostCurrency) {
        // Decode info.otherDataJsonString for Frost recovery info.
        final frostData = jsonDecode(walletbackup["frostWalletData"] as String);
        serializedKeys = frostData["keys"] as String;
        multisigConfig = frostData["config"] as String;

        final myNameIndex = frost.getParticipantIndexFromKeys(
          serializedKeys: serializedKeys,
        );
        final participants = Frost.getParticipants(
          multisigConfig: multisigConfig,
        );
        final myName = participants[myNameIndex];

        final frostInfo = FrostWalletInfo(
          walletId: info.walletId,
          knownSalts: [],
          participants: participants,
          myName: myName,
          threshold: frost.multisigThreshold(multisigConfig: multisigConfig),
        );

        await MainDB.instance.isar.writeTxn(() async {
          await MainDB.instance.isar.frostWalletInfo.put(frostInfo);
        });
      }

      wallet = await Wallet.create(
        walletInfo: info,
        mainDB: MainDB.instance,
        secureStorageInterface: secureStorageInterface,
        nodeService: nodeService,
        prefs: prefs,
        mnemonic: mnemonic,
        mnemonicPassphrase: mnemonicPassphrase,
        privateKey: privateKey,
        viewOnlyData: viewOnlyData,
      );

      switch (wallet.runtimeType) {
        case const (EpiccashWallet):
          await (wallet as EpiccashWallet).init(isRestore: true);
          break;
        
        case const (MimblewimblecoinWallet):
          await (wallet as MimblewimblecoinWallet).init(isRestore: true);
          break;

        case const (MoneroWallet):
          await (wallet as MoneroWallet).init(isRestore: true);
          break;

        case const (WowneroWallet):
          await (wallet as WowneroWallet).init(isRestore: true);
          break;

        case const (XelisWallet):
          await (wallet as XelisWallet).init(isRestore: true);
          break;

        default:
          await wallet.init();
      }

      int restoreHeight = walletbackup['restoreHeight'] as int? ?? 0;
      if (restoreHeight <= 0) {
<<<<<<<
        if (wallet is EpiccashWallet ||
            wallet is LibMoneroWallet ||
            wallet is LibSalviumWallet) {
=======
        if (wallet is EpiccashWallet  || wallet is MimblewimblecoinWallet || wallet is LibMoneroWallet) {
>>>>>>>
          restoreHeight = 0;
        } else {
          restoreHeight = walletbackup['storedChainHeight'] as int? ?? 0;
        }
      }

      final Future<void>? restoringFuture;
      if (wallet is BitcoinFrostWallet) {
        restoringFuture = wallet.recover(
          isRescan: false,
          multisigConfig: multisigConfig!,
          serializedKeys: serializedKeys!,
        );
      } else {
        restoringFuture = wallet.recover(isRescan: false);
      }

      uiState?.update(
        walletId: info.walletId,
        restoringStatus: StackRestoringStatus.restoring,
        wallet: wallet,
      );

      if (_shouldCancelRestore) {
        return false;
      }

      // restore notes
      final notesMap = Map<String, String>.from(
        walletbackup["notes"] as Map? ?? {},
      );
      final List<TransactionNote> notes = [];

      for (final key in notesMap.keys) {
        if (notesMap[key] != null && notesMap[key]!.isNotEmpty) {
          notes.add(
            TransactionNote(
              walletId: info.walletId,
              txid: key,
              value: notesMap[key]!,
            ),
          );
        }
      }

      if (notes.isNotEmpty) {
        await MainDB.instance.isar.writeTxn(() async {
          await MainDB.instance.isar.transactionNotes.putAll(notes);
        });
      }

      if (_shouldCancelRestore) {
        return false;
      }

      try {
        // if mnemonic verified does not get set the wallet will be deleted on app restart
        await wallet.info.setMnemonicVerified(isar: MainDB.instance.isar);
      } catch (_) {
        // Do not interrupt/cancel/fail restore from swb if setMnemonicVerified was already set
      }

      if (_shouldCancelRestore) {
        return false;
      }

      await restoringFuture;

      Logging.instance.i(
        "SWB restored: ${info.walletId} ${info.name} ${info.coin.prettyName}",
      );

      final currentAddress = await wallet.getCurrentReceivingAddress();
      uiState?.update(
        walletId: info.walletId,
        restoringStatus: StackRestoringStatus.success,
        wallet: wallet,
        address: currentAddress?.value,
        height: restoreHeight,
        mnemonic: mnemonic,
        mnemonicPassphrase: mnemonicPassphrase,
      );
    } catch (e, s) {
      Logging.instance.i("", error: e, stackTrace: s);
      uiState?.update(
        walletId: info.walletId,
        restoringStatus: StackRestoringStatus.failed,
        mnemonic: mnemonic,
        mnemonicPassphrase: mnemonicPassphrase,
      );
      return false;
    } finally {
      await wallet?.exit();
    }
    return true;
  }

  static Future<void> _restoreEverythingButWallets(
    Map<String, dynamic> validJSON,
    StackRestoringUIState? uiState,
    Map<String, String> oldToNewWalletIdMap,
    SecureStorageInterface secureStorageInterface,
  ) async {
    final Map<String, dynamic> prefs =
        validJSON["prefs"] as Map<String, dynamic>;
    final List<dynamic>? addressBookEntries =
        validJSON["addressBookEntries"] as List?;
    final List<dynamic>? primaryNodes = validJSON["primaryNodes"] as List?;
    final List<dynamic>? nodes = validJSON["nodes"] as List?;
    final List<dynamic>? trades = validJSON["tradeHistory"] as List?;
    final List<dynamic>? tradeTxidLookupData =
        validJSON["tradeTxidLookupData"] as List?;
    final Map<String, dynamic>? tradeNotes =
        validJSON["tradeNotes"] as Map<String, dynamic>?;

    uiState?.preferences = StackRestoringStatus.restoring;

    Logging.instance.d("SWB restoring prefs");
    await _restorePrefs(prefs);

    uiState?.preferences = StackRestoringStatus.success;
    uiState?.addressBook = StackRestoringStatus.restoring;

    Logging.instance.d("SWB restoring addressbook");
    if (addressBookEntries != null) {
      await _restoreAddressBook(addressBookEntries);
    }

    uiState?.addressBook = StackRestoringStatus.success;
    uiState?.nodes = StackRestoringStatus.restoring;

    Logging.instance.d("SWB restoring nodes");
    await _restoreNodes(nodes, primaryNodes, secureStorageInterface);

    uiState?.nodes = StackRestoringStatus.success;
    uiState?.trades = StackRestoringStatus.restoring;

    // restore trade history
    if (trades != null) {
      Logging.instance.d("SWB restoring trades");
      await _restoreTrades(trades);
    }

    // restore trade history lookup data for trades send from stack wallet
    if (tradeTxidLookupData != null) {
      Logging.instance.d("SWB restoring trade look up data");
      await _restoreTradesLookUpData(tradeTxidLookupData, oldToNewWalletIdMap);
    }

    // restore trade notes

    if (tradeNotes != null) {
      Logging.instance.d("SWB restoring trade notes");
      await _restoreTradesNotes(tradeNotes);
    }

    uiState?.trades = StackRestoringStatus.success;
    // uiState?.notifications = RestoringState.restoring;

    // // restore notifications data
    // final notificationsService = NotificationsService();
    // await notificationsService.init(nodeService, tradesService);
    // if (allNotifications != null) {
    //   for (int i = 0; i < allNotifications.length - 1; i++) {
    //     notificationsService.add(
    //         NotificationModel.fromJson(allNotifications[i]), false);
    //   }
    //   // only call notifyListeners on last one added
    //   if (allNotifications.length > 0) {
    //     notificationsService.add(
    //         NotificationModel.fromJson(allNotifications.last), true);
    //   }
    // }

    // uiState?.notifications = RestoringState.done;
  }

  static Future<bool?> restoreStackWalletJSON(
    String jsonBackup,
    StackRestoringUIState? uiState,
    SecureStorageInterface secureStorageInterface,
  ) async {
    if (!Platform.isLinux) await WakelockPlus.enable();

    Logging.instance.d("SWB creating temp backup");
    final preRestoreJSON = await createStackWalletJSON(
      secureStorage: secureStorageInterface,
    );
    Logging.instance.d("SWB temp backup created");

    final List<String> _currentWalletIds =
        await MainDB.instance.isar.walletInfo
            .where()
            .walletIdProperty()
            .findAll();

    final preRestoreState = PreRestoreState(
      _currentWalletIds.toSet(),
      preRestoreJSON,
    );

    final Map<String, String> oldToNewWalletIdMap = {};

    final Map<String, dynamic> validJSON =
        json.decode(jsonBackup) as Map<String, dynamic>;

    final List<dynamic> wallets = validJSON["wallets"] as List;

    // check for duplicate walletIds and assign new ones if required
    for (final wallet in wallets) {
      if (_currentWalletIds.contains(wallet["id"] as String)) {
        oldToNewWalletIdMap[wallet["id"] as String] = const Uuid().v1();
      } else {
        oldToNewWalletIdMap[wallet["id"] as String] = wallet["id"] as String;
      }
    }

    uiState?.decryption = StackRestoringStatus.success;

    // basic cancel check here
    // no reverting required yet as nothing has been written to store
    if (_checkShouldCancel(null, secureStorageInterface)) {
      return false;
    }

    await _restoreEverythingButWallets(
      validJSON,
      uiState,
      oldToNewWalletIdMap,
      secureStorageInterface,
    );

    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
      return false;
    }

    final nodeService = NodeService(
      secureStorageInterface: secureStorageInterface,
    );

    final _prefs = Prefs.instance;
    await _prefs.init();

    final List<Tuple2<dynamic, WalletInfo>> managers = [];

    final Map<String, WalletRestoreState> walletStates = {};

    for (final walletbackup in wallets) {
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
        return false;
      }

      final coin = AppConfig.getCryptoCurrencyFor(
        walletbackup['coinName'] as String,
      );

      if (coin == null) {
        continue;
      }

      final walletName = walletbackup['name'] as String;
      final walletId = oldToNewWalletIdMap[walletbackup["id"] as String]!;

      // TODO: use these for monero and possibly other coins later on?
      // final List<String> txidList = List<String>.from(walletbackup['txidList'] as List? ?? []);

      Map<String, dynamic>? otherData;
      try {
        if (walletbackup["otherDataJsonString"] is String) {
          final data = jsonDecode(
            walletbackup["otherDataJsonString"] as String,
          );
          otherData = Map<String, dynamic>.from(data as Map);
        }
      } catch (e, s) {
        Logging.instance.e(
          "SWB restore walletinfo otherdata error: ",
          error: e,
          stackTrace: s,
        );
      }

      final info = WalletInfo(
        coinName: coin.identifier,
        walletId: walletId,
        name: walletName,
        mainAddressType: coin.defaultAddressType,
        restoreHeight: walletbackup['restoreHeight'] as int? ?? 0,
        otherDataJsonString: otherData == null ? null : jsonEncode(otherData),
        cachedChainHeight: walletbackup['storedChainHeight'] as int? ?? 0,
      );

      var node = nodeService.getPrimaryNodeFor(currency: coin);

      if (node == null) {
        node = coin.defaultNode(isPrimary: true);
        await nodeService.save(node, null, false);
      }

      // final txTracker = TransactionNotificationTracker(walletId: walletId);
      //
      // final failovers = nodeService.failoverNodesFor(coin: coin);

      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
        return false;
      }

      managers.add(Tuple2(walletbackup, info));
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
        return false;
      }

      walletStates[walletId] = WalletRestoreState(
        coin: coin,
        restoringStatus: StackRestoringStatus.waiting,
        walletId: walletId,
        walletName: walletName,
      );
    }

    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
      return false;
    }

    // set the states so the ui can display each status as they update during restores
    uiState?.walletStates = walletStates;

    final List<Future<bool>> restoreStatuses = [];
    // start restoring wallets
    for (final tuple in managers) {
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
        return false;
      }
      final bools = await _asyncRestore(
        tuple,
        _prefs,
        nodeService,
        secureStorageInterface,
        uiState,
      );
      restoreStatuses.add(Future(() => bools));
    }

    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
      return false;
    }

    for (final Future<bool> status in restoreStatuses) {
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
        return false;
      }
      await status;
    }

    if (!Platform.isLinux) await WakelockPlus.disable();
    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(preRestoreState, secureStorageInterface)) {
      return false;
    }

    Logging.instance.d("done with SWB restore");

    await Wallets.sharedInstance.loadAfterStackRestore(
      _prefs,
      uiState?.wallets ?? [],
      Util.isDesktop,
    );

    return true;
  }

  static Future<void> _revert(
    PreRestoreState revertToState,
    SecureStorageInterface secureStorageInterface,
  ) async {
    final Map<String, dynamic> prefs =
        revertToState.validJSON["prefs"] as Map<String, dynamic>;
    final List<dynamic>? addressBookEntries =
        revertToState.validJSON["addressBookEntries"] as List?;
    final List<dynamic>? nodes = revertToState.validJSON["nodes"] as List?;
    final List<dynamic>? trades =
        revertToState.validJSON["tradeHistory"] as List?;
    final List<dynamic>? tradeTxidLookupData =
        revertToState.validJSON["tradeTxidLookupData"] as List?;
    final Map<String, dynamic>? tradeNotes =
        revertToState.validJSON["tradeNotes"] as Map<String, dynamic>?;

    // prefs
    await _restorePrefs(prefs);

    // contacts
    final addressBookService = AddressBookService();
    final allContactIds = addressBookService.contacts.map((e) => e.customId);

    if (addressBookEntries == null) {
      // if no contacts were present before attempted restore then delete any that
      // could have been added before the restore was cancelled
      for (final String idToDelete in allContactIds) {
        await addressBookService.removeContact(idToDelete);
      }
    } else {
      final Map<String, dynamic> preContactMap = {};
      for (final contact in addressBookEntries) {
        preContactMap[contact['id'] as String] =
            contact as Map<String, dynamic>;
      }
      // otherwise we go through and delete any newly added contacts while
      // reverting previous contact data on contacts that may have been modified
      for (final String id in allContactIds) {
        final contact = preContactMap[id];
        // pre restore state has contact
        if (contact != null) {
          // ensure this contact's data matches the pre restore state
          final List<ContactAddressEntry> addresses = [];
          for (final address in (contact['addresses'] as List<dynamic>)) {
            final entry =
                ContactAddressEntry()
                  ..coinName = address['coin'] as String
                  ..address = address['address'] as String
                  ..label = address['label'] as String
                  ..other = address['other'] as String?;

            try {
              entry.coin;
            } catch (_) {
              // coin not supported so ignore this entry
              continue;
            }

            addresses.add(entry);
          }
          await addressBookService.editContact(
            ContactEntry(
              emojiChar: contact['emoji'] as String?,
              name: contact['name'] as String,
              addresses: addresses,
              isFavorite: contact['isFavorite'] as bool,
              customId: contact['id'] as String,
            ),
          );
        } else {
          // otherwise remove it as it was not there before attempting SWB restore
          await addressBookService.removeContact(id);
        }
      }
    }

    // nodes
    final NodeService nodeService = NodeService(
      secureStorageInterface: secureStorageInterface,
    );
    final currentNodes = nodeService.nodes;
    if (nodes == null) {
      // no pre nodes found so we delete all but defaults
      for (final node in currentNodes) {
        if (!node.isDefault) {
          await nodeService.delete(node.id, true);
        }
      }
    } else {
      final Map<String, dynamic> preNodeMap = {};
      for (final nodeData in nodes) {
        preNodeMap[nodeData['id'] as String] = nodeData as Map<String, dynamic>;
      }
      // delete only newly added during attempted restore
      for (final node in currentNodes) {
        final nodeData = preNodeMap[node.id];
        if (nodeData != null) {
          // node existed before restore attempt
          // revert to pre restore node
          await nodeService.save(
            node.copyWith(
              host: nodeData['host'] as String,
              port: nodeData['port'] as int,
              name: nodeData['name'] as String,
              useSSL: nodeData['useSSL'] == "false" ? false : true,
              enabled: nodeData['enabled'] == "false" ? false : true,
              coinName: nodeData['coinName'] as String,
              loginName: nodeData['loginName'] as String?,
              isFailover: nodeData['isFailover'] as bool,
              isDown: nodeData['isDown'] as bool,
              trusted: nodeData['trusted'] as bool?,
              isPrimary: nodeData["isPrimary"] as bool? ?? false,
            ),
            nodeData['password'] as String?,
            true,
          );
        } else {
          await nodeService.delete(node.id, true);
        }
      }
    }

    await nodeService.updateDefaults();

    // trades
    final tradesService = TradesService();
    final currentTrades = tradesService.trades;

    if (trades == null) {
      // no trade history found pre restore attempt so we delete anything that
      // was added during the restore attempt
      for (final tradeTx in currentTrades) {
        await tradesService.delete(trade: tradeTx, shouldNotifyListeners: true);
      }
    } else {
      final Map<String, dynamic> preTradeMap = {};
      for (final trade in trades) {
        preTradeMap[trade['uuid'] as String] = trade as Map<String, dynamic>;
      }
      // delete only newly added during attempted restore
      for (final tradeTx in currentTrades) {
        final tradeData = preTradeMap[tradeTx.uuid];
        if (tradeData != null) {
          // trade existed before attempted restore so we don't delete it, only
          // revert data to pre restore state
          await tradesService.edit(
            trade: Trade.fromMap(tradeData as Map<String, dynamic>),
            shouldNotifyListeners: true,
          );
        } else {
          // trade did not exist before so we delete it
          await tradesService.delete(
            trade: tradeTx,
            shouldNotifyListeners: true,
          );
        }
      }
    }

    // trade notes

    final tradeNotesService = TradeNotesService();
    final currentNotes = tradeNotesService.all;

    if (tradeNotes == null) {
      for (final noteEntry in currentNotes.entries) {
        await tradeNotesService.delete(tradeId: noteEntry.key);
      }
    } else {
      // grab all trade IDs of (reverted to pre state) trades
      final idsToKeep = tradesService.trades.map((e) => e.tradeId);

      // delete all notes that don't correspond to an id that we have
      for (final noteEntry in currentNotes.entries) {
        if (!idsToKeep.contains(noteEntry.key)) {
          await tradeNotesService.delete(tradeId: noteEntry.key);
        }
      }
    }

    // trade lookup data
    // to avoid risking completely messing up here we'll accept a bit of risk
    // and completely delete everything before restoring pre state. This data
    // "Table" will be removed as it won't be needed if/when we migrate to Isar
    final tradeTxidLookupDataService = TradeSentFromStackService();
    final allItems = tradeTxidLookupDataService.all;
    for (final item in allItems) {
      await tradeTxidLookupDataService.delete(tradeWalletLookup: item);
    }
    if (tradeTxidLookupData != null) {
      for (int i = 0; i < tradeTxidLookupData.length; i++) {
        final json = Map<String, dynamic>.from(tradeTxidLookupData[i] as Map);
        final TradeWalletLookup lookup = TradeWalletLookup.fromJson(json);
        await tradeTxidLookupDataService.save(tradeWalletLookup: lookup);
      }
    }

    // finally remove any added wallets
    final allWalletIds =
        (await MainDB.instance.isar.walletInfo
                .where()
                .walletIdProperty()
                .findAll())
            .toSet();
    final walletIdsToDelete = allWalletIds.difference(revertToState.walletIds);
    await MainDB.instance.isar.writeTxn(() async {
      await MainDB.instance.isar.walletInfo.deleteAllByWalletId(
        walletIdsToDelete.toList(),
      );
    });

    _cancelCompleter!.complete();
    _shouldCancelRestore = false;
    Logging.instance.d("Revert SWB complete");
  }

  static Future<void> _restorePrefs(Map<String, dynamic> prefs) async {
    final _prefs = Prefs.instance;
    await _prefs.init();
    _prefs.currency = prefs['currency'] as String;
    // _prefs.useBiometrics = prefs['useBiometrics'] as bool;
    // _prefs.hasPin = prefs['hasPin'] as bool;
    _prefs.language = prefs['language'] as String;
    _prefs.showFavoriteWallets = prefs['showFavoriteWallets'] as bool;
    _prefs.wifiOnly = prefs['wifiOnly'] as bool;
    _prefs.syncType =
        prefs['syncType'] == "currentWalletOnly"
            ? SyncingType.currentWalletOnly
            : prefs['syncType'] == "selectedWalletsAtStartup"
            ? SyncingType.currentWalletOnly
            : SyncingType.allWalletsOnStartup; //
    _prefs.walletIdsSyncOnStartup =
        (prefs['walletIdsSyncOnStartup'] as List<dynamic>)
            .map<String>((e) => e as String)
            .toList();
    _prefs.showTestNetCoins = prefs['showTestNetCoins'] as bool;
    _prefs.isAutoBackupEnabled = prefs['isAutoBackupEnabled'] as bool;
    _prefs.autoBackupLocation = prefs['autoBackupLocation'] as String?;
    _prefs.backupFrequencyType = BackupFrequencyType.values.firstWhere(
      (e) => e.name == (prefs['backupFrequencyType'] as String?),
      orElse: () => BackupFrequencyType.everyAppStart,
    );
    _prefs.lastAutoBackup = DateTime.tryParse(
      prefs['lastAutoBackup'] as String? ?? "",
    );
  }

  static Future<void> _restoreAddressBook(
    List<dynamic> addressBookEntries,
  ) async {
    final AddressBookService addressBookService = AddressBookService();
    for (final contact in addressBookEntries) {
      final List<ContactAddressEntry> addresses = [];
      for (final address in (contact['addresses'] as List<dynamic>)) {
        final entry =
            ContactAddressEntry()
              ..coinName = address['coin'] as String
              ..address = address['address'] as String
              ..label = address['label'] as String
              ..other = address['other'] as String?;

        try {
          entry.coin;
        } catch (_) {
          // coin not supported so ignore this entry
          continue;
        }

        addresses.add(entry);
      }
      if (addresses.isNotEmpty) {
        await addressBookService.addContact(
          ContactEntry(
            emojiChar: contact['emoji'] as String?,
            name: contact['name'] as String,
            addresses: addresses,
            isFavorite: contact['isFavorite'] as bool,
            customId: contact['id'] as String,
          ),
        );
      }
    }
  }

  static Future<void> _restoreNodes(
    List<dynamic>? nodes,
    List<dynamic>? primaryNodes,
    SecureStorageInterface secureStorageInterface,
  ) async {
    final NodeService nodeService = NodeService(
      secureStorageInterface: secureStorageInterface,
    );
    if (nodes != null) {
      final primaryIds =
          primaryNodes
              ?.map((e) => e["id"] as String?)
              .whereType<String>()
              .toSet();

      for (final node in nodes) {
        final id = node['id'] as String;
        await nodeService.save(
          NodeModel(
            host: node['host'] as String,
            port: node['port'] as int,
            name: node['name'] as String,
            id: id,
            useSSL: node['useSSL'] == "false" ? false : true,
            enabled: node['enabled'] == "false" ? false : true,
            coinName: node['coinName'] as String,
            loginName: node['loginName'] as String?,
            isFailover: node['isFailover'] as bool,
            isDown: node['isDown'] as bool,
            torEnabled: node['torEnabled'] as bool? ?? true,
            clearnetEnabled: node['plainEnabled'] as bool? ?? true,
            isPrimary:
                node["isPrimary"] as bool? ?? primaryIds?.contains(id) ?? false,
          ),
          node["password"] as String?,
          true,
        );
      }
    }

    await nodeService.updateDefaults();
  }

  static Future<void> _restoreTrades(List<dynamic> trades) async {
    if (trades.isNotEmpty) {
      final tradesService = TradesService();
      for (int i = 0; i < trades.length; i++) {
        // First check for old old database entries
        ExchangeTransaction? exTx;
        try {
          exTx = ExchangeTransaction.fromJson(
            trades[i] as Map<String, dynamic>,
          );
        } catch (e) {
          // unneeded log
          // Logging.instance.log("$e\n$s", error: e, stackTrace: s,);
        }

        Trade trade;
        if (exTx != null) {
          trade = Trade.fromExchangeTransaction(exTx, false);
        } else {
          trade = Trade.fromMap(trades[i] as Map<String, dynamic>);
        }

        await tradesService.add(
          trade: trade,
          shouldNotifyListeners:
              i ==
              trades.length - 1, // only call notifyListeners on last one added
        );
      }
    }
  }

  static Future<void> _restoreTradesLookUpData(
    List<dynamic> tradeTxidLookupData,
    Map<String, String> oldToNewWalletIdMap,
  ) async {
    final tradeTxidLookupDataService = TradeSentFromStackService();
    for (int i = 0; i < tradeTxidLookupData.length; i++) {
      final json = Map<String, dynamic>.from(tradeTxidLookupData[i] as Map);
      TradeWalletLookup lookup = TradeWalletLookup.fromJson(json);
      // update walletIds
      final List<String> walletIds =
          lookup.walletIds.map((e) => oldToNewWalletIdMap[e]!).toList();
      lookup = lookup.copyWith(walletIds: walletIds);

      final oldLookup = DB.instance.get<TradeWalletLookup>(
        boxName: DB.boxNameTradeLookup,
        key: lookup.uuid,
      );
      if (oldLookup != null) {
        if (oldLookup.txid == lookup.txid &&
            oldLookup.tradeId == lookup.tradeId) {
          final List<String> mergedList = oldLookup.walletIds;
          for (final id in lookup.walletIds) {
            if (!mergedList.contains(id)) {
              mergedList.add(id);
            }
          }
          lookup = lookup.copyWith(walletIds: walletIds);
        } else {
          lookup = TradeWalletLookup(
            uuid: const Uuid().v1(),
            txid: lookup.txid,
            tradeId: lookup.tradeId,
            walletIds: lookup.walletIds,
          );
        }
      }

      await tradeTxidLookupDataService.save(tradeWalletLookup: lookup);
    }
  }

  static Future<void> _restoreTradesNotes(
    Map<String, dynamic> tradeNotes,
  ) async {
    final tradeNotesService = TradeNotesService();
    for (final note in tradeNotes.entries) {
      await tradeNotesService.set(
        tradeId: note.key,
        note: note.value as String,
      );
    }
  }
}
