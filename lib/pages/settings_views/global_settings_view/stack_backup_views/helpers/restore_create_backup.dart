/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:frostdart/frostdart.dart' as frost;
import 'package:isar/isar.dart';
import 'package:stack_wallet_backup/stack_wallet_backup.dart';
import 'package:tuple/tuple.dart';
import 'package:uuid/uuid.dart';
import 'package:wakelock_plus/wakelock_plus.dart';

import '../../../../../app_config.dart';
import '../../../../../db/hive/db.dart';
import '../../../../../db/isar/main_db.dart';
import '../../../../../models/exchange/change_now/exchange_transaction.dart';
import '../../../../../models/exchange/response_objects/trade.dart';
import '../../../../../models/isar/models/contact_entry.dart';
import '../../../../../models/isar/models/transaction_note.dart';
import '../../../../../models/node_model.dart';
import '../../../../../models/stack_restoring_ui_state.dart';
import '../../../../../models/trade_wallet_lookup.dart';
import '../../../../../models/wallet_restore_state.dart';
import '../../../../../services/address_book_service.dart';
import '../../../../../services/frost.dart';
import '../../../../../services/node_service.dart';
import '../../../../../services/trade_notes_service.dart';
import '../../../../../services/trade_sent_from_stack_service.dart';
import '../../../../../services/trade_service.dart';
import '../../../../../services/wallets.dart';
import '../../../../../utilities/enums/backup_frequency_type.dart';
import '../../../../../utilities/enums/stack_restoring_status.dart';
import '../../../../../utilities/enums/sync_type_enum.dart';
import '../../../../../utilities/flutter_secure_storage_interface.dart';
import '../../../../../utilities/format.dart';
import '../../../../../utilities/logger.dart';
import '../../../../../utilities/prefs.dart';
import '../../../../../utilities/util.dart';
import '../../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../../wallets/crypto_currency/intermediate/frost_currency.dart';
import '../../../../../wallets/isar/models/frost_wallet_info.dart';
import '../../../../../wallets/isar/models/wallet_info.dart';
import '../../../../../wallets/wallet/impl/bitcoin_frost_wallet.dart';
import '../../../../../wallets/wallet/impl/epiccash_wallet.dart';
import '../../../../../wallets/wallet/impl/monero_wallet.dart';
import '../../../../../wallets/wallet/impl/wownero_wallet.dart';
import '../../../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../../../wallets/wallet/wallet.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/mnemonic_interface.dart';
import '../../../../../wallets/wallet/wallet_mixin_interfaces/private_key_interface.dart';

class PreRestoreState {
  final Set<String> walletIds;
  final Map<String, dynamic> validJSON;

  PreRestoreState(this.walletIds, this.validJSON);
}

String getErrorMessageFromSWBException(Exception e) {
  String errorMessage = e.toString();
  if (e is BadDataLength) {
    errorMessage = e.errMsg();
  } else if (e is BadProtocolVersion) {
    errorMessage = e.errMsg();
  } else if (e is FailedDecryption) {
    errorMessage = e.errMsg();
  } else if (e is BadChecksum) {
    errorMessage = e.errMsg();
  } else if (e is BadAadLength) {
    errorMessage = e.errMsg();
  }
  return errorMessage;
}

String createAutoBackupFilename(String dirPath, DateTime date) {
  // this filename structure is important. DO NOT CHANGE
  return "$dirPath/stackautobackup_"
      "${date.year}_${date.month}_${date.day}_${date.hour}"
      "_${date.minute}_${date.second}.swb";
}

abstract class SWB {
  static Completer<void>? _cancelCompleter;

  static Future<void> cancelRestore() async {
    if (!_shouldCancelRestore) {
      _cancelCompleter = null;
      _cancelCompleter = Completer<void>();
      _shouldCancelRestore = true;
      Logging.instance
          .log("SWB cancel restore requested", level: LogLevel.Info);
    } else {
      Logging.instance.log(
        "SWB cancel restore requested while a cancellation request is currently in progress",
        level: LogLevel.Warning,
      );
    }

    // return completer that will complete on SWBRestoreCancelEventType.completed event
    return _cancelCompleter!.future;
  }

  static bool _shouldCancelRestore = false;

  static bool _checkShouldCancel(
    PreRestoreState? revertToState,
    SecureStorageInterface secureStorageInterface,
  ) {
    if (_shouldCancelRestore) {
      if (revertToState != null) {
        _revert(revertToState, secureStorageInterface);
      } else {
        _cancelCompleter!.complete();
        _shouldCancelRestore = false;
      }

      return true;
    } else {
      return false;
    }
  }

  static Future<bool> encryptStackWalletWithPassphrase(
    String fileToSave,
    String passphrase,
    String plaintext,
  ) async {
    try {
      final File backupFile = File(fileToSave);
      if (!backupFile.existsSync()) {
        final String jsonBackup = plaintext;
        final Uint8List content = Uint8List.fromList(utf8.encode(jsonBackup));
        final Uint8List encryptedContent =
            await encryptWithPassphrase(passphrase, content);
        backupFile
            .writeAsStringSync(Format.uint8listToString(encryptedContent));
      }
      Logging.instance.log(backupFile.absolute, level: LogLevel.Info);
      return true;
    } catch (e, s) {
      Logging.instance.log("$e\n$s", level: LogLevel.Error);
      return false;
    }
  }

  static Future<bool> encryptStackWalletWithADK(
    String fileToSave,
    String adk,
    String plaintext,
    int adkVersion,
  ) async {
    try {
      final File backupFile = File(fileToSave);
      if (!backupFile.existsSync()) {
        final String jsonBackup = plaintext;
        final Uint8List content = Uint8List.fromList(utf8.encode(jsonBackup));
        final Uint8List encryptedContent = await encryptWithAdk(
          Format.stringToUint8List(adk),
          content,
          version: adkVersion,
        );
        backupFile
            .writeAsStringSync(Format.uint8listToString(encryptedContent));
      }
      Logging.instance.log(backupFile.absolute, level: LogLevel.Info);
      return true;
    } catch (e, s) {
      Logging.instance.log("$e\n$s", level: LogLevel.Error);
      return false;
    }
  }

  static Future<String?> decryptStackWalletWithPassphrase(
    Tuple2<String, String> data,
  ) async {
    try {
      final String fileToRestore = data.item1;
      final String passphrase = data.item2;
      final File backupFile = File(fileToRestore);
      final String encryptedText = await backupFile.readAsString();
      return await decryptStackWalletStringWithPassphrase(
        Tuple2(encryptedText, passphrase),
      );
    } catch (e, s) {
      Logging.instance.log("$e\n$s", level: LogLevel.Error);
      return null;
    }
  }

  static Future<String?> decryptStackWalletStringWithPassphrase(
    Tuple2<String, String> data,
  ) async {
    try {
      final encryptedText = data.item1;
      final passphrase = data.item2;

      final encryptedBytes = Format.stringToUint8List(encryptedText);

      final decryptedContent =
          await decryptWithPassphrase(passphrase, encryptedBytes);

      final jsonBackup = utf8.decode(decryptedContent);
      return jsonBackup;
    } catch (e, s) {
      Logging.instance.log("$e\n$s", level: LogLevel.Error);
      return null;
    }
  }

  /// [secureStorage] parameter exposed for testing purposes
  static Future<Map<String, dynamic>> createStackWalletJSON({
    required SecureStorageInterface secureStorage,
  }) async {
    Logging.instance
        .log("Starting createStackWalletJSON...", level: LogLevel.Info);
    final _wallets = Wallets.sharedInstance;
    final Map<String, dynamic> backupJson = {};
    final NodeService nodeService =
        NodeService(secureStorageInterface: secureStorage);
    final _secureStore = secureStorage;

    Logging.instance.log(
      "createStackWalletJSON awaiting DB.instance.mutex...",
      level: LogLevel.Info,
    );
    // prevent modification of data
    await DB.instance.mutex.protect(() async {
      Logging.instance.log(
        "...createStackWalletJSON DB.instance.mutex acquired",
        level: LogLevel.Info,
      );
      Logging.instance.log(
        "SWB backing up nodes",
        level: LogLevel.Warning,
      );
      try {
        final primaryNodes = nodeService.primaryNodes.map((e) async {
          final map = e.toMap();
          map["password"] = await e.getPassword(_secureStore);
          return map;
        }).toList();
        backupJson['primaryNodes'] = await Future.wait(primaryNodes);
      } catch (e, s) {
        Logging.instance.log("$e $s", level: LogLevel.Warning);
      }
      try {
        final nodesFuture = nodeService.nodes.map((e) async {
          final map = e.toMap();
          map["password"] = await e.getPassword(_secureStore);
          return map;
        }).toList();
        final nodes = await Future.wait(nodesFuture);
        backupJson['nodes'] = nodes;
      } catch (e, s) {
        Logging.instance.log("$e $s", level: LogLevel.Error);
      }

      Logging.instance.log(
        "SWB backing up prefs",
        level: LogLevel.Warning,
      );

      final Map<String, dynamic> prefs = {};
      final _prefs = Prefs.instance;
      await _prefs.init();
      prefs['currency'] = _prefs.currency;
      prefs['useBiometrics'] = _prefs.useBiometrics;
      prefs['hasPin'] = _prefs.hasPin;
      prefs['language'] = _prefs.language;
      prefs['showFavoriteWallets'] = _prefs.showFavoriteWallets;
      prefs['wifiOnly'] = _prefs.wifiOnly;
      prefs['syncType'] = _prefs.syncType.name;
      prefs['walletIdsSyncOnStartup'] = _prefs.walletIdsSyncOnStartup;
      prefs['showTestNetCoins'] = _prefs.showTestNetCoins;
      prefs['isAutoBackupEnabled'] = _prefs.isAutoBackupEnabled;
      prefs['autoBackupLocation'] = _prefs.autoBackupLocation;
      prefs['backupFrequencyType'] = _prefs.backupFrequencyType.toString();
      prefs['lastAutoBackup'] = _prefs.lastAutoBackup.toString();

      backupJson['prefs'] = prefs;

      Logging.instance.log(
        "SWB backing up addressbook",
        level: LogLevel.Warning,
      );

      final AddressBookService addressBookService = AddressBookService();
      final addresses = addressBookService.contacts;
      backupJson['addressBookEntries'] =
          addresses.map((e) => e.toMap()).toList();

      Logging.instance.log(
        "SWB backing up wallets",
        level: LogLevel.Warning,
      );

      final List<dynamic> backupWallets = [];
      for (final wallet in _wallets.wallets) {
        final Map<String, dynamic> backupWallet = {};
        backupWallet['name'] = wallet.info.name;
        backupWallet['id'] = wallet.walletId;
        backupWallet['isFavorite'] = wallet.info.isFavourite;
        backupWallet['otherDataJsonString'] = wallet.info.otherDataJsonString;

        if (wallet is MnemonicInterface) {
          backupWallet['mnemonic'] = await wallet.getMnemonic();
          backupWallet['mnemonicPassphrase'] =
              await wallet.getMnemonicPassphrase();
        } else if (wallet is PrivateKeyInterface) {
          backupWallet['privateKey'] = await wallet.getPrivateKey();
        } else if (wallet is BitcoinFrostWallet) {
          final String? keys = await wallet.getSerializedKeys();
          final String? config = await wallet.getMultisigConfig();
          if (keys == null || config == null) {
            final String err =
                "${wallet.info.coin.identifier} wallet ${wallet.info.name} "
                "has null keys or config";
            Logging.instance.log(err, level: LogLevel.Fatal);
            throw Exception(err);
          }
          //This case should never actually happen in practice unless the whole
          // wallet is somehow corrupt
          // TODO [prio=low]: solve case in which either keys or config is null.

          // Format keys & config as a JSON string and set otherDataJsonString.
          final Map<String, dynamic> frostData = {};
          frostData["keys"] = keys;
          frostData["config"] = config;
          backupWallet['frostWalletData'] = jsonEncode(frostData);
        }
        backupWallet['coinName'] = wallet.info.coin.identifier;
        backupWallet['storedChainHeight'] = wallet.info.cachedChainHeight;

        // backupWallet['txidList'] = DB.instance.get<dynamic>(
        //     boxName: wallet.walletId, key: "cachedTxids") as List?;
        // the following can cause a deadlock
        // (await manager.transactionData).getAllTransactions().keys.toList();

        backupWallet['restoreHeight'] = wallet.info.restoreHeight;

        final isarNotes = await MainDB.instance.isar.transactionNotes
            .where()
            .walletIdEqualTo(wallet.walletId)
            .findAll();

        final notes = isarNotes
            .asMap()
            .map((key, value) => MapEntry(value.txid, value.value));

        backupWallet['notes'] = notes;

        backupWallets.add(backupWallet);
      }
      backupJson['wallets'] = backupWallets;

      Logging.instance.log(
        "SWB backing up trades",
        level: LogLevel.Warning,
      );

      // back up trade history
      final tradesService = TradesService();
      final trades =
          tradesService.trades.map((e) => e.toMap()).toList(growable: false);
      backupJson["tradeHistory"] = trades;

      // back up trade history lookup data for trades send from stack wallet
      final tradeTxidLookupDataService = TradeSentFromStackService();
      final lookupData =
          tradeTxidLookupDataService.all.map((e) => e.toMap()).toList();
      backupJson["tradeTxidLookupData"] = lookupData;

      Logging.instance.log(
        "SWB backing up trade notes",
        level: LogLevel.Warning,
      );

      // back up trade notes
      final tradeNotesService = TradeNotesService();
      final tradeNotes = tradeNotesService.all;
      backupJson["tradeNotes"] = tradeNotes;
    });
    Logging.instance.log(
      "createStackWalletJSON DB.instance.mutex released",
      level: LogLevel.Info,
    );

    // // back up notifications data
    // final notificationsService = NotificationsService();
    // await notificationsService.init(nodeService, tradesService);
    // backupJson["allNotifications"] = notificationsService.notifications
    //     .map((e) => e.toMap())
    //     .toList(growable: false);

    Logging.instance
        .log("...createStackWalletJSON complete", level: LogLevel.Info);
    return backupJson;
  }

  static Future<bool> _asyncRestore(
    Tuple2<dynamic, WalletInfo> tuple,
    Prefs prefs,
    NodeService nodeService,
    SecureStorageInterface secureStorageInterface,
    StackRestoringUIState? uiState,
  ) async {
    final info = tuple.item2;
    final walletbackup = tuple.item1;

    String? mnemonic, mnemonicPassphrase, privateKey;

    if (walletbackup['mnemonic'] == null) {
      // probably private key based
      if (walletbackup['privateKey'] != null) {
        privateKey = walletbackup['privateKey'] as String;
      }
    } else {
      if (walletbackup['mnemonic'] is List) {
        final List<String> mnemonicList =
            (walletbackup['mnemonic'] as List<dynamic>)
                .map<String>((e) => e as String)
                .toList();
        mnemonic = mnemonicList.join(" ").trim();
      } else {
        mnemonic = walletbackup['mnemonic'] as String;
      }

      mnemonicPassphrase = walletbackup['mnemonicPassphrase'] as String? ?? "";
    }

    uiState?.update(
      walletId: info.walletId,
      restoringStatus: StackRestoringStatus.restoring,
      mnemonic: mnemonic,
      mnemonicPassphrase: mnemonicPassphrase,
    );

    try {
      String? serializedKeys;
      String? multisigConfig;
      if (info.coin is FrostCurrency) {
        // Decode info.otherDataJsonString for Frost recovery info.
        final frostData = jsonDecode(walletbackup["frostWalletData"] as String);
        serializedKeys = frostData["keys"] as String;
        multisigConfig = frostData["config"] as String;

        final myNameIndex = frost.getParticipantIndexFromKeys(
          serializedKeys: serializedKeys,
        );
        final participants = Frost.getParticipants(
          multisigConfig: multisigConfig,
        );
        final myName = participants[myNameIndex];

        final frostInfo = FrostWalletInfo(
          walletId: info.walletId,
          knownSalts: [],
          participants: participants,
          myName: myName,
          threshold: frost.multisigThreshold(
            multisigConfig: multisigConfig,
          ),
        );

        await MainDB.instance.isar.writeTxn(() async {
          await MainDB.instance.isar.frostWalletInfo.put(frostInfo);
        });
      }

      final wallet = await Wallet.create(
        walletInfo: info,
        mainDB: MainDB.instance,
        secureStorageInterface: secureStorageInterface,
        nodeService: nodeService,
        prefs: prefs,
        mnemonic: mnemonic,
        mnemonicPassphrase: mnemonicPassphrase,
        privateKey: privateKey,
      );

      if (wallet is MoneroWallet /*|| wallet is WowneroWallet doesn't work.*/) {
        await wallet.init(isRestore: true);
      } else if (wallet is WowneroWallet) {
        await wallet.init(isRestore: true);
      } else {
        await wallet.init();
      }

      int restoreHeight = walletbackup['restoreHeight'] as int? ?? 0;
      if (restoreHeight <= 0) {
        restoreHeight = walletbackup['storedChainHeight'] as int? ?? 0;
      }

      Future<void>? restoringFuture;

      if (!(wallet is LibMoneroWallet || wallet is EpiccashWallet)) {
        if (wallet is BitcoinFrostWallet) {
          restoringFuture = wallet.recover(
            isRescan: false,
            multisigConfig: multisigConfig!,
            serializedKeys: serializedKeys!,
          );
        } else {
          restoringFuture = wallet.recover(isRescan: false);
        }
      }

      uiState?.update(
        walletId: info.walletId,
        restoringStatus: StackRestoringStatus.restoring,
        wallet: wallet,
      );

      if (_shouldCancelRestore) {
        return false;
      }

      // restore notes
      final notesMap =
          Map<String, String>.from(walletbackup["notes"] as Map? ?? {});
      final List<TransactionNote> notes = [];

      for (final key in notesMap.keys) {
        if (notesMap[key] != null && notesMap[key]!.isNotEmpty) {
          notes.add(
            TransactionNote(
              walletId: info.walletId,
              txid: key,
              value: notesMap[key]!,
            ),
          );
        }
      }

      if (notes.isNotEmpty) {
        await MainDB.instance.isar.writeTxn(() async {
          await MainDB.instance.isar.transactionNotes.putAll(notes);
        });
      }

      if (_shouldCancelRestore) {
        return false;
      }

      try {
        // if mnemonic verified does not get set the wallet will be deleted on app restart
        await wallet.info.setMnemonicVerified(isar: MainDB.instance.isar);
      } catch (_) {
        // Do not interrupt/cancel/fail restore from swb if setMnemonicVerified was already set
      }

      if (_shouldCancelRestore) {
        return false;
      }

      await restoringFuture;

      Logging.instance.log(
        "SWB restored: ${info.walletId} ${info.name} ${info.coin.prettyName}",
        level: LogLevel.Info,
      );

      final currentAddress = await wallet.getCurrentReceivingAddress();
      uiState?.update(
        walletId: info.walletId,
        restoringStatus: StackRestoringStatus.success,
        wallet: wallet,
        address: currentAddress?.value,
        height: restoreHeight,
        mnemonic: mnemonic,
        mnemonicPassphrase: mnemonicPassphrase,
      );
    } catch (e, s) {
      Logging.instance.log("$e $s", level: LogLevel.Warning);
      uiState?.update(
        walletId: info.walletId,
        restoringStatus: StackRestoringStatus.failed,
        mnemonic: mnemonic,
        mnemonicPassphrase: mnemonicPassphrase,
      );
      return false;
    }
    return true;
  }

  static Future<void> _restoreEverythingButWallets(
    Map<String, dynamic> validJSON,
    StackRestoringUIState? uiState,
    Map<String, String> oldToNewWalletIdMap,
    SecureStorageInterface secureStorageInterface,
  ) async {
    final Map<String, dynamic> prefs =
        validJSON["prefs"] as Map<String, dynamic>;
    final List<dynamic>? addressBookEntries =
        validJSON["addressBookEntries"] as List?;
    final List<dynamic>? primaryNodes = validJSON["primaryNodes"] as List?;
    final List<dynamic>? nodes = validJSON["nodes"] as List?;
    final List<dynamic>? trades = validJSON["tradeHistory"] as List?;
    final List<dynamic>? tradeTxidLookupData =
        validJSON["tradeTxidLookupData"] as List?;
    final Map<String, dynamic>? tradeNotes =
        validJSON["tradeNotes"] as Map<String, dynamic>?;

    uiState?.preferences = StackRestoringStatus.restoring;

    Logging.instance.log(
      "SWB restoring prefs",
      level: LogLevel.Warning,
    );
    await _restorePrefs(prefs);

    uiState?.preferences = StackRestoringStatus.success;
    uiState?.addressBook = StackRestoringStatus.restoring;

    Logging.instance.log(
      "SWB restoring addressbook",
      level: LogLevel.Warning,
    );
    if (addressBookEntries != null) {
      await _restoreAddressBook(addressBookEntries);
    }

    uiState?.addressBook = StackRestoringStatus.success;
    uiState?.nodes = StackRestoringStatus.restoring;

    Logging.instance.log(
      "SWB restoring nodes",
      level: LogLevel.Warning,
    );
    await _restoreNodes(
      nodes,
      primaryNodes,
      secureStorageInterface,
    );

    uiState?.nodes = StackRestoringStatus.success;
    uiState?.trades = StackRestoringStatus.restoring;

    // restore trade history
    if (trades != null) {
      Logging.instance.log(
        "SWB restoring trades",
        level: LogLevel.Warning,
      );
      await _restoreTrades(trades);
    }

    // restore trade history lookup data for trades send from stack wallet
    if (tradeTxidLookupData != null) {
      Logging.instance.log(
        "SWB restoring trade look up data",
        level: LogLevel.Warning,
      );
      await _restoreTradesLookUpData(tradeTxidLookupData, oldToNewWalletIdMap);
    }

    // restore trade notes

    if (tradeNotes != null) {
      Logging.instance.log(
        "SWB restoring trade notes",
        level: LogLevel.Warning,
      );
      await _restoreTradesNotes(tradeNotes);
    }

    uiState?.trades = StackRestoringStatus.success;
    // uiState?.notifications = RestoringState.restoring;

    // // restore notifications data
    // final notificationsService = NotificationsService();
    // await notificationsService.init(nodeService, tradesService);
    // if (allNotifications != null) {
    //   for (int i = 0; i < allNotifications.length - 1; i++) {
    //     notificationsService.add(
    //         NotificationModel.fromJson(allNotifications[i]), false);
    //   }
    //   // only call notifyListeners on last one added
    //   if (allNotifications.length > 0) {
    //     notificationsService.add(
    //         NotificationModel.fromJson(allNotifications.last), true);
    //   }
    // }

    // uiState?.notifications = RestoringState.done;
  }

  static Future<bool?> restoreStackWalletJSON(
    String jsonBackup,
    StackRestoringUIState? uiState,
    SecureStorageInterface secureStorageInterface,
  ) async {
    if (!Platform.isLinux) await WakelockPlus.enable();

    Logging.instance.log(
      "SWB creating temp backup",
      level: LogLevel.Warning,
    );
    final preRestoreJSON =
        await createStackWalletJSON(secureStorage: secureStorageInterface);
    Logging.instance.log(
      "SWB temp backup created",
      level: LogLevel.Warning,
    );

    final List<String> _currentWalletIds = await MainDB.instance.isar.walletInfo
        .where()
        .walletIdProperty()
        .findAll();

    final preRestoreState =
        PreRestoreState(_currentWalletIds.toSet(), preRestoreJSON);

    final Map<String, String> oldToNewWalletIdMap = {};

    final Map<String, dynamic> validJSON =
        json.decode(jsonBackup) as Map<String, dynamic>;

    final List<dynamic> wallets = validJSON["wallets"] as List;

    // check for duplicate walletIds and assign new ones if required
    for (final wallet in wallets) {
      if (_currentWalletIds.contains(wallet["id"] as String)) {
        oldToNewWalletIdMap[wallet["id"] as String] = const Uuid().v1();
      } else {
        oldToNewWalletIdMap[wallet["id"] as String] = wallet["id"] as String;
      }
    }

    uiState?.decryption = StackRestoringStatus.success;

    // basic cancel check here
    // no reverting required yet as nothing has been written to store
    if (_checkShouldCancel(
      null,
      secureStorageInterface,
    )) {
      return false;
    }

    await _restoreEverythingButWallets(
      validJSON,
      uiState,
      oldToNewWalletIdMap,
      secureStorageInterface,
    );

    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(
      preRestoreState,
      secureStorageInterface,
    )) {
      return false;
    }

    final nodeService = NodeService(
      secureStorageInterface: secureStorageInterface,
    );

    final _prefs = Prefs.instance;
    await _prefs.init();

    final List<Tuple2<dynamic, WalletInfo>> managers = [];

    final Map<String, WalletRestoreState> walletStates = {};

    for (final walletbackup in wallets) {
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(
        preRestoreState,
        secureStorageInterface,
      )) {
        return false;
      }

      final coin = AppConfig.getCryptoCurrencyFor(
        walletbackup['coinName'] as String,
      );

      if (coin == null) {
        continue;
      }

      final walletName = walletbackup['name'] as String;
      final walletId = oldToNewWalletIdMap[walletbackup["id"] as String]!;

      // TODO: use these for monero and possibly other coins later on?
      // final List<String> txidList = List<String>.from(walletbackup['txidList'] as List? ?? []);

      Map<String, dynamic>? otherData;
      try {
        if (walletbackup["otherDataJsonString"] is String) {
          final data =
              jsonDecode(walletbackup["otherDataJsonString"] as String);
          otherData = Map<String, dynamic>.from(data as Map);
        }
      } catch (e, s) {
        Logging.instance.log(
          "SWB restore walletinfo otherdata error: $e\n$s",
          level: LogLevel.Error,
        );
      }

      if (coin is Firo) {
        otherData ??= {};
        // swb will do a restore so this flag should be set to false so another
        // rescan/restore isn't done when opening the wallet
        otherData[WalletInfoKeys.lelantusCoinIsarRescanRequired] = false;
      }

      final info = WalletInfo(
        coinName: coin.identifier,
        walletId: walletId,
        name: walletName,
        mainAddressType: coin.defaultAddressType,
        restoreHeight: walletbackup['restoreHeight'] as int? ?? 0,
        otherDataJsonString: otherData == null ? null : jsonEncode(otherData),
        cachedChainHeight: walletbackup['storedChainHeight'] as int? ?? 0,
      );

      var node = nodeService.getPrimaryNodeFor(currency: coin);

      if (node == null) {
        node = coin.defaultNode;
        await nodeService.setPrimaryNodeFor(coin: coin, node: node);
      }

      // final txTracker = TransactionNotificationTracker(walletId: walletId);
      //
      // final failovers = nodeService.failoverNodesFor(coin: coin);

      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(
        preRestoreState,
        secureStorageInterface,
      )) {
        return false;
      }

      managers.add(Tuple2(walletbackup, info));
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(
        preRestoreState,
        secureStorageInterface,
      )) {
        return false;
      }

      walletStates[walletId] = WalletRestoreState(
        coin: coin,
        restoringStatus: StackRestoringStatus.waiting,
        walletId: walletId,
        walletName: walletName,
      );
    }

    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(
      preRestoreState,
      secureStorageInterface,
    )) {
      return false;
    }

    // set the states so the ui can display each status as they update during restores
    uiState?.walletStates = walletStates;

    final List<Future<bool>> restoreStatuses = [];
    // start restoring wallets
    for (final tuple in managers) {
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(
        preRestoreState,
        secureStorageInterface,
      )) {
        return false;
      }
      final bools = await _asyncRestore(
        tuple,
        _prefs,
        nodeService,
        secureStorageInterface,
        uiState,
      );
      restoreStatuses.add(Future(() => bools));
    }

    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(
      preRestoreState,
      secureStorageInterface,
    )) {
      return false;
    }

    for (final Future<bool> status in restoreStatuses) {
      // check if cancel was requested and restore previous state
      if (_checkShouldCancel(
        preRestoreState,
        secureStorageInterface,
      )) {
        return false;
      }
      await status;
    }

    if (!Platform.isLinux) await WakelockPlus.disable();
    // check if cancel was requested and restore previous state
    if (_checkShouldCancel(
      preRestoreState,
      secureStorageInterface,
    )) {
      return false;
    }

    Logging.instance.log("done with SWB restore", level: LogLevel.Warning);

    await Wallets.sharedInstance
        .loadAfterStackRestore(_prefs, uiState?.wallets ?? [], Util.isDesktop);

    return true;
  }

  static Future<void> _revert(
    PreRestoreState revertToState,
    SecureStorageInterface secureStorageInterface,
  ) async {
    final Map<String, dynamic> prefs =
        revertToState.validJSON["prefs"] as Map<String, dynamic>;
    final List<dynamic>? addressBookEntries =
        revertToState.validJSON["addressBookEntries"] as List?;
    final List<dynamic>? primaryNodes =
        revertToState.validJSON["primaryNodes"] as List?;
    final List<dynamic>? nodes = revertToState.validJSON["nodes"] as List?;
    final List<dynamic>? trades =
        revertToState.validJSON["tradeHistory"] as List?;
    final List<dynamic>? tradeTxidLookupData =
        revertToState.validJSON["tradeTxidLookupData"] as List?;
    final Map<String, dynamic>? tradeNotes =
        revertToState.validJSON["tradeNotes"] as Map<String, dynamic>?;

    // prefs
    await _restorePrefs(prefs);

    // contacts
    final addressBookService = AddressBookService();
    final allContactIds = addressBookService.contacts.map((e) => e.customId);

    if (addressBookEntries == null) {
      // if no contacts were present before attempted restore then delete any that
      // could have been added before the restore was cancelled
      for (final String idToDelete in allContactIds) {
        await addressBookService.removeContact(idToDelete);
      }
    } else {
      final Map<String, dynamic> preContactMap = {};
      for (final contact in addressBookEntries) {
        preContactMap[contact['id'] as String] =
            contact as Map<String, dynamic>;
      }
      // otherwise we go through and delete any newly added contacts while
      // reverting previous contact data on contacts that may have been modified
      for (final String id in allContactIds) {
        final contact = preContactMap[id];
        // pre restore state has contact
        if (contact != null) {
          // ensure this contact's data matches the pre restore state
          final List<ContactAddressEntry> addresses = [];
          for (final address in (contact['addresses'] as List<dynamic>)) {
            final entry = ContactAddressEntry()
              ..coinName = address['coin'] as String
              ..address = address['address'] as String
              ..label = address['label'] as String
              ..other = address['other'] as String?;

            try {
              entry.coin;
            } catch (_) {
              // coin not supported so ignore this entry
              continue;
            }

            addresses.add(
              entry,
            );
          }
          await addressBookService.editContact(
            ContactEntry(
              emojiChar: contact['emoji'] as String?,
              name: contact['name'] as String,
              addresses: addresses,
              isFavorite: contact['isFavorite'] as bool,
              customId: contact['id'] as String,
            ),
          );
        } else {
          // otherwise remove it as it was not there before attempting SWB restore
          await addressBookService.removeContact(id);
        }
      }
    }

    // nodes
    final NodeService nodeService = NodeService(
      secureStorageInterface: secureStorageInterface,
    );
    final currentNodes = nodeService.nodes;
    if (nodes == null) {
      // no pre nodes found so we delete all but defaults
      for (final node in currentNodes) {
        if (!node.isDefault) {
          await nodeService.delete(node.id, true);
        }
      }
    } else {
      final Map<String, dynamic> preNodeMap = {};
      for (final nodeData in nodes) {
        preNodeMap[nodeData['id'] as String] = nodeData as Map<String, dynamic>;
      }
      // delete only newly added during attempted restore
      for (final node in currentNodes) {
        final nodeData = preNodeMap[node.id];
        if (nodeData != null) {
          // node existed before restore attempt
          // revert to pre restore node
          await nodeService.edit(
            node.copyWith(
              host: nodeData['host'] as String,
              port: nodeData['port'] as int,
              name: nodeData['name'] as String,
              useSSL: nodeData['useSSL'] == "false" ? false : true,
              enabled: nodeData['enabled'] == "false" ? false : true,
              coinName: nodeData['coinName'] as String,
              loginName: nodeData['loginName'] as String?,
              isFailover: nodeData['isFailover'] as bool,
              isDown: nodeData['isDown'] as bool,
            ),
            nodeData['password'] as String?,
            true,
          );
        } else {
          await nodeService.delete(node.id, true);
        }
      }
    }

    // primary nodes
    if (primaryNodes != null) {
      for (final node in primaryNodes) {
        try {
          final CryptoCurrency coin;
          try {
            coin = AppConfig.getCryptoCurrencyByPrettyName(
              node['coinName'] as String,
            );
          } catch (_) {
            continue;
          }

          await nodeService.setPrimaryNodeFor(
            coin: coin,
            node: nodeService.getNodeById(id: node['id'] as String)!,
          );
        } catch (e, s) {
          Logging.instance.log("$e $s", level: LogLevel.Error);
        }
      }
    }
    await nodeService.updateDefaults();

    // trades
    final tradesService = TradesService();
    final currentTrades = tradesService.trades;

    if (trades == null) {
      // no trade history found pre restore attempt so we delete anything that
      // was added during the restore attempt
      for (final tradeTx in currentTrades) {
        await tradesService.delete(trade: tradeTx, shouldNotifyListeners: true);
      }
    } else {
      final Map<String, dynamic> preTradeMap = {};
      for (final trade in trades) {
        preTradeMap[trade['uuid'] as String] = trade as Map<String, dynamic>;
      }
      // delete only newly added during attempted restore
      for (final tradeTx in currentTrades) {
        final tradeData = preTradeMap[tradeTx.uuid];
        if (tradeData != null) {
          // trade existed before attempted restore so we don't delete it, only
          // revert data to pre restore state
          await tradesService.edit(
            trade: Trade.fromMap(tradeData as Map<String, dynamic>),
            shouldNotifyListeners: true,
          );
        } else {
          // trade did not exist before so we delete it
          await tradesService.delete(
            trade: tradeTx,
            shouldNotifyListeners: true,
          );
        }
      }
    }

    // trade notes

    final tradeNotesService = TradeNotesService();
    final currentNotes = tradeNotesService.all;

    if (tradeNotes == null) {
      for (final noteEntry in currentNotes.entries) {
        await tradeNotesService.delete(tradeId: noteEntry.key);
      }
    } else {
      // grab all trade IDs of (reverted to pre state) trades
      final idsToKeep = tradesService.trades.map((e) => e.tradeId);

      // delete all notes that don't correspond to an id that we have
      for (final noteEntry in currentNotes.entries) {
        if (!idsToKeep.contains(noteEntry.key)) {
          await tradeNotesService.delete(tradeId: noteEntry.key);
        }
      }
    }

    // trade lookup data
    // to avoid risking completely messing up here we'll accept a bit of risk
    // and completely delete everything before restoring pre state. This data
    // "Table" will be removed as it won't be needed if/when we migrate to Isar
    final tradeTxidLookupDataService = TradeSentFromStackService();
    final allItems = tradeTxidLookupDataService.all;
    for (final item in allItems) {
      await tradeTxidLookupDataService.delete(tradeWalletLookup: item);
    }
    if (tradeTxidLookupData != null) {
      for (int i = 0; i < tradeTxidLookupData.length; i++) {
        final json = Map<String, dynamic>.from(tradeTxidLookupData[i] as Map);
        final TradeWalletLookup lookup = TradeWalletLookup.fromJson(json);
        await tradeTxidLookupDataService.save(tradeWalletLookup: lookup);
      }
    }

    // finally remove any added wallets
    final allWalletIds = (await MainDB.instance.isar.walletInfo
            .where()
            .walletIdProperty()
            .findAll())
        .toSet();
    final walletIdsToDelete = allWalletIds.difference(revertToState.walletIds);
    await MainDB.instance.isar.writeTxn(() async {
      await MainDB.instance.isar.walletInfo
          .deleteAllByWalletId(walletIdsToDelete.toList());
    });

    _cancelCompleter!.complete();
    _shouldCancelRestore = false;
    Logging.instance.log("Revert SWB complete", level: LogLevel.Info);
  }

  static Future<void> _restorePrefs(Map<String, dynamic> prefs) async {
    final _prefs = Prefs.instance;
    await _prefs.init();
    _prefs.currency = prefs['currency'] as String;
    // _prefs.useBiometrics = prefs['useBiometrics'] as bool;
    // _prefs.hasPin = prefs['hasPin'] as bool;
    _prefs.language = prefs['language'] as String;
    _prefs.showFavoriteWallets = prefs['showFavoriteWallets'] as bool;
    _prefs.wifiOnly = prefs['wifiOnly'] as bool;
    _prefs.syncType = prefs['syncType'] == "currentWalletOnly"
        ? SyncingType.currentWalletOnly
        : prefs['syncType'] == "selectedWalletsAtStartup"
            ? SyncingType.currentWalletOnly
            : SyncingType.allWalletsOnStartup; //
    _prefs.walletIdsSyncOnStartup =
        (prefs['walletIdsSyncOnStartup'] as List<dynamic>)
            .map<String>((e) => e as String)
            .toList();
    _prefs.showTestNetCoins = prefs['showTestNetCoins'] as bool;
    _prefs.isAutoBackupEnabled = prefs['isAutoBackupEnabled'] as bool;
    _prefs.autoBackupLocation = prefs['autoBackupLocation'] as String?;
    _prefs.backupFrequencyType = BackupFrequencyType.values.firstWhere(
      (e) => e.name == (prefs['backupFrequencyType'] as String?),
      orElse: () => BackupFrequencyType.everyAppStart,
    );
    _prefs.lastAutoBackup =
        DateTime.tryParse(prefs['lastAutoBackup'] as String? ?? "");
  }

  static Future<void> _restoreAddressBook(
    List<dynamic> addressBookEntries,
  ) async {
    final AddressBookService addressBookService = AddressBookService();
    for (final contact in addressBookEntries) {
      final List<ContactAddressEntry> addresses = [];
      for (final address in (contact['addresses'] as List<dynamic>)) {
        final entry = ContactAddressEntry()
          ..coinName = address['coin'] as String
          ..address = address['address'] as String
          ..label = address['label'] as String
          ..other = address['other'] as String?;

        try {
          entry.coin;
        } catch (_) {
          // coin not supported so ignore this entry
          continue;
        }

        addresses.add(
          entry,
        );
      }
      if (addresses.isNotEmpty) {
        await addressBookService.addContact(
          ContactEntry(
            emojiChar: contact['emoji'] as String?,
            name: contact['name'] as String,
            addresses: addresses,
            isFavorite: contact['isFavorite'] as bool,
            customId: contact['id'] as String,
          ),
        );
      }
    }
  }

  static Future<void> _restoreNodes(
    List<dynamic>? nodes,
    List<dynamic>? primaryNodes,
    SecureStorageInterface secureStorageInterface,
  ) async {
    final NodeService nodeService = NodeService(
      secureStorageInterface: secureStorageInterface,
    );
    if (nodes != null) {
      for (final node in nodes) {
        await nodeService.add(
          NodeModel(
            host: node['host'] as String,
            port: node['port'] as int,
            name: node['name'] as String,
            id: node['id'] as String,
            useSSL: node['useSSL'] == "false" ? false : true,
            enabled: node['enabled'] == "false" ? false : true,
            coinName: node['coinName'] as String,
            loginName: node['loginName'] as String?,
            isFailover: node['isFailover'] as bool,
            isDown: node['isDown'] as bool,
          ),
          node["password"] as String?,
          true,
        );
      }
    }
    if (primaryNodes != null) {
      for (final node in primaryNodes) {
        final CryptoCurrency coin;
        try {
          coin = AppConfig.getCryptoCurrencyByPrettyName(
            node['coinName'] as String,
          );
        } catch (_) {
          continue;
        }

        try {
          await nodeService.setPrimaryNodeFor(
            coin: coin,
            node: nodeService.getNodeById(id: node['id'] as String)!,
          );
        } catch (e, s) {
          Logging.instance.log("$e $s", level: LogLevel.Error);
        }
      }
    }
    await nodeService.updateDefaults();
  }

  static Future<void> _restoreTrades(
    List<dynamic> trades,
  ) async {
    final tradesService = TradesService();
    for (int i = 0; i < trades.length - 1; i++) {
      ExchangeTransaction? exTx;
      try {
        exTx = ExchangeTransaction.fromJson(trades[i] as Map<String, dynamic>);
      } catch (e) {
        // unneeded log
        // Logging.instance.log("$e\n$s", level: LogLevel.Warning);
      }

      Trade trade;
      if (exTx != null) {
        trade = Trade.fromExchangeTransaction(exTx, false);
      } else {
        trade = Trade.fromMap(trades[i] as Map<String, dynamic>);
      }

      await tradesService.add(
        trade: trade,
        shouldNotifyListeners: false,
      );
    }
    // only call notifyListeners on last one added
    if (trades.isNotEmpty) {
      ExchangeTransaction? exTx;
      try {
        exTx =
            ExchangeTransaction.fromJson(trades.last as Map<String, dynamic>);
      } catch (e) {
        // unneeded log
        // Logging.instance.log("$e\n$s", level: LogLevel.Warning);
      }

      Trade trade;
      if (exTx != null) {
        trade = Trade.fromExchangeTransaction(exTx, false);
      } else {
        trade = Trade.fromMap(trades.last as Map<String, dynamic>);
      }

      await tradesService.add(
        trade: trade,
        shouldNotifyListeners: true,
      );
    }
  }

  static Future<void> _restoreTradesLookUpData(
    List<dynamic> tradeTxidLookupData,
    Map<String, String> oldToNewWalletIdMap,
  ) async {
    final tradeTxidLookupDataService = TradeSentFromStackService();
    for (int i = 0; i < tradeTxidLookupData.length; i++) {
      final json = Map<String, dynamic>.from(tradeTxidLookupData[i] as Map);
      TradeWalletLookup lookup = TradeWalletLookup.fromJson(json);
      // update walletIds
      final List<String> walletIds =
          lookup.walletIds.map((e) => oldToNewWalletIdMap[e]!).toList();
      lookup = lookup.copyWith(walletIds: walletIds);

      final oldLookup = DB.instance.get<TradeWalletLookup>(
        boxName: DB.boxNameTradeLookup,
        key: lookup.uuid,
      );
      if (oldLookup != null) {
        if (oldLookup.txid == lookup.txid &&
            oldLookup.tradeId == lookup.tradeId) {
          final List<String> mergedList = oldLookup.walletIds;
          for (final id in lookup.walletIds) {
            if (!mergedList.contains(id)) {
              mergedList.add(id);
            }
          }
          lookup = lookup.copyWith(walletIds: walletIds);
        } else {
          lookup = TradeWalletLookup(
            uuid: const Uuid().v1(),
            txid: lookup.txid,
            tradeId: lookup.tradeId,
            walletIds: lookup.walletIds,
          );
        }
      }

      await tradeTxidLookupDataService.save(tradeWalletLookup: lookup);
    }
  }

  static Future<void> _restoreTradesNotes(
    Map<String, dynamic> tradeNotes,
  ) async {
    final tradeNotesService = TradeNotesService();
    for (final note in tradeNotes.entries) {
      await tradeNotesService.set(
        tradeId: note.key,
        note: note.value as String,
      );
    }
  }
}
