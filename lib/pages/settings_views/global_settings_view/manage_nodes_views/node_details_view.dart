/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/svg.dart';
import 'package:tuple/tuple.dart';

import '../../../../notifications/show_flush_bar.dart';
import '../../../../providers/global/active_wallet_provider.dart';
import '../../../../providers/global/secure_store_provider.dart';
import '../../../../providers/providers.dart';
import '../../../../themes/stack_colors.dart';
import '../../../../utilities/assets.dart';
import '../../../../utilities/enums/sync_type_enum.dart';
import '../../../../utilities/flutter_secure_storage_interface.dart';
import '../../../../utilities/test_node_connection.dart';
import '../../../../utilities/text_styles.dart';
import '../../../../utilities/tor_plain_net_option_enum.dart';
import '../../../../utilities/util.dart';
import '../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../widgets/background.dart';
import '../../../../widgets/conditional_parent.dart';
import '../../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../../widgets/desktop/delete_button.dart';
import '../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../widgets/desktop/primary_button.dart';
import '../../../../widgets/desktop/secondary_button.dart';
import 'add_edit_node_view.dart';

class NodeDetailsView extends ConsumerStatefulWidget {
  const NodeDetailsView({
    super.key,
    required this.coin,
    required this.nodeId,
    required this.popRouteName,
  });

  static const String routeName = "/nodeDetails";

  final CryptoCurrency coin;
  final String nodeId;
  final String popRouteName;

  @override
  ConsumerState<NodeDetailsView> createState() => _NodeDetailsViewState();
}

class _NodeDetailsViewState extends ConsumerState<NodeDetailsView> {
  late final SecureStorageInterface secureStore;
  late final CryptoCurrency coin;
  late final String nodeId;
  late final String popRouteName;

  bool _desktopReadOnly = true;

  Future<void> _notifyWalletsOfUpdatedNode() async {
    final wallets = ref
        .read(pWallets)
        .wallets
        .where((e) => e.info.coin == widget.coin);
    final prefs = ref.read(prefsChangeNotifierProvider);

    switch (prefs.syncType) {
      case SyncingType.currentWalletOnly:
        for (final wallet in wallets) {
          if (ref.read(currentWalletIdProvider) == wallet.walletId) {
            unawaited(wallet.updateNode().then((value) => wallet.refresh()));
          } else {
            unawaited(wallet.updateNode());
          }
        }
        break;
      case SyncingType.selectedWalletsAtStartup:
        final List<String> walletIdsToSync = prefs.walletIdsSyncOnStartup;
        for (final wallet in wallets) {
          if (walletIdsToSync.contains(wallet.walletId)) {
            unawaited(wallet.updateNode().then((value) => wallet.refresh()));
          } else {
            unawaited(wallet.updateNode());
          }
        }
        break;
      case SyncingType.allWalletsOnStartup:
        for (final wallet in wallets) {
          unawaited(wallet.updateNode().then((value) => wallet.refresh()));
        }
        break;
    }
  }

  @override
  initState() {
    secureStore = ref.read(secureStoreProvider);
    coin = widget.coin;
    nodeId = widget.nodeId;
    popRouteName = widget.popRouteName;
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final isDesktop = Util.isDesktop;

    final node = ref.watch(
      nodeServiceChangeNotifierProvider.select(
        (value) => value.getNodeById(id: nodeId),
      ),
    );

    final nodesForCoin = ref.watch(
      nodeServiceChangeNotifierProvider.select(
        (value) => value.getNodesFor(coin),
      ),
    );

    final canDelete = nodesForCoin.length > 1;

    return ConditionalParent(
      condition: !isDesktop,
      builder:
          (child) => Background(
            child: Scaffold(
              backgroundColor:
                  Theme.of(context).extension<StackColors>()!.background,
              appBar: AppBar(
                leading: AppBarBackButton(
                  onPressed: () async {
                    if (FocusScope.of(context).hasFocus) {
                      FocusScope.of(context).unfocus();
                      await Future<void>.delayed(
                        const Duration(milliseconds: 75),
                      );
                    }
                    if (context.mounted) {
                      Navigator.of(context).pop();
                    }
                  },
                ),
                title: Text(
                  "Node details",
                  style: STextStyles.navBarTitle(context),
                ),
                actions: [
                  // if (!nodeId.startsWith(DefaultNodes.defaultNodeIdPrefix))
                  Padding(
                    padding: const EdgeInsets.only(
                      top: 10,
                      bottom: 10,
                      right: 10,
                    ),
                    child: AspectRatio(
                      aspectRatio: 1,
                      child: AppBarIconButton(
                        key: const Key("nodeDetailsEditNodeAppBarButtonKey"),
                        size: 36,
                        shadows: const [],
                        color:
                            Theme.of(
                              context,
                            ).extension<StackColors>()!.background,
                        icon: SvgPicture.asset(
                          Assets.svg.pencil,
                          color:
                              Theme.of(
                                context,
                              ).extension<StackColors>()!.accentColorDark,
                          width: 20,
                          height: 20,
                        ),
                        onPressed: () {
                          Navigator.of(context).pushNamed(
                            AddEditNodeView.routeName,
                            arguments: Tuple4(
                              AddEditNodeViewType.edit,
                              coin,
                              nodeId,
                              popRouteName,
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ],
              ),
              body: SafeArea(
                child: Padding(
                  padding: const EdgeInsets.only(top: 12, left: 12, right: 12),
                  child: LayoutBuilder(
                    builder: (context, constraints) {
                      return SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.all(4),
                          child: ConstrainedBox(
                            constraints: BoxConstraints(
                              minHeight: constraints.maxHeight - 8,
                            ),
                            child: IntrinsicHeight(child: child),
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ),
            ),
          ),
      child: ConditionalParent(
        condition: isDesktop,
        builder:
            (child) => DesktopDialog(
              maxWidth: 580,
              maxHeight: double.infinity,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    children: [
                      const SizedBox(width: 8),
                      const AppBarBackButton(iconSize: 24, size: 40),
                      Text(
                        "Node details",
                        style: STextStyles.desktopH3(context),
                      ),
                    ],
                  ),
                  Padding(
                    padding: const EdgeInsets.only(
                      left: 32,
                      right: 32,
                      top: 16,
                      bottom: 32,
                    ),
                    child: child,
                  ),
                ],
              ),
            ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            NodeForm(
              node: node,
              secureStore: secureStore,
              readOnly: isDesktop ? _desktopReadOnly : true,
              coin: coin,
            ),
            if (!isDesktop) const Spacer(),
            if (isDesktop) const SizedBox(height: 22),
            if (isDesktop && canDelete)
              SizedBox(
                height: 56,
                child:
                    _desktopReadOnly
                        ? null
                        : Row(
                          children: [
                            Expanded(
                              child: DeleteButton(
                                label: "Delete node",
                                desktopMed: true,
                                onPressed: () async {
                                  Navigator.of(context).pop();

                                  await ref
                                      .read(nodeServiceChangeNotifierProvider)
                                      .delete(node!.id, true);
                                },
                              ),
                            ),
                            const SizedBox(width: 16),
                            const Spacer(),
                          ],
                        ),
              ),
            if (isDesktop && !_desktopReadOnly && canDelete)
              const SizedBox(height: 45),
            Row(
              children: [
                Expanded(
                  child: SecondaryButton(
                    label: "Test connection",
                    buttonHeight: isDesktop ? ButtonHeight.l : null,
                    onPressed: () async {
                      final node =
                          ref
                              .read(nodeServiceChangeNotifierProvider)
                              .getNodeById(id: nodeId)!;

                      final TorPlainNetworkOption netOption;
                      if (ref.read(nodeFormDataProvider).netOption != null) {
                        netOption = ref.read(nodeFormDataProvider).netOption!;
                      } else {
                        netOption = TorPlainNetworkOption.fromNodeData(
                          node.torEnabled,
                          node.clearnetEnabled,
                        );
                      }

                      final nodeFormData =
                          NodeFormData()
                            ..useSSL = node.useSSL
                            ..trusted = node.trusted
                            ..name = node.name
                            ..host = node.host
                            ..login = node.loginName
                            ..port = node.port
                            ..isFailover = node.isFailover
                            ..netOption = netOption
                            ..forceNoTor = node.forceNoTor;
                      nodeFormData.password = await node.getPassword(
                        ref.read(secureStoreProvider),
                      );

                      if (context.mounted) {
                        final testPassed = await testNodeConnection(
                          context: context,
                          nodeFormData: nodeFormData,
                          cryptoCurrency: coin,
                          ref: ref,
                        );

                        if (testPassed) {
                          if (context.mounted) {
                            unawaited(
                              showFloatingFlushBar(
                                type: FlushBarType.success,
                                message: "Server ping success",
                                context: context,
                              ),
                            );
                          }
                        } else {
                          if (context.mounted) {
                            unawaited(
                              showFloatingFlushBar(
                                type: FlushBarType.warning,
                                message: "Server unreachable",
                                context: context,
                              ),
                            );
                          }
                        }
                      }
                    },
                  ),
                ),
                if (isDesktop) const SizedBox(width: 16),
                if (isDesktop)
                  Expanded(
                    child:
                    // !nodeId.startsWith(DefaultNodes.defaultNodeIdPrefix)
                    //     ?
                    PrimaryButton(
                      label: _desktopReadOnly ? "Edit" : "Save",
                      buttonHeight: ButtonHeight.l,
                      onPressed: () async {
                        final shouldSave = _desktopReadOnly == false;
                        setState(() {
                          _desktopReadOnly = !_desktopReadOnly;
                        });

                        if (shouldSave) {
                          final editedNode = node!.copyWith(
                            host: ref.read(nodeFormDataProvider).host,
                            port: ref.read(nodeFormDataProvider).port,
                            name: ref.read(nodeFormDataProvider).name,
                            useSSL: ref.read(nodeFormDataProvider).useSSL,
                            trusted: ref.read(nodeFormDataProvider).trusted,
                            loginName: ref.read(nodeFormDataProvider).login,
                            isFailover:
                                ref.read(nodeFormDataProvider).isFailover,
                            torEnabled:
                                ref.read(nodeFormDataProvider).netOption ==
                                    TorPlainNetworkOption.tor ||
                                ref.read(nodeFormDataProvider).netOption ==
                                    TorPlainNetworkOption.both,
                            clearnetEnabled:
                                ref.read(nodeFormDataProvider).netOption ==
                                    TorPlainNetworkOption.clear ||
                                ref.read(nodeFormDataProvider).netOption ==
                                    TorPlainNetworkOption.both,
                            forceNoTor:
                                ref.read(nodeFormDataProvider).forceNoTor,
                          );

                          await ref
                              .read(nodeServiceChangeNotifierProvider)
                              .edit(
                                editedNode,
                                ref.read(nodeFormDataProvider).password,
                                true,
                              );
                          await _notifyWalletsOfUpdatedNode();
                        }
                      },
                    ),
                    // : Container()
                  ),
              ],
            ),
            if (!isDesktop) const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }
}
