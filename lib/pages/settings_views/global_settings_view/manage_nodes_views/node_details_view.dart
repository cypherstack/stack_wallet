/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/svg.dart';
import 'package:stackwallet/electrumx_rpc/electrumx_client.dart';
import 'package:stackwallet/models/node_model.dart';
import 'package:stackwallet/notifications/show_flush_bar.dart';
import 'package:stackwallet/pages/settings_views/global_settings_view/manage_nodes_views/add_edit_node_view.dart';
import 'package:stackwallet/providers/global/secure_store_provider.dart';
import 'package:stackwallet/providers/providers.dart';
import 'package:stackwallet/themes/stack_colors.dart';
import 'package:stackwallet/utilities/assets.dart';
import 'package:stackwallet/utilities/enums/coin_enum.dart';
import 'package:stackwallet/utilities/flutter_secure_storage_interface.dart';
import 'package:stackwallet/utilities/logger.dart';
import 'package:stackwallet/utilities/test_epic_box_connection.dart';
import 'package:stackwallet/utilities/test_eth_node_connection.dart';
import 'package:stackwallet/utilities/test_monero_node_connection.dart';
import 'package:stackwallet/utilities/test_stellar_node_connection.dart';
import 'package:stackwallet/utilities/text_styles.dart';
import 'package:stackwallet/utilities/util.dart';
import 'package:stackwallet/wallets/api/tezos/tezos_rpc_api.dart';
import 'package:stackwallet/widgets/background.dart';
import 'package:stackwallet/widgets/conditional_parent.dart';
import 'package:stackwallet/widgets/custom_buttons/app_bar_icon_button.dart';
import 'package:stackwallet/widgets/desktop/delete_button.dart';
import 'package:stackwallet/widgets/desktop/desktop_dialog.dart';
import 'package:stackwallet/widgets/desktop/primary_button.dart';
import 'package:stackwallet/widgets/desktop/secondary_button.dart';
import 'package:tuple/tuple.dart';

class NodeDetailsView extends ConsumerStatefulWidget {
  const NodeDetailsView({
    super.key,
    required this.coin,
    required this.nodeId,
    required this.popRouteName,
  });

  static const String routeName = "/nodeDetails";

  final Coin coin;
  final String nodeId;
  final String popRouteName;

  @override
  ConsumerState<NodeDetailsView> createState() => _NodeDetailsViewState();
}

class _NodeDetailsViewState extends ConsumerState<NodeDetailsView> {
  late final SecureStorageInterface secureStore;
  late final Coin coin;
  late final String nodeId;
  late final String popRouteName;

  bool _desktopReadOnly = true;

  @override
  initState() {
    secureStore = ref.read(secureStoreProvider);
    coin = widget.coin;
    nodeId = widget.nodeId;
    popRouteName = widget.popRouteName;
    super.initState();
  }

  Future<void> _testConnection(WidgetRef ref, BuildContext context) async {
    final node =
        ref.watch(nodeServiceChangeNotifierProvider).getNodeById(id: nodeId);

    bool testPassed = false;

    switch (coin) {
      case Coin.epicCash:
        try {
          testPassed = await testEpicNodeConnection(
                NodeFormData()
                  ..host = node!.host
                  ..useSSL = node.useSSL
                  ..port = node.port,
              ) !=
              null;
        } catch (e, s) {
          Logging.instance.log("$e\n$s", level: LogLevel.Warning);
          testPassed = false;
        }
        break;

      case Coin.monero:
      case Coin.monerodart:
      case Coin.wownero:
      case Coin.wownerodart:
        try {
          final uri = Uri.parse(node!.host);
          if (uri.scheme.startsWith("http")) {
            final String path = uri.path.isEmpty ? "/json_rpc" : uri.path;

            String uriString = "${uri.scheme}://${uri.host}:${node.port}$path";

            final response = await testMoneroNodeConnection(
              Uri.parse(uriString),
              false,
            );

            if (response.cert != null) {
              if (mounted) {
                final shouldAllowBadCert = await showBadX509CertificateDialog(
                  response.cert!,
                  response.url!,
                  response.port!,
                  context,
                );

                if (shouldAllowBadCert) {
                  final response = await testMoneroNodeConnection(
                      Uri.parse(uriString), true);
                  testPassed = response.success;
                }
              }
            } else {
              testPassed = response.success;
            }
          }
        } catch (e, s) {
          Logging.instance.log("$e\n$s", level: LogLevel.Warning);
        }

        break;

      case Coin.bitcoin:
      case Coin.litecoin:
      case Coin.dogecoin:
      case Coin.firo:
      case Coin.particl:
      case Coin.bitcoinTestNet:
      case Coin.firoTestNet:
      case Coin.dogecoinTestNet:
      case Coin.bitcoincash:
      case Coin.namecoin:
      case Coin.litecoinTestNet:
      case Coin.bitcoincashTestnet:
      case Coin.eCash:
      case Coin.bitcoinFrost:
      case Coin.bitcoinFrostTestNet:
        final client = ElectrumXClient(
          host: node!.host,
          port: node.port,
          useSSL: node.useSSL,
          failovers: [],
          prefs: ref.read(prefsChangeNotifierProvider),
          coin: coin,
        );

        try {
          testPassed = await client.ping();
        } catch (_) {
          testPassed = false;
        }

        break;

      case Coin.ethereum:
        try {
          testPassed = await testEthNodeConnection(node!.host);
        } catch (_) {
          testPassed = false;
        }
        break;

      case Coin.nano:
      case Coin.banano:
        // TODO: fix this lacking code
        throw UnimplementedError();
      //TODO: check network/node
      case Coin.tezos:
        try {
          testPassed = await TezosRpcAPI.testNetworkConnection(
            nodeInfo: (host: node!.host, port: (node as NodeModel).port),
          );
        } catch (_) {}
        break;
      case Coin.stellar:
      case Coin.stellarTestnet:
        try {
          testPassed = await testStellarNodeConnection(node!.host, node.port);
        } catch (_) {
          testPassed = false;
        }
        break;
    }

    if (testPassed) {
      unawaited(
        showFloatingFlushBar(
          type: FlushBarType.success,
          message: "Server ping success",
          context: context,
        ),
      );
    } else {
      unawaited(
        showFloatingFlushBar(
          type: FlushBarType.warning,
          message: "Server unreachable",
          context: context,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDesktop = Util.isDesktop;

    final node = ref.watch(nodeServiceChangeNotifierProvider
        .select((value) => value.getNodeById(id: nodeId)));

    final nodesForCoin = ref.watch(nodeServiceChangeNotifierProvider
        .select((value) => value.getNodesFor(coin)));

    final canDelete = nodesForCoin.length > 1;

    return ConditionalParent(
      condition: !isDesktop,
      builder: (child) => Background(
        child: Scaffold(
          backgroundColor:
              Theme.of(context).extension<StackColors>()!.background,
          appBar: AppBar(
            leading: AppBarBackButton(
              onPressed: () async {
                if (FocusScope.of(context).hasFocus) {
                  FocusScope.of(context).unfocus();
                  await Future<void>.delayed(const Duration(milliseconds: 75));
                }
                if (mounted) {
                  Navigator.of(context).pop();
                }
              },
            ),
            title: Text(
              "Node details",
              style: STextStyles.navBarTitle(context),
            ),
            actions: [
              // if (!nodeId.startsWith(DefaultNodes.defaultNodeIdPrefix))
              Padding(
                padding: const EdgeInsets.only(
                  top: 10,
                  bottom: 10,
                  right: 10,
                ),
                child: AspectRatio(
                  aspectRatio: 1,
                  child: AppBarIconButton(
                    key: const Key("nodeDetailsEditNodeAppBarButtonKey"),
                    size: 36,
                    shadows: const [],
                    color:
                        Theme.of(context).extension<StackColors>()!.background,
                    icon: SvgPicture.asset(
                      Assets.svg.pencil,
                      color: Theme.of(context)
                          .extension<StackColors>()!
                          .accentColorDark,
                      width: 20,
                      height: 20,
                    ),
                    onPressed: () {
                      Navigator.of(context).pushNamed(
                        AddEditNodeView.routeName,
                        arguments: Tuple4(
                          AddEditNodeViewType.edit,
                          coin,
                          nodeId,
                          popRouteName,
                        ),
                      );
                    },
                  ),
                ),
              ),
            ],
          ),
          body: Padding(
            padding: const EdgeInsets.only(
              top: 12,
              left: 12,
              right: 12,
            ),
            child: LayoutBuilder(
              builder: (context, constraints) {
                return SingleChildScrollView(
                  child: Padding(
                    padding: const EdgeInsets.all(4),
                    child: ConstrainedBox(
                      constraints:
                          BoxConstraints(minHeight: constraints.maxHeight - 8),
                      child: IntrinsicHeight(
                        child: child,
                      ),
                    ),
                  ),
                );
              },
            ),
          ),
        ),
      ),
      child: ConditionalParent(
        condition: isDesktop,
        builder: (child) => DesktopDialog(
          maxWidth: 580,
          maxHeight: double.infinity,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  const SizedBox(
                    width: 8,
                  ),
                  const AppBarBackButton(
                    iconSize: 24,
                    size: 40,
                  ),
                  Text(
                    "Node details",
                    style: STextStyles.desktopH3(context),
                  )
                ],
              ),
              Padding(
                padding: const EdgeInsets.only(
                  left: 32,
                  right: 32,
                  top: 16,
                  bottom: 32,
                ),
                child: child,
              ),
            ],
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            NodeForm(
              node: node,
              secureStore: secureStore,
              readOnly: isDesktop ? _desktopReadOnly : true,
              coin: coin,
            ),
            if (!isDesktop) const Spacer(),
            if (isDesktop)
              const SizedBox(
                height: 22,
              ),
            if (isDesktop && canDelete)
              SizedBox(
                height: 56,
                child: _desktopReadOnly
                    ? null
                    : Row(
                        children: [
                          Expanded(
                            child: DeleteButton(
                              label: "Delete node",
                              desktopMed: true,
                              onPressed: () async {
                                Navigator.of(context).pop();

                                await ref
                                    .read(nodeServiceChangeNotifierProvider)
                                    .delete(
                                      node!.id,
                                      true,
                                    );
                              },
                            ),
                          ),
                          const SizedBox(
                            width: 16,
                          ),
                          const Spacer(),
                        ],
                      ),
              ),
            if (isDesktop && !_desktopReadOnly && canDelete)
              const SizedBox(
                height: 45,
              ),
            Row(
              children: [
                Expanded(
                  child: SecondaryButton(
                    label: "Test connection",
                    buttonHeight: isDesktop ? ButtonHeight.l : null,
                    onPressed: () async {
                      await _testConnection(ref, context);
                    },
                  ),
                ),
                if (isDesktop)
                  const SizedBox(
                    width: 16,
                  ),
                if (isDesktop)
                  Expanded(
                    child:
                        // !nodeId.startsWith(DefaultNodes.defaultNodeIdPrefix)
                        //     ?
                        PrimaryButton(
                      label: _desktopReadOnly ? "Edit" : "Save",
                      buttonHeight: ButtonHeight.l,
                      onPressed: () async {
                        final shouldSave = _desktopReadOnly == false;
                        setState(() {
                          _desktopReadOnly = !_desktopReadOnly;
                        });

                        if (shouldSave) {
                          final editedNode = node!.copyWith(
                            host: ref.read(nodeFormDataProvider).host,
                            port: ref.read(nodeFormDataProvider).port,
                            name: ref.read(nodeFormDataProvider).name,
                            useSSL: ref.read(nodeFormDataProvider).useSSL,
                            trusted: ref.read(nodeFormDataProvider).trusted,
                            loginName: ref.read(nodeFormDataProvider).login,
                            isFailover:
                                ref.read(nodeFormDataProvider).isFailover,
                          );

                          await ref
                              .read(nodeServiceChangeNotifierProvider)
                              .edit(
                                editedNode,
                                ref.read(nodeFormDataProvider).password,
                                true,
                              );
                        }
                      },
                    )
                    // : Container()
                    ,
                  ),
              ],
            ),
            if (!isDesktop)
              const SizedBox(
                height: 16,
              ),
          ],
        ),
      ),
    );
  }
}
