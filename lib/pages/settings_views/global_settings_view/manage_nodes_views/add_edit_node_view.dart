/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'dart:async';

import 'package:barcode_scan2/barcode_scan2.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:uuid/uuid.dart';

import '../../../../models/node_model.dart';
import '../../../../notifications/show_flush_bar.dart';
import '../../../../providers/global/active_wallet_provider.dart';
import '../../../../providers/global/secure_store_provider.dart';
import '../../../../providers/providers.dart';
import '../../../../themes/stack_colors.dart';
import '../../../../utilities/assets.dart';
import '../../../../utilities/constants.dart';
import '../../../../utilities/enums/sync_type_enum.dart';
import '../../../../utilities/flutter_secure_storage_interface.dart';
import '../../../../utilities/logger.dart';
import '../../../../utilities/node_uri_util.dart';
import '../../../../utilities/test_node_connection.dart';
import '../../../../utilities/text_styles.dart';
import '../../../../utilities/tor_plain_net_option_enum.dart';
import '../../../../utilities/util.dart';
import '../../../../wallets/crypto_currency/crypto_currency.dart';
import '../../../../wallets/crypto_currency/intermediate/cryptonote_currency.dart';
import '../../../../wallets/wallet/intermediate/lib_monero_wallet.dart';
import '../../../../widgets/background.dart';
import '../../../../widgets/conditional_parent.dart';
import '../../../../widgets/custom_buttons/app_bar_icon_button.dart';
import '../../../../widgets/desktop/desktop_dialog.dart';
import '../../../../widgets/desktop/primary_button.dart';
import '../../../../widgets/desktop/qr_code_scanner_dialog.dart';
import '../../../../widgets/desktop/secondary_button.dart';
import '../../../../widgets/icon_widgets/qrcode_icon.dart';
import '../../../../widgets/icon_widgets/x_icon.dart';
import '../../../../widgets/stack_dialog.dart';
import '../../../../widgets/stack_text_field.dart';
import '../../../../widgets/textfield_icon_button.dart';
// import 'package:web3dart/web3dart.dart';

enum AddEditNodeViewType { add, edit }

class AddEditNodeView extends ConsumerStatefulWidget {
  const AddEditNodeView({
    super.key,
    required this.viewType,
    required this.coin,
    required this.nodeId,
    required this.routeOnSuccessOrDelete,
  });

  static const String routeName = "/addEditNode";

  final AddEditNodeViewType viewType;
  final CryptoCurrency coin;
  final String routeOnSuccessOrDelete;
  final String? nodeId;

  @override
  ConsumerState<AddEditNodeView> createState() => _AddEditNodeViewState();
}

class _AddEditNodeViewState extends ConsumerState<AddEditNodeView> {
  late final AddEditNodeViewType viewType;
  late final CryptoCurrency coin;
  late final String? nodeId;
  late final bool isDesktop;

  (NodeModel, String)? _scannedResult;

  late bool saveEnabled;
  late bool testConnectionEnabled;

  void _onTestSuccess(NodeFormData data) {
    if (coin is Epiccash) {
      ref.read(nodeFormDataProvider).host = data.host;
      ref.read(nodeFormDataProvider).port = data.port;
      ref.read(nodeFormDataProvider).useSSL = data.useSSL;
    } else if (coin is CryptonoteCurrency) {
      ref.read(nodeFormDataProvider).host = data.host;
    }
  }

  Future<void> attemptSave() async {
    final canConnect = await testNodeConnection(
      context: context,
      onSuccess: _onTestSuccess,
      cryptoCurrency: coin,
      nodeFormData: ref.read(nodeFormDataProvider),
      ref: ref,
    );

    bool? shouldSave;

    if (!canConnect && mounted) {
      await showDialog<dynamic>(
        context: context,
        useSafeArea: true,
        barrierDismissible: true,
        builder: (_) => isDesktop
            ? DesktopDialog(
                maxWidth: 440,
                maxHeight: 300,
                child: Column(
                  children: [
                    Padding(
                      padding: const EdgeInsets.only(
                        top: 32,
                      ),
                      child: Row(
                        children: [
                          const SizedBox(
                            width: 32,
                          ),
                          Text(
                            "Server currently unreachable",
                            style: STextStyles.desktopH3(context),
                          ),
                        ],
                      ),
                    ),
                    Expanded(
                      child: Padding(
                        padding: const EdgeInsets.only(
                          left: 32,
                          right: 32,
                          top: 16,
                          bottom: 32,
                        ),
                        child: Column(
                          children: [
                            const Spacer(),
                            Text(
                              "Would you like to save this node anyways?",
                              style: STextStyles.desktopTextMedium(context),
                            ),
                            const Spacer(
                              flex: 2,
                            ),
                            Row(
                              children: [
                                Expanded(
                                  child: SecondaryButton(
                                    label: "Cancel",
                                    buttonHeight:
                                        isDesktop ? ButtonHeight.l : null,
                                    onPressed: () => Navigator.of(
                                      context,
                                      rootNavigator: true,
                                    ).pop(false),
                                  ),
                                ),
                                const SizedBox(
                                  width: 16,
                                ),
                                Expanded(
                                  child: PrimaryButton(
                                    label: "Save",
                                    buttonHeight:
                                        isDesktop ? ButtonHeight.l : null,
                                    onPressed: () => Navigator.of(
                                      context,
                                      rootNavigator: true,
                                    ).pop(true),
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              )
            : StackDialog(
                title: "Server currently unreachable",
                message: "Would you like to save this node anyways?",
                leftButton: TextButton(
                  onPressed: () async {
                    Navigator.of(context).pop(false);
                  },
                  child: Text(
                    "Cancel",
                    style: STextStyles.button(context).copyWith(
                      color: Theme.of(context)
                          .extension<StackColors>()!
                          .accentColorDark,
                    ),
                  ),
                ),
                rightButton: TextButton(
                  onPressed: () async {
                    Navigator.of(context).pop(true);
                  },
                  style: Theme.of(context)
                      .extension<StackColors>()!
                      .getPrimaryEnabledButtonStyle(context),
                  child: Text(
                    "Save",
                    style: STextStyles.button(context),
                  ),
                ),
              ),
      ).then((value) {
        if (value is bool && value) {
          shouldSave = true;
        } else {
          shouldSave = false;
        }
      });
    }

    if (!canConnect && !shouldSave!) {
      // return without saving
      return;
    }

    final formData = ref.read(nodeFormDataProvider);

    // strip unused path
    String address = formData.host!;
    if (coin is LibMoneroWallet) {
      if (address.startsWith("http")) {
        final uri = Uri.parse(address);
        address = "${uri.scheme}://${uri.host}";
      }
    }

    final torEnabled = formData.netOption == TorPlainNetworkOption.tor ||
        formData.netOption == TorPlainNetworkOption.both;
    final plainEnabled = formData.netOption == TorPlainNetworkOption.clear ||
        formData.netOption == TorPlainNetworkOption.both;

    switch (viewType) {
      case AddEditNodeViewType.add:
        final NodeModel node = NodeModel(
          host: address,
          port: formData.port!,
          name: formData.name!,
          id: const Uuid().v1(),
          useSSL: formData.useSSL!,
          loginName: formData.login,
          enabled: true,
          coinName: coin.identifier,
          isFailover: formData.isFailover!,
          trusted: formData.trusted!,
          isDown: false,
          torEnabled: torEnabled,
          clearnetEnabled: plainEnabled,
        );

        await ref.read(nodeServiceChangeNotifierProvider).add(
              node,
              formData.password,
              true,
            );
        await _notifyWalletsOfUpdatedNode();
        if (mounted) {
          Navigator.of(context)
              .popUntil(ModalRoute.withName(widget.routeOnSuccessOrDelete));
        }
        break;
      case AddEditNodeViewType.edit:
        final NodeModel node = NodeModel(
          host: address,
          port: formData.port!,
          name: formData.name!,
          id: nodeId!,
          useSSL: formData.useSSL!,
          loginName: formData.login,
          enabled: true,
          coinName: coin.identifier,
          isFailover: formData.isFailover!,
          trusted: formData.trusted!,
          isDown: false,
          torEnabled: torEnabled,
          clearnetEnabled: plainEnabled,
        );

        await ref.read(nodeServiceChangeNotifierProvider).add(
              node,
              formData.password,
              true,
            );
        await _notifyWalletsOfUpdatedNode();
        if (mounted) {
          Navigator.of(context)
              .popUntil(ModalRoute.withName(widget.routeOnSuccessOrDelete));
        }
        break;
    }
  }

  Future<void> _notifyWalletsOfUpdatedNode() async {
    final wallets =
        ref.read(pWallets).wallets.where((e) => e.info.coin == widget.coin);
    final prefs = ref.read(prefsChangeNotifierProvider);

    switch (prefs.syncType) {
      case SyncingType.currentWalletOnly:
        for (final wallet in wallets) {
          if (ref.read(currentWalletIdProvider) == wallet.walletId) {
            unawaited(wallet.updateNode().then((value) => wallet.refresh()));
          } else {
            unawaited(wallet.updateNode());
          }
        }
        break;
      case SyncingType.selectedWalletsAtStartup:
        final List<String> walletIdsToSync = prefs.walletIdsSyncOnStartup;
        for (final wallet in wallets) {
          if (walletIdsToSync.contains(wallet.walletId)) {
            unawaited(wallet.updateNode().then((value) => wallet.refresh()));
          } else {
            unawaited(wallet.updateNode());
          }
        }
        break;
      case SyncingType.allWalletsOnStartup:
        for (final wallet in wallets) {
          unawaited(wallet.updateNode().then((value) => wallet.refresh()));
        }
        break;
    }
  }

  bool _scanLock = false;

  void _scanQr() async {
    if (_scanLock) return;
    _scanLock = true;
    try {
      if (Util.isDesktop) {
        try {
          final qrResult = await showDialog<String>(
            context: context,
            builder: (context) => const QrCodeScannerDialog(),
          );

          if (qrResult == null) {
            Logging.instance.d("Qr scanning cancelled");
          } else {
            try {
              await _processQrData(qrResult);
            } catch (e, s) {
              Logging.instance.e("Error processing QR code data: ",
                  error: e, stackTrace: s);
            }
          }
        } catch (e, s) {
          Logging.instance.e("Error opening QR code scanner dialog: ",
              error: e, stackTrace: s);
        }
      } else {
        try {
          final result = await BarcodeScanner.scan();
          await _processQrData(result.rawContent);
        } catch (e, s) {
          Logging.instance.e(
            "$runtimeType._scanQr()",
            error: e,
            stackTrace: s,
          );
        }
      }
    } finally {
      _scanLock = false;
    }
  }

  Future<void> _processQrData(String data) async {
    try {
      final nodeQrData = NodeQrUtil.decodeUri(data);
      if (mounted) {
        setState(() {
          _scannedResult = (
            NodeModel(
              host: nodeQrData.host,
              port: nodeQrData.port,
              name: nodeQrData.label ?? "",
              id: const Uuid().v1(),
              useSSL: nodeQrData.scheme == "https",
              enabled: true,
              coinName: coin.identifier,
              isFailover: true,
              isDown: false,
              torEnabled: true,
              clearnetEnabled: !nodeQrData.host.endsWith(".onion"),
              loginName: (nodeQrData as LibMoneroNodeQrData?)?.user,
            ),
            (nodeQrData as LibMoneroNodeQrData?)?.password ?? ""
          );
        });
      }
    } catch (e, s) {
      Logging.instance.w(
        "$e\n$s",
        error: e,
        stackTrace: s,
      );
    }
  }

  @override
  void initState() {
    isDesktop = Util.isDesktop;
    ref.refresh(nodeFormDataProvider);

    viewType = widget.viewType;
    coin = widget.coin;
    nodeId = widget.nodeId;

    if (nodeId == null) {
      saveEnabled = false;
      testConnectionEnabled = false;
    } else {
      final node =
          ref.read(nodeServiceChangeNotifierProvider).getNodeById(id: nodeId!)!;
      testConnectionEnabled = node.host.isNotEmpty;
      saveEnabled = testConnectionEnabled && node.name.isNotEmpty;
    }

    super.initState();
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final NodeModel? node =
        viewType == AddEditNodeViewType.edit && nodeId != null
            ? ref.watch(
                nodeServiceChangeNotifierProvider
                    .select((value) => value.getNodeById(id: nodeId!)),
              )
            : null;

    return ConditionalParent(
      condition: !isDesktop,
      builder: (child) => Background(
        child: Scaffold(
          backgroundColor:
              Theme.of(context).extension<StackColors>()!.background,
          appBar: AppBar(
            leading: AppBarBackButton(
              onPressed: () async {
                if (FocusScope.of(context).hasFocus) {
                  FocusScope.of(context).unfocus();
                  await Future<void>.delayed(const Duration(milliseconds: 75));
                }
                if (context.mounted) {
                  Navigator.of(context).pop();
                }
              },
            ),
            title: Text(
              viewType == AddEditNodeViewType.edit ? "Edit node" : "Add node",
              style: STextStyles.navBarTitle(context),
            ),
            actions: [
              if (viewType == AddEditNodeViewType.add &&
                  coin
                      is CryptonoteCurrency) // TODO: [prio=low] do something other than `coin is CryptonoteCurrency` in the future
                Padding(
                  padding: const EdgeInsets.only(
                    top: 10,
                    bottom: 10,
                    right: 10,
                  ),
                  child: AspectRatio(
                    aspectRatio: 1,
                    child: AppBarIconButton(
                      key: const Key("qrNodeAppBarButtonKey"),
                      size: 36,
                      shadows: const [],
                      color: Theme.of(context)
                          .extension<StackColors>()!
                          .background,
                      icon: QrCodeIcon(
                        width: 20,
                        height: 20,
                        color: Theme.of(context)
                            .extension<StackColors>()!
                            .accentColorDark,
                      ),
                      onPressed: _scanQr,
                    ),
                  ),
                ),
              if (viewType == AddEditNodeViewType.edit &&
                  ref
                          .watch(
                            nodeServiceChangeNotifierProvider
                                .select((value) => value.getNodesFor(coin)),
                          )
                          .length >
                      1)
                Padding(
                  padding: const EdgeInsets.only(
                    top: 10,
                    bottom: 10,
                    right: 10,
                  ),
                  child: AspectRatio(
                    aspectRatio: 1,
                    child: AppBarIconButton(
                      key: const Key("deleteNodeAppBarButtonKey"),
                      size: 36,
                      shadows: const [],
                      color: Theme.of(context)
                          .extension<StackColors>()!
                          .background,
                      icon: SvgPicture.asset(
                        Assets.svg.trash,
                        color: Theme.of(context)
                            .extension<StackColors>()!
                            .accentColorDark,
                        width: 20,
                        height: 20,
                      ),
                      onPressed: () async {
                        Navigator.popUntil(
                          context,
                          ModalRoute.withName(widget.routeOnSuccessOrDelete),
                        );

                        await ref
                            .read(nodeServiceChangeNotifierProvider)
                            .delete(
                              nodeId!,
                              true,
                            );
                      },
                    ),
                  ),
                ),
            ],
          ),
          body: Padding(
            padding: const EdgeInsets.only(
              top: 12,
              left: 12,
              right: 12,
              bottom: 12,
            ),
            child: LayoutBuilder(
              builder: (context, constraints) {
                return SingleChildScrollView(
                  child: Padding(
                    padding: const EdgeInsets.all(4),
                    child: ConstrainedBox(
                      constraints:
                          BoxConstraints(minHeight: constraints.maxHeight - 8),
                      child: IntrinsicHeight(
                        child: child,
                      ),
                    ),
                  ),
                );
              },
            ),
          ),
        ),
      ),
      child: ConditionalParent(
        condition: isDesktop,
        builder: (child) => DesktopDialog(
          maxWidth: 580,
          maxHeight: double.infinity,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(
                height: 8,
              ),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      const SizedBox(
                        width: 8,
                      ),
                      const AppBarBackButton(
                        iconSize: 24,
                        size: 40,
                      ),
                      Text(
                        "Add new node",
                        style: STextStyles.desktopH3(context),
                      ),
                    ],
                  ),
                  if (coin
                      is CryptonoteCurrency) // TODO: [prio=low] do something other than `coin is CryptonoteCurrency` in the future
                    Padding(
                      padding: const EdgeInsets.only(right: 32),
                      child: AppBarIconButton(
                        size: 40,
                        color: isDesktop
                            ? Theme.of(context)
                                .extension<StackColors>()!
                                .textFieldDefaultBG
                            : Theme.of(context)
                                .extension<StackColors>()!
                                .background,
                        icon: const QrCodeIcon(
                          width: 21,
                          height: 21,
                        ),
                        onPressed: _scanQr,
                      ),
                    ),
                ],
              ),
              Padding(
                padding: const EdgeInsets.only(
                  left: 32,
                  right: 32,
                  top: 16,
                  bottom: 32,
                ),
                child: child,
              ),
            ],
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            NodeForm(
              key: Key((node ?? _scannedResult?.$1)?.id ?? "none"),
              node: node ?? _scannedResult?.$1,
              scannedPw: _scannedResult?.$2,
              secureStore: ref.read(secureStoreProvider),
              readOnly: false,
              coin: widget.coin,
              onChanged: (canSave, canTest) {
                if (canSave != saveEnabled &&
                    canTest != testConnectionEnabled) {
                  setState(() {
                    saveEnabled = canSave;
                    testConnectionEnabled = canTest;
                  });
                } else if (canSave != saveEnabled) {
                  setState(() {
                    saveEnabled = canSave;
                  });
                } else if (canTest != testConnectionEnabled) {
                  setState(() {
                    testConnectionEnabled = canTest;
                  });
                }
              },
            ),
            if (!isDesktop) const Spacer(),
            if (isDesktop)
              const SizedBox(
                height: 78,
              ),
            Row(
              children: [
                Expanded(
                  child: SecondaryButton(
                    label: "Test connection",
                    enabled: testConnectionEnabled,
                    buttonHeight: isDesktop ? ButtonHeight.l : null,
                    onPressed: testConnectionEnabled
                        ? () async {
                            final testPassed = await testNodeConnection(
                              context: context,
                              onSuccess: _onTestSuccess,
                              cryptoCurrency: coin,
                              nodeFormData: ref.read(nodeFormDataProvider),
                              ref: ref,
                            );
                            if (context.mounted) {
                              if (testPassed) {
                                unawaited(
                                  showFloatingFlushBar(
                                    type: FlushBarType.success,
                                    message: "Server ping success",
                                    context: context,
                                  ),
                                );
                              } else {
                                unawaited(
                                  showFloatingFlushBar(
                                    type: FlushBarType.warning,
                                    message: "Server unreachable",
                                    context: context,
                                  ),
                                );
                              }
                            }
                          }
                        : null,
                  ),
                ),
                if (isDesktop)
                  const SizedBox(
                    width: 16,
                  ),
                if (isDesktop)
                  Expanded(
                    child: PrimaryButton(
                      label: "Save",
                      enabled: saveEnabled,
                      buttonHeight: ButtonHeight.l,
                      onPressed: saveEnabled ? attemptSave : null,
                    ),
                  ),
              ],
            ),
            if (!isDesktop)
              const SizedBox(
                height: 16,
              ),
            if (!isDesktop)
              TextButton(
                style: saveEnabled
                    ? Theme.of(context)
                        .extension<StackColors>()!
                        .getPrimaryEnabledButtonStyle(context)
                    : Theme.of(context)
                        .extension<StackColors>()!
                        .getPrimaryDisabledButtonStyle(context),
                onPressed: saveEnabled ? attemptSave : null,
                child: Text(
                  "Save",
                  style: STextStyles.button(context),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class NodeFormData {
  String? name, host, login, password;
  int? port;
  bool? useSSL, isFailover, trusted;
  TorPlainNetworkOption? netOption;

  @override
  String toString() {
    return "{ name: $name, host: $host, port: $port, useSSL: $useSSL, trusted: $trusted, netOption: $netOption }";
  }
}

final nodeFormDataProvider = Provider<NodeFormData>((_) => NodeFormData());

class NodeForm extends ConsumerStatefulWidget {
  const NodeForm({
    super.key,
    this.node,
    this.scannedPw,
    required this.secureStore,
    required this.readOnly,
    required this.coin,
    this.onChanged,
  });

  final NodeModel? node;
  final String? scannedPw;
  final SecureStorageInterface secureStore;
  final bool readOnly;
  final CryptoCurrency coin;
  final void Function(bool canSave, bool canTestConnection)? onChanged;

  @override
  ConsumerState<NodeForm> createState() => _NodeFormState();
}

class _NodeFormState extends ConsumerState<NodeForm> {
  late final TextEditingController _nameController;
  late final TextEditingController _hostController;
  late final TextEditingController _portController;
  late final TextEditingController _passwordController;
  late final TextEditingController _usernameController;

  final _nameFocusNode = FocusNode();
  final _passwordFocusNode = FocusNode();
  final _portFocusNode = FocusNode();
  final _hostFocusNode = FocusNode();
  final _usernameFocusNode = FocusNode();

  bool _useSSL = false;
  bool _isFailover = false;
  bool _trusted = false;
  int? port;
  late bool enableSSLCheckbox;
  late TorPlainNetworkOption netOption;

  late final bool enableAuthFields;

  void Function(bool canSave, bool canTestConnection)? onChanged;

  bool _checkShouldEnableAuthFields(CryptoCurrency coin) {
    // TODO: which coin servers can have username and password?
    switch (coin) {
      case Ethereum():
      case CryptonoteCurrency():
        return true;

      default:
        return false;
    }
  }

  bool get canSave {
    // 65535 is max tcp port
    return _nameController.text.isNotEmpty && canTestConnection;
  }

  bool get canTestConnection {
    // 65535 is max tcp port
    return _hostController.text.isNotEmpty &&
        port != null &&
        port! >= 0 &&
        port! <= 65535;
  }

  bool enableField(TextEditingController controller) {
    bool enable = true;
    if (widget.readOnly) {
      enable = controller.text.isNotEmpty;
    }
    return enable;
  }

  bool get shouldBeReadOnly =>
      widget.readOnly || widget.node?.isDefault == true;

  void _updateState() {
    port = int.tryParse(_portController.text);
    onChanged?.call(canSave, canTestConnection);
    ref.read(nodeFormDataProvider).name = _nameController.text;
    ref.read(nodeFormDataProvider).host = _hostController.text;
    ref.read(nodeFormDataProvider).login =
        _usernameController.text.isEmpty ? null : _usernameController.text;
    ref.read(nodeFormDataProvider).password =
        _passwordController.text.isEmpty ? null : _passwordController.text;
    ref.read(nodeFormDataProvider).port = port;
    ref.read(nodeFormDataProvider).useSSL = _useSSL;
    ref.read(nodeFormDataProvider).isFailover = _isFailover;
    ref.read(nodeFormDataProvider).trusted = _trusted;
    ref.read(nodeFormDataProvider).netOption = netOption;
  }

  @override
  void initState() {
    onChanged = widget.onChanged;
    _nameController = TextEditingController();
    _hostController = TextEditingController();
    _portController = TextEditingController();
    _passwordController = TextEditingController();
    _usernameController = TextEditingController();

    enableAuthFields = _checkShouldEnableAuthFields(widget.coin);

    if (widget.node != null) {
      final node = widget.node!;
      if (enableAuthFields) {
        if (widget.scannedPw == null) {
          node.getPassword(widget.secureStore).then((value) {
            if (value is String) {
              _passwordController.text = value;
            }
          });
        } else {
          _passwordController.text = widget.scannedPw!;
        }
      }

      _nameController.text = node.name;
      _hostController.text = node.host;
      _portController.text = node.port.toString();
      _usernameController.text = node.loginName ?? "";
      _useSSL = node.useSSL;
      _isFailover = node.isFailover;
      _trusted = node.trusted ?? false;

      if (node.torEnabled && !node.clearnetEnabled) {
        netOption = TorPlainNetworkOption.tor;
      } else if (node.clearnetEnabled && !node.torEnabled) {
        netOption = TorPlainNetworkOption.clear;
      } else {
        netOption = TorPlainNetworkOption.both;
      }

      if (widget.coin is Epiccash) {
        enableSSLCheckbox = !node.host.startsWith("http");
      } else {
        enableSSLCheckbox = true;
      }

      WidgetsBinding.instance.addPostFrameCallback((_) {
        // update provider state object so test connection works without having to modify a field in the ui first
        _updateState();
      });
    } else {
      enableSSLCheckbox = true;
      netOption = TorPlainNetworkOption.both;
      // default to port 3413
      // _portController.text = "3413";
    }

    super.initState();
  }

  @override
  void dispose() {
    _nameController.dispose();
    _hostController.dispose();
    _portController.dispose();
    _passwordController.dispose();
    _usernameController.dispose();

    _nameFocusNode.dispose();
    _passwordFocusNode.dispose();
    _usernameFocusNode.dispose();
    _hostFocusNode.dispose();
    _portFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ClipRRect(
          borderRadius: BorderRadius.circular(
            Constants.size.circularBorderRadius,
          ),
          child: TextField(
            autocorrect: Util.isDesktop ? false : true,
            enableSuggestions: Util.isDesktop ? false : true,
            key: const Key("addCustomNodeNodeNameFieldKey"),
            readOnly: shouldBeReadOnly,
            enabled: enableField(_nameController),
            controller: _nameController,
            focusNode: _nameFocusNode,
            style: STextStyles.field(context),
            decoration: standardInputDecoration(
              "Node name",
              _nameFocusNode,
              context,
            ).copyWith(
              suffixIcon: !shouldBeReadOnly && _nameController.text.isNotEmpty
                  ? Padding(
                      padding: const EdgeInsets.only(right: 0),
                      child: UnconstrainedBox(
                        child: Row(
                          children: [
                            TextFieldIconButton(
                              child: const XIcon(),
                              onTap: () async {
                                _nameController.text = "";
                                _updateState();
                              },
                            ),
                          ],
                        ),
                      ),
                    )
                  : null,
            ),
            onChanged: (newValue) {
              _updateState();
              setState(() {});
            },
          ),
        ),
        const SizedBox(
          height: 8,
        ),
        ClipRRect(
          borderRadius: BorderRadius.circular(
            Constants.size.circularBorderRadius,
          ),
          child: TextField(
            autocorrect: Util.isDesktop ? false : true,
            enableSuggestions: Util.isDesktop ? false : true,
            key: const Key("addCustomNodeNodeAddressFieldKey"),
            readOnly: shouldBeReadOnly,
            enabled: enableField(_hostController),
            controller: _hostController,
            focusNode: _hostFocusNode,
            style: STextStyles.field(context),
            decoration: standardInputDecoration(
              (widget.coin is! CryptonoteCurrency) ? "IP address" : "Url",
              _hostFocusNode,
              context,
            ).copyWith(
              suffixIcon: !shouldBeReadOnly && _hostController.text.isNotEmpty
                  ? Padding(
                      padding: const EdgeInsets.only(right: 0),
                      child: UnconstrainedBox(
                        child: Row(
                          children: [
                            TextFieldIconButton(
                              child: const XIcon(),
                              onTap: () async {
                                _hostController.text = "";
                                _updateState();
                              },
                            ),
                          ],
                        ),
                      ),
                    )
                  : null,
            ),
            onChanged: (newValue) {
              if (widget.coin is Epiccash) {
                if (newValue.startsWith("https://")) {
                  _useSSL = true;
                  enableSSLCheckbox = false;
                } else if (newValue.startsWith("http://")) {
                  _useSSL = false;
                  enableSSLCheckbox = false;
                } else {
                  enableSSLCheckbox = true;
                }
              } else if (widget.coin is LibMoneroWallet) {
                if (newValue.startsWith("https://")) {
                  _useSSL = true;
                } else if (newValue.startsWith("http://")) {
                  _useSSL = false;
                } else {
                  _useSSL = true;
                }
              }
              _updateState();
              setState(() {});
            },
          ),
        ),
        const SizedBox(
          height: 8,
        ),
        ClipRRect(
          borderRadius: BorderRadius.circular(
            Constants.size.circularBorderRadius,
          ),
          child: TextField(
            autocorrect: Util.isDesktop ? false : true,
            enableSuggestions: Util.isDesktop ? false : true,
            key: const Key("addCustomNodeNodePortFieldKey"),
            readOnly: shouldBeReadOnly,
            enabled: enableField(_portController),
            controller: _portController,
            focusNode: _portFocusNode,
            inputFormatters: [FilteringTextInputFormatter.digitsOnly],
            keyboardType: TextInputType.number,
            style: STextStyles.field(context),
            decoration: standardInputDecoration(
              "Port",
              _portFocusNode,
              context,
            ).copyWith(
              suffixIcon: !shouldBeReadOnly && _portController.text.isNotEmpty
                  ? Padding(
                      padding: const EdgeInsets.only(right: 0),
                      child: UnconstrainedBox(
                        child: Row(
                          children: [
                            TextFieldIconButton(
                              child: const XIcon(),
                              onTap: () async {
                                _portController.text = "";
                                _updateState();
                              },
                            ),
                          ],
                        ),
                      ),
                    )
                  : null,
            ),
            onChanged: (newValue) {
              _updateState();
              setState(() {});
            },
          ),
        ),
        const SizedBox(
          height: 8,
        ),
        if (enableAuthFields)
          ClipRRect(
            borderRadius: BorderRadius.circular(
              Constants.size.circularBorderRadius,
            ),
            child: TextField(
              autocorrect: Util.isDesktop ? false : true,
              enableSuggestions: Util.isDesktop ? false : true,
              controller: _usernameController,
              readOnly: shouldBeReadOnly,
              enabled: enableField(_usernameController),
              focusNode: _usernameFocusNode,
              style: STextStyles.field(context),
              decoration: standardInputDecoration(
                "Login (optional)",
                _usernameFocusNode,
                context,
              ).copyWith(
                suffixIcon:
                    !shouldBeReadOnly && _usernameController.text.isNotEmpty
                        ? Padding(
                            padding: const EdgeInsets.only(right: 0),
                            child: UnconstrainedBox(
                              child: Row(
                                children: [
                                  TextFieldIconButton(
                                    child: const XIcon(),
                                    onTap: () async {
                                      _usernameController.text = "";
                                      _updateState();
                                    },
                                  ),
                                ],
                              ),
                            ),
                          )
                        : null,
              ),
              onChanged: (newValue) {
                _updateState();
                setState(() {});
              },
            ),
          ),
        if (enableAuthFields)
          const SizedBox(
            height: 8,
          ),
        if (enableAuthFields)
          ClipRRect(
            borderRadius: BorderRadius.circular(
              Constants.size.circularBorderRadius,
            ),
            child: TextField(
              autocorrect: Util.isDesktop ? false : true,
              enableSuggestions: Util.isDesktop ? false : true,
              controller: _passwordController,
              readOnly: shouldBeReadOnly,
              enabled: enableField(_passwordController),
              obscureText: true,
              focusNode: _passwordFocusNode,
              style: STextStyles.field(context),
              decoration: standardInputDecoration(
                "Password (optional)",
                _passwordFocusNode,
                context,
              ).copyWith(
                suffixIcon:
                    !shouldBeReadOnly && _passwordController.text.isNotEmpty
                        ? Padding(
                            padding: const EdgeInsets.only(right: 0),
                            child: UnconstrainedBox(
                              child: Row(
                                children: [
                                  TextFieldIconButton(
                                    child: const XIcon(),
                                    onTap: () async {
                                      _passwordController.text = "";
                                      _updateState();
                                    },
                                  ),
                                ],
                              ),
                            ),
                          )
                        : null,
              ),
              onChanged: (newValue) {
                _updateState();
                setState(() {});
              },
            ),
          ),
        if (enableAuthFields)
          const SizedBox(
            height: 8,
          ),
        if (widget.coin is! CryptonoteCurrency)
          Row(
            children: [
              GestureDetector(
                onTap: !shouldBeReadOnly && enableSSLCheckbox
                    ? () {
                        setState(() {
                          _useSSL = !_useSSL;
                        });
                        _updateState();
                      }
                    : null,
                child: Container(
                  color: Colors.transparent,
                  child: Row(
                    children: [
                      SizedBox(
                        width: 20,
                        height: 20,
                        child: Checkbox(
                          fillColor: !shouldBeReadOnly && enableSSLCheckbox
                              ? null
                              : MaterialStateProperty.all(
                                  Theme.of(context)
                                      .extension<StackColors>()!
                                      .checkboxBGDisabled,
                                ),
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                          value: _useSSL,
                          onChanged: !shouldBeReadOnly && enableSSLCheckbox
                              ? (newValue) {
                                  setState(() {
                                    _useSSL = newValue!;
                                  });
                                  _updateState();
                                }
                              : null,
                        ),
                      ),
                      const SizedBox(
                        width: 12,
                      ),
                      Text(
                        "Use SSL",
                        style: STextStyles.itemSubtitle12(context),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        if (widget.coin is LibMoneroWallet)
          Row(
            children: [
              GestureDetector(
                onTap: !widget.readOnly /*&& trustedCheckbox*/
                    ? () {
                        setState(() {
                          _trusted = !_trusted;
                        });
                        _updateState();
                      }
                    : null,
                child: Container(
                  color: Colors.transparent,
                  child: Row(
                    children: [
                      SizedBox(
                        width: 20,
                        height: 20,
                        child: Checkbox(
                          fillColor: !widget.readOnly
                              ? null
                              : MaterialStateProperty.all(
                                  Theme.of(context)
                                      .extension<StackColors>()!
                                      .checkboxBGDisabled,
                                ),
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                          value: _trusted,
                          onChanged: !widget.readOnly
                              ? (newValue) {
                                  setState(() {
                                    _trusted = newValue!;
                                  });
                                  _updateState();
                                }
                              : null,
                        ),
                      ),
                      const SizedBox(
                        width: 12,
                      ),
                      Text(
                        "Trusted",
                        style: STextStyles.itemSubtitle12(context),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        if (widget.coin is! CryptonoteCurrency && widget.coin is! Epiccash)
          const SizedBox(
            height: 8,
          ),
        if (widget.coin is! CryptonoteCurrency && widget.coin is! Epiccash)
          Row(
            children: [
              GestureDetector(
                onTap: () {
                  setState(() {
                    _isFailover = !_isFailover;
                  });
                  if (widget.readOnly) {
                    ref.read(nodeServiceChangeNotifierProvider).edit(
                          widget.node!.copyWith(
                            isFailover: _isFailover,
                            loginName: widget.node!.loginName,
                            trusted: widget.node!.trusted,
                          ),
                          null,
                          true,
                        );
                  } else {
                    _updateState();
                  }
                },
                child: Container(
                  color: Colors.transparent,
                  child: Row(
                    children: [
                      SizedBox(
                        width: 20,
                        height: 20,
                        child: Checkbox(
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                          value: _isFailover,
                          onChanged: (newValue) {
                            setState(() {
                              _isFailover = newValue!;
                            });
                            if (widget.readOnly) {
                              ref.read(nodeServiceChangeNotifierProvider).edit(
                                    widget.node!.copyWith(
                                      isFailover: _isFailover,
                                      loginName: widget.node!.loginName,
                                      trusted: widget.node!.trusted,
                                    ),
                                    null,
                                    true,
                                  );
                            } else {
                              _updateState();
                            }
                          },
                        ),
                      ),
                      const SizedBox(
                        width: 12,
                      ),
                      Text(
                        "Use as failover",
                        style: STextStyles.itemSubtitle12(context),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        if (widget.coin is! Ethereum)
          const SizedBox(
            height: 16,
          ),
        if (widget.coin is! Ethereum)
          Row(
            children: [
              RadioTextButton(
                label: "Only TOR traffic",
                enabled: !widget.readOnly,
                value: TorPlainNetworkOption.tor,
                groupValue: netOption,
                onChanged: (value) {
                  if (!widget.readOnly) {
                    setState(
                      () => netOption = TorPlainNetworkOption.tor,
                    );
                    _updateState();
                  }
                },
              ),
            ],
          ),
        if (widget.coin is! Ethereum)
          const SizedBox(
            height: 8,
          ),
        if (widget.coin is! Ethereum)
          Row(
            children: [
              RadioTextButton(
                label: "Only non-TOR traffic",
                enabled: !widget.readOnly,
                value: TorPlainNetworkOption.clear,
                groupValue: netOption,
                onChanged: (value) {
                  if (!widget.readOnly) {
                    setState(
                      () => netOption = TorPlainNetworkOption.clear,
                    );
                    _updateState();
                  }
                },
              ),
            ],
          ),
        if (widget.coin is! Ethereum)
          const SizedBox(
            height: 8,
          ),
        if (widget.coin is! Ethereum)
          Row(
            children: [
              RadioTextButton(
                label: "Allow both",
                enabled: !widget.readOnly,
                value: TorPlainNetworkOption.both,
                groupValue: netOption,
                onChanged: (value) {
                  if (!widget.readOnly) {
                    setState(
                      () => netOption = TorPlainNetworkOption.both,
                    );
                    _updateState();
                  }
                },
              ),
            ],
          ),
      ],
    );
  }
}

class RadioTextButton<T> extends StatelessWidget {
  const RadioTextButton({
    super.key,
    required this.value,
    required this.label,
    required this.groupValue,
    required this.onChanged,
    this.enabled = true,
  });

  final T value;
  final String label;
  final T groupValue;
  final bool enabled;
  final void Function(T) onChanged;

  @override
  Widget build(BuildContext context) {
    return ConditionalParent(
      condition: Util.isDesktop,
      builder: (child) => MouseRegion(
        cursor: SystemMouseCursors.click,
        child: child,
      ),
      child: GestureDetector(
        onTap: () {
          if (value != groupValue) {
            onChanged.call(value);
          }
        },
        child: Container(
          color: Colors.transparent,
          child: Row(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              SizedBox(
                width: 20,
                height: 20,
                child: Radio<T>(
                  activeColor: Theme.of(context)
                      .extension<StackColors>()!
                      .radioButtonIconEnabled,
                  value: value,
                  groupValue: groupValue,
                  onChanged: !enabled
                      ? null
                      : (_) {
                          if (value != groupValue) {
                            onChanged.call(value);
                          }
                        },
                ),
              ),
              const SizedBox(
                width: 14,
              ),
              Text(
                label,
                style: STextStyles.w500_14(context),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
