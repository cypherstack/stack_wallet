/*
 * This file is part of Stack Wallet.
 *
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';

import '../themes/stack_colors.dart';
import '../utilities/text_styles.dart';
import '../utilities/util.dart';

class Options extends StatefulWidget {
  const Options({
    super.key,
    this.icons,
    this.texts,
    this.onValueChanged,
    required this.selectedIndex,
    this.controller,
    required this.onColor,
    required this.offColor,
    this.decoration,
  });

  final List<String>? icons;
  final List<String>? texts;
  final void Function(int)? onValueChanged;
  final int selectedIndex;
  final DSBController? controller;
  final Color onColor;
  final Color offColor;
  final BoxDecoration? decoration;

  @override
  OptionsState createState() => OptionsState();
}

class OptionsState extends State<Options> {
  late final BoxDecoration? decoration;
  late final Color onColor;
  late final Color offColor;
  late final DSBController? controller;

  final bool isDesktop = Util.isDesktop;

  late int _selectedIndex;
  int get selectedIndex => _selectedIndex;

  late ValueNotifier<double> valueListener;

  final tapAnimationDuration = const Duration(milliseconds: 150);
  bool _isDragging = false;

  @override
  initState() {
    onColor = widget.onColor;
    offColor = widget.offColor;
    decoration = widget.decoration;
    controller = widget.controller;
    _selectedIndex = widget.selectedIndex;
    valueListener = ValueNotifier(_selectedIndex.toDouble());

    widget.controller?.activate = () {
      _selectedIndex = (_selectedIndex + 1) % (widget.texts?.length ?? 1);
      valueListener.value = _selectedIndex.toDouble();
    };
    super.initState();
  }

  @override
  void dispose() {
    valueListener.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    debugPrint("BUILD: $runtimeType");
    final optionsCount = widget.texts?.length ?? 1;

    return GestureDetector(
      onTap: () {
        _selectedIndex = (_selectedIndex + 1) % optionsCount;
        widget.onValueChanged?.call(_selectedIndex);
        valueListener.value = _selectedIndex.toDouble();
        setState(() {});
      },
      child: LayoutBuilder(
        builder: (context, constraint) {
          return Stack(
            children: [
              AnimatedBuilder(
                animation: valueListener,
                builder: (context, child) {
                  return AnimatedContainer(
                    duration: tapAnimationDuration,
                    height: constraint.maxHeight,
                    width: constraint.maxWidth,
                    decoration: decoration?.copyWith(
                      color: offColor,
                    ),
                  );
                },
              ),
              Builder(
                builder: (context) {
                  final handle = GestureDetector(
                    key: const Key("draggableSwitchButtonSwitch"),
                    onHorizontalDragStart: (_) => _isDragging = true,
                    onHorizontalDragUpdate: (details) {
                      valueListener.value = (valueListener.value +
                              details.delta.dx / (constraint.maxWidth / optionsCount))
                          .clamp(0.0, optionsCount - 1.0);
                    },
                    onHorizontalDragEnd: (details) {
                      final int oldValue = _selectedIndex;
                      _selectedIndex = valueListener.value.round();
                      if (_selectedIndex != oldValue) {
                        widget.onValueChanged?.call(_selectedIndex);
                        setState(() {});
                      }
                      _isDragging = false;
                    },
                    child: AnimatedBuilder(
                      animation: valueListener,
                      builder: (context, child) {
                        return AnimatedContainer(
                          duration: tapAnimationDuration,
                          height: constraint.maxHeight,
                          width: constraint.maxWidth / optionsCount,
                          decoration: decoration?.copyWith(
                            color: onColor,
                          ),
                        );
                      },
                    ),
                  );
                  return AnimatedBuilder(
                    animation: valueListener,
                    builder: (context, child) {
                      return AnimatedAlign(
                        duration: _isDragging ? Duration.zero : tapAnimationDuration,
                        alignment: Alignment(
                          (valueListener.value * 2 / (optionsCount - 1)) - 1,
                          0.5,
                        ),
                        child: child,
                      );
                    },
                    child: handle,
                  );
                },
              ),
              IgnorePointer(
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: List.generate(optionsCount, (index) {
                    return SizedBox(
                      width: constraint.maxWidth / optionsCount,
                      child: Center(
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            if (widget.icons != null && widget.icons!.length > index)
                              SvgPicture.asset(
                                widget.icons![index],
                                width: 12,
                                height: 14,
                                color: isDesktop
                                    ? _selectedIndex != index
                                        ? Theme.of(context)
                                            .extension<StackColors>()!
                                            .accentColorBlue
                                        : Theme.of(context)
                                            .extension<StackColors>()!
                                            .buttonTextSecondary
                                    : _selectedIndex != index
                                        ? Theme.of(context)
                                            .extension<StackColors>()!
                                            .textDark
                                        : Theme.of(context)
                                            .extension<StackColors>()!
                                            .textSubtitle1,
                              ),
                            if (widget.icons != null && widget.icons!.length > index)
                              const SizedBox(
                                width: 5,
                              ),
                            Text(
                              widget.texts?[index] ?? "",
                              style: isDesktop
                                  ? STextStyles.desktopTextExtraExtraSmall(
                                      context,
                                    ).copyWith(
                                      color: _selectedIndex != index
                                          ? Theme.of(context)
                                              .extension<StackColors>()!
                                              .accentColorBlue
                                          : Theme.of(context)
                                              .extension<StackColors>()!
                                              .buttonTextSecondary,
                                    )
                                  : STextStyles.smallMed12(context).copyWith(
                                      color: _selectedIndex != index
                                          ? Theme.of(context)
                                              .extension<StackColors>()!
                                              .textDark
                                          : Theme.of(context)
                                              .extension<StackColors>()!
                                              .textSubtitle1,
                                    ),
                            ),
                          ],
                        ),
                      ),
                    );
                  }),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

class DSBController {
  VoidCallback? activate;
  bool? isOn;
}
